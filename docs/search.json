[
  {
    "objectID": "Inbreeding_depression_parental_care.html",
    "href": "Inbreeding_depression_parental_care.html",
    "title": "Inbreeding and parental care",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\n# making ggplot more powerful\n\nlibrary(MetBrewer) # for colour palettes based upon artwork housed at the MET\nlibrary(MoMAColors) # for colour palettes based upon artwork housed at MoMA\n\n\nRegistered S3 method overwritten by 'MoMAColors':\n  method        from     \n  print.palette MetBrewer\n\n\nCode\nlibrary(wesanderson) # for colour palettes based on wes anderson movies\n\n\nRegistered S3 method overwritten by 'wesanderson':\n  method        from      \n  print.palette MoMAColors\n\n\nCode\nlibrary(rcartocolor) # for nice sequential colour schemes\nlibrary(PNWColors) # for colour palettes \nlibrary(tidybayes) # for plotting distributions\nlibrary(stickylabeller) # labelling facets with strings in ggplot\nlibrary(geomtextpath) # for curved plot annotations\nlibrary(ggtext) # for markdown syntax in plot labels\nlibrary(patchwork) # for patching plots together\nlibrary(ggnewscale) # to reset scales in plots, allowing multiple fill arguments in ggplot"
  },
  {
    "objectID": "Inbreeding_depression_parental_care.html#current-theory",
    "href": "Inbreeding_depression_parental_care.html#current-theory",
    "title": "Inbreeding and parental care",
    "section": "Current theory",
    "text": "Current theory\nTo model the inclusive fitness gained from an inbred mating, three components that contribute to fitness are required:\n\nThe number of offspring that inherit the focal allele when outcrossing: \\(\\frac{1}{2}n\\)\nThe reduction in offspring produced due to inbreeding depression: \\(\\delta\\)\nThe indirect fitness gain (offspring that inherit anther copy of the focal allele) due to inbreeding: \\(\\frac{1}{2}rn\\), where \\(r\\) is the individual-level relatedness coefficient\n\nPut together, the inclusive fitness from a single inbred mating is:\n\\[\\frac{1}{2}n(1 - \\delta) + \\frac{1}{2}rn(1 - \\delta)\\]\n, while fitness from a single outbred mating is simply \\(\\frac{1}{2}n\\). It follows that when \\((1 + r)(1 - \\delta)n \\gt n\\) selection should favour a preference for inbreeding.\nIn his 1979 book chapter, Parker considered the inclusive fitness results of breeding with a relative and identified that females and males should have different tolerances for inbreeding depression. The key departure from the unlimited polygyny case presented in the above equations is that a cost to future reproductive success is included for males, i.e. due to finite sperm production, parental care, or harmful mating behaviour such as sexual cannibalism.\nParker modelled the condition for monandrous females to prefer incestuous matings when also presented with an outcrossing opportunity as\n\\[\\frac{1}{2}n(1 - \\delta) + \\frac{1}{2}rn(1-\\delta) - \\frac{1}{2}crn \\gt \\frac{1}{2}n\\]\nwhere the new third term on the lefthand side of the equation is the number of alleles that were not indirectly propagated by her male relative by future outcrossing. \\(c\\) is the cost of the present mating, relative to what is lost for a female. This can be considered a ratio of parental investment. When \\(c = 1\\) parental investment in the current bout of reproduction is even between the sexes. Alternatively, if males only contribute cheaply produced sperm to an incestuous mating, the cost of mating is likely very small relative to females i.e. \\(c ~ 0\\)."
  },
  {
    "objectID": "Inbreeding_depression_parental_care.html#what-if-parental-care-buffers-inbreeding-depression",
    "href": "Inbreeding_depression_parental_care.html#what-if-parental-care-buffers-inbreeding-depression",
    "title": "Inbreeding and parental care",
    "section": "What if parental care buffers inbreeding depression?",
    "text": "What if parental care buffers inbreeding depression?\nWe can model this by allowing \\(c\\) to affect \\(\\delta\\). Specifically, we need an equation where an increase in \\(c\\) reduces the size of \\(\\delta\\).Something like this should work: \\(\\delta(1-\\alpha c)\\), where \\(\\alpha\\) controls the potential for male care to abate the costs of inbreeding depression. If \\(\\alpha = 1\\), males that invest in care just as much as females can completely offset the effects of inbreeding depression, whereas if \\(\\alpha = 0\\) male care does not affect inbreeding depression.\n\n\nCode\nbuffered_depression &lt;- expand_grid(D = seq(from = 0, to = 1, by = 0.05),\n                          c = seq(from = 0, to = 1, by = 0.05),\n                          a = seq(from = 0, to = 1, by = 0.05)) %&gt;% \n  mutate(buffered_depression = D*(1 - c*a))\n\n\nheatmap_colours &lt;- rcartocolor::carto_pal(\"Emrld\", n = 20)\n\nbuffered_depression %&gt;%\n  filter(a == 0.1 | a == 0.25 | a == 0.5 | a == 1) %&gt;%\n  mutate(a = a*100) %&gt;% \n  ggplot(aes(x = c, y = D)) +\n  geom_tile(aes(fill = buffered_depression)) +\n  stat_textcontour(aes(z = buffered_depression), colour = \"black\", \n               binwidth = 25, breaks = c(0, 0.2, 0.4, 0.6, 0.8)) +\n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  facet_wrap(~a, nrow = 3,\n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('Buffering potential = {`a`}%')) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 1)) +\n  labs(x = '_c_ (Male parental effort relative to caring female)',\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Realised\\ninbreeding\\ndepression\") +\n  scale_x_continuous(expand = c(0, 0), \n                     breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0), \n                     breaks = c(0.2, 0.4, 0.6, 0.8, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.x = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\n\n\n\n\n\n\n\nCode\n# (prop fitness lost)\\n that can be tolerated\"\n\n\n\n\nCode\nbuffered_depression_a &lt;- expand_grid(D = seq(from = 0, to = 1, by = 0.1),\n                          c = seq(from = 0, to = 1, by = 0.01),\n                          a = seq(from = 0, to = 1, by = 0.05)) %&gt;% \n  mutate(buffered_depression = D*(1 - c*a))\n\n\nbuffered_depression_a %&gt;% \n  filter(a == 0.1 | a == 0.25 | a == 0.5 | a == 1) %&gt;%\n  ggplot(aes(x = c, y = buffered_depression, colour = D, group = D)) +\n  geom_line(linewidth = 1) +\n  facet_wrap(~a) +\n  scale_colour_carto_c(palette = \"SunsetDark\", type = \"qualitative\",\n                       limits = c(0, 1)) +\n  facet_wrap(~a, nrow = 3,\n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('Care potency = {`a`}')) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 1)) +\n  labs(x = '_c_ (Male parental effort relative to caring female)',\n       y = 'Realised inbreeding depression',\n       colour = ~delta~'') +\n  scale_x_continuous(expand = c(0, 0), \n                     breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0), \n                     breaks = c(0.2, 0.4, 0.6, 0.8, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.x = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))"
  },
  {
    "objectID": "Inbreeding_depression_parental_care.html#what-does-this-mean-for-the-evolution-of-inbreeding",
    "href": "Inbreeding_depression_parental_care.html#what-does-this-mean-for-the-evolution-of-inbreeding",
    "title": "Inbreeding and parental care",
    "section": "What does this mean for the evolution of inbreeding?",
    "text": "What does this mean for the evolution of inbreeding?\nFor alleles expressed in females, the inequality becomes\n\\[n(1 - \\delta(1-\\alpha c)) + rn(1-\\delta(1-\\alpha c)) - crn \\gt n\\] Rearrange to find the female inbreeding tolerance\n\\[\\delta_{f} = -\\frac{(c + 1)r}{(r + 1) (\\alpha c - 1)}\\]\nThis is the level of inbreeding depression below which inbreeding is favoured by selection.\nWe can now compare \\(\\delta_{f}\\) at various levels of care and care potency.\n\n\nCode\nbuffered_depression &lt;- \n  expand_grid(D = seq(from = 0, to = 1, by = 0.05),\n              c = seq(from = 0, to = 1, by = 0.1),\n              r = seq(from = 0, to = 1, by = 0.05),\n              a = c(0, 0.1, 0.25, 0.5, 0.75, 0.99)) %&gt;% \n  mutate(depression_threshold = ((c - 1)*r) / ((r + 1)*(a*c - 1))\n         )\n\nbuffered_depression %&gt;% \n  mutate(a = a*100) %&gt;%\n  ggplot(aes(x = r, y = depression_threshold, colour = c, group = c)) +\n  geom_line(linewidth = 0.8) + \n  scale_colour_carto_c(palette = \"Sunset\", type = \"qualitative\",\n                       limits = c(0, 1)) +\n  facet_wrap(~a, nrow = 3,\n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('Buffering potential = {`a`}%')) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 1)) +\n  labs(x = '_r_, the relatedness coefficient',\n       y = ~ paste(delta[f], \" (inbreeding tolerance threshold in females)\"),\n       colour = \"_c_\") +\n  scale_x_continuous(expand = c(0, 0.009)) + \n  scale_y_continuous(expand = c(0, 0)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.x = element_markdown(),\n        legend.title = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\n\n\n\n\n\n\n\nPerhaps more helpfully, we can consider the case of mating between full-siblings and explore the point at which \\(\\alpha\\), the potency of care, qualitatively starts to change what we would predict:\n\n\nCode\neffectiveness_care &lt;- \n  expand_grid(c = seq(from = 0, to = 1, by = 0.01),\n              a = seq(from = 0, to = 1, by = 0.01),) %&gt;% \n  mutate(depression_threshold = ((c - 1)*0.5) / ((0.5 + 1)*(a*c - 1)))\n\neffectiveness_care %&gt;% \n  ggplot(aes(x = a, y = c)) +\n  geom_tile(aes(fill = depression_threshold)) +\n  stat_textcontour(aes(z = depression_threshold), colour = \"black\", \n               binwidth = 5, breaks = c(0, 0.1, 0.2, 0.3)) +\n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 0.334)) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 1)) +\n  labs(x = ~alpha~'(Potency of male care)',\n       y = \"_c_ (Male investment in care relative to caring female)\",\n       fill = ~ paste(delta[f])) +\n  scale_x_continuous(expand = c(0, 0), \n                     breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0), \n                     breaks = c(0.2, 0.4, 0.6, 0.8, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\nWarning: Removed 1 row containing non-finite outside the scale range\n(`stat_textcontour()`).\n\n\n\n\n\n\n\n\n\nFinally, we can show how inbreeding invades with male care, compared with to a system where males do not invest in care. Note that inbreeding is always more permissable when there is no male care. However, the negative effect of care on the invasion prospects of mutant inbreeding alleles is blunted when care has a potent impact on realised inbreeding depression.\nFix decimal places for text on contours\n\n\nCode\nexpand_grid(c = seq(from = 0, to = 1, by = 0.01),\n            a = seq(from = 0, to = 1, by = 0.01),\n            r = c(0.1, 0.25, 0.5, 1)) %&gt;% \n  mutate(depression_threshold = ((c - 1)*r) / ((r + 1)*(a*c - 1)),\n         no_care_threshold = r/(1 + r),\n         care_effect = depression_threshold - no_care_threshold,\n         care_effect_prop = depression_threshold / no_care_threshold) %&gt;% \n  filter(r == 0.5) %&gt;% \n  # plot\n  ggplot(aes(x = a, y = c)) +\n  geom_tile(aes(fill = care_effect_prop)) +\n  stat_textcontour(aes(z = care_effect_prop), colour = \"black\", \n                   breaks = c(0.2, 0.4, 0.6, 0.8, 0.9)) +\n  scale_fill_gradientn(colours = heatmap_colours#, limits = c(0, 0.334)\n                       ) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 1)) +\n  labs(x = ~alpha~'(Potency of care)',\n       y = \"_c_ (Male investment in care realtive to caring female)\",\n       fill = \"Inbreeding threshold\\nrelative to\\nno male care\") +\n  #facet_wrap(~r, nrow = 2,\n  #           scales = \"free\", strip.position = c(\"top\"),\n   #          labeller = label_glue('r = {`r`}')) +\n  scale_x_continuous(expand = c(0, 0), \n                     breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0), \n                     breaks = c(0.2, 0.4, 0.6, 0.8, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\nWarning: Removed 1 row containing non-finite outside the scale range\n(`stat_textcontour()`)."
  },
  {
    "objectID": "Inbreeding_depression_parental_care.html#what-if-care-has-diminishing-returns",
    "href": "Inbreeding_depression_parental_care.html#what-if-care-has-diminishing-returns",
    "title": "Inbreeding and parental care",
    "section": "What if care has diminishing returns?",
    "text": "What if care has diminishing returns?\nShikhara advice: don’t specify functional forms. Too arbitrary\nAlternatively, we could model care using an exponential rather than linear function, such that there are diminishing returns when increasing the effort put into care when care is already strong.\nThe equation now looks like this\n\\[n(1 - \\frac{\\delta}{e^{\\alpha c}}) + rn(1 - \\frac{\\delta}{e^{\\alpha c}}) - crn \\gt n\\] Realised inbreeding depression behaves like this, where \\(\\alpha\\), the potency of male care, is now a rate multiplier:\n\n\nCode\nbuffered_depression_2 &lt;- expand_grid(D = seq(from = 0, to = 1, by = 0.05),\n                          c = seq(from = 0, to = 1, by = 0.05),\n                          a = seq(from = 0, to = 10, by = 0.05)) %&gt;% \n  mutate(buffered_depression = D*exp(-a*c))\n\nbuffered_depression_2 %&gt;%\n  filter(a == 0.25 | a == 1 | a == 3 | a == 10) %&gt;%\n  ggplot(aes(x = c, y = D)) +\n  geom_tile(aes(fill = buffered_depression)) +\n  stat_textcontour(aes(z = buffered_depression), colour = \"black\", \n               binwidth = 25, breaks = c(0, 0.2, 0.4, 0.6, 0.8)) +\n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  facet_wrap(~a, nrow = 3,\n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('Care potency = {`a`}')) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 1)) +\n  labs(x = '_c_ (Male parental effort relative to caring female)',\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Realised\\ninbreeding\\ndepression\") +\n  scale_x_continuous(expand = c(0, 0), \n                     breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0), \n                     breaks = c(0.2, 0.4, 0.6, 0.8, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.x = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\nWarning: The text offset exceeds the curvature in one or more paths. This will result in\ndisplaced letters. Consider reducing the vjust or text size, or use the hjust\nparameter to move the string to a different point on the path.\n\n\n\n\n\n\n\n\n\nCode\n# (prop fitness lost)\\n that can be tolerated\"\n\n\nPlotted another way:\n\n\nCode\nbuffered_depression_2a &lt;- expand_grid(D = seq(from = 0, to = 1, by = 0.1),\n                          c = seq(from = 0, to = 1, by = 0.01),\n                          a = seq(from = 0, to = 10, by = 0.05)) %&gt;% \n  mutate(buffered_depression = D*exp(-a*c))\n\n\nbuffered_depression_2a %&gt;% \n  filter(a == 0.25 | a == 1 | a == 3 | a == 10) %&gt;%\n  ggplot(aes(x = c, y = buffered_depression, colour = D, group = D)) +\n  geom_line(linewidth = 1) +\n  facet_wrap(~a) +\n  scale_colour_carto_c(palette = \"SunsetDark\", type = \"qualitative\",\n                       limits = c(0, 1)) +\n  facet_wrap(~a, nrow = 3,\n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('Care potency = {`a`}')) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 1)) +\n  labs(x = '_c_ (Male parental effort relative to caring female)',\n       y = 'Realised inbreeding depression',\n       colour = ~delta~'') +\n  scale_x_continuous(expand = c(0, 0), \n                     breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0), \n                     breaks = c(0.2, 0.4, 0.6, 0.8, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.x = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\n\n\n\n\n\n\n\nOnce again we can rearrange to find the female inbreeding tolerance\n\\[\\delta_{f} = -\\frac{(c - 1)e^{ac}r}{(r + 1)}\\] This is the level of inbreeding depression below which inbreeding is favoured by selection.\nWe can now compare \\(\\delta_{f}\\) at various levels of care and care potency.\n\n\nCode\nbuffered_depression_2b &lt;- \n  expand_grid(D = seq(from = 0, to = 1, by = 0.05),\n              c = seq(from = 0, to = 1, by = 0.1),\n              r = seq(from = 0, to = 1, by = 0.05),\n              a = c(0, 0.25, 1, 3, 10)) %&gt;% \n  mutate(depression_threshold = -1*((c - 1)* exp(a*c)*r) / ((r + 1))\n  )\n\nbuffered_depression_2b %&gt;% \n  ggplot(aes(x = r, y = depression_threshold, colour = c, group = c)) +\n  geom_line(linewidth = 0.8) + \n  scale_colour_carto_c(palette = \"Sunset\", type = \"qualitative\",\n                       limits = c(0, 1)) +\n  facet_wrap(~a, nrow = 3,\n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('Care potency = {`a`}')) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 1)) +\n  labs(x = '_r_, the relatedness coefficient',\n       y = ~ paste(delta[f], \" (inbreeding tolerance threshold in females)\"),\n       colour = \"_c_\") +\n  scale_x_continuous(expand = c(0, 0.009)) + \n  scale_y_continuous(expand = c(0, 0)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.x = element_markdown(),\n        legend.title = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\n\n\n\n\n\n\n\nPerhaps more helpfully, we can consider the case of mating between full-siblings and explore the point at which \\(\\alpha\\), the potency of care, qualitatively starts to change what we would predict:\n\n\nCode\neffectiveness_care &lt;- \n  expand_grid(c = seq(from = 0, to = 1, by = 0.01),\n              a = seq(from = 0, to = 10, by = 0.01),) %&gt;% \n  mutate(depression_threshold = -1*((c - 1)* exp(a*c)*0.5) / ((0.5 + 1)),\n         depression_threshold = if_else(depression_threshold &gt; 1, 1, depression_threshold))\n\n\neffectiveness_care %&gt;% \n  ggplot(aes(x = a, y = c)) +\n  geom_tile(aes(fill = depression_threshold)) +\n  stat_textcontour(aes(z = depression_threshold), colour = \"black\", \n               binwidth = 5, breaks = c(0.2, 0.4, 0.6, 0.8, 1)) +\n  scale_fill_gradientn(colours = heatmap_colours) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 10)) +\n  labs(x = ~alpha~'(Potency of male care)',\n       y = \"_c_ (Male investment in care relative to caring female)\",\n       fill = ~ paste(delta[f])) +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0), \n                     breaks = c(0.2, 0.4, 0.6, 0.8, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\n\n\n\n\n\n\n\nFinally, we can show how inbreeding invades with male care, compared with to a system where males do not invest in care. Note that inbreeding is always more permissible when there is no male care. However, the negative effect of care on the invasion prospects of mutant inbreeding alleles is blunted when care has a potent impact on realised inbreeding depression.\n\n\nCode\nheatmap_colours_diverging &lt;- rcartocolor::carto_pal(\"Temps\", n = 20)\n\nexpand_grid(c = seq(from = 0, to = 1, by = 0.01),\n            a = seq(from = 0, to = 10, by = 0.01),\n            r = c(0.1, 0.25, 0.5, 1)) %&gt;% \n  mutate(depression_threshold = -1*((c - 1)* exp(a*c)*r) / ((r + 1)),\n         depression_threshold = if_else(depression_threshold &gt; 1, 1, depression_threshold),\n         no_care_threshold = r/(1 + r),\n         care_effect = depression_threshold - no_care_threshold,\n         care_effect_prop = depression_threshold / no_care_threshold) %&gt;% \n  #filter(r == 0.5) %&gt;% \n  # plot\n  ggplot(aes(x = a, y = c)) +\n  geom_tile(aes(fill = care_effect)) +\n  stat_textcontour(aes(z = care_effect), colour = \"black\", \n                   breaks = c(0)) +\n  scale_fill_gradientn(colours = heatmap_colours_diverging, limits = c(-1, 1)) +\n  coord_cartesian(ylim = c(0, 1), xlim = c(0, 5)) +\n  labs(x = ~alpha~'(Potency of care)',\n       y = \"_c_ (Male investment in care realtive to caring female)\",\n       fill = \"Inbreeding threshold\\nrelative to\\nno male care\") +\n  facet_wrap(~r, nrow = 2,\n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('r = {`r`}')) +\n  scale_x_continuous(expand = c(0, 0)) + \n   #                  breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0), \n                     breaks = c(0.2, 0.4, 0.6, 0.8, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))"
  },
  {
    "objectID": "Inbreeding_depression_parental_care.html#key-findings",
    "href": "Inbreeding_depression_parental_care.html#key-findings",
    "title": "Inbreeding and parental care",
    "section": "Key findings",
    "text": "Key findings\nMale care makes it more difficult for inbreeding alleles to invade. However, if care has a strong buffering effect on inbreeding depression, inbreeding can be favoured by selection even when males invest a lot in care.\nEmpirically, it would be very interesting to quantify the effectiveness of care for buffering inbreeding depression, for varying levels of caring effort.\nTheoretically, coevolution between caring loci and inbreeding loci is a logical, and powerful, next step. Does inbreeding make care more valuable? We need life-history theory for this."
  },
  {
    "objectID": "Inbreeding_depression_parental_care.html#next-males-and-females-that-have-future-breeding-prospects",
    "href": "Inbreeding_depression_parental_care.html#next-males-and-females-that-have-future-breeding-prospects",
    "title": "Inbreeding and parental care",
    "section": "Next: males, and females that have future breeding prospects",
    "text": "Next: males, and females that have future breeding prospects"
  },
  {
    "objectID": "Cuts/useful_text.html",
    "href": "Cuts/useful_text.html",
    "title": "USeful_text",
    "section": "",
    "text": "Here, we set N = 1000 and find the encounter time for the \\(500^2\\) possible female-male encounters.\n\\(v\\) is one of the parameters that we can vary to change the risk of an individual going unmated. Here, we create candidate lists of mating events where \\(v = 1\\), \\(v =10\\), \\(v = 100\\) and \\(v = 1000\\) (where v = 100 equates to a search efficiency equal to the rate of mortality when \\(N = 1000)\\)."
  },
  {
    "objectID": "Cuts/old_sim_with_plots.html",
    "href": "Cuts/old_sim_with_plots.html",
    "title": "old_sim_with_plots",
    "section": "",
    "text": "Parker’s \\(c\\) value offers a simple, intuitive way to model the cost of mating for males relative to females. However, other methods better capture the self-consistent dynamics of real populations, where both sexes also run the risk of going unmated. To incorporate both costs of mating and the possibility of matelessness, we simulate the invasion of an allele that encodes a preference for inbreeding, for loci on various chromosomes that are expressed in either females or males.\nThe simulation progresses continuously through time by jumping from event to event. Events are calculated via a Gillespie-like algorithm, which involves both memory-less processes and others that are maintained through time. Events can trigger state changes for the individuals in the population, leading to death, mating, inheritance of a breeding site or offspring production. We simulate a population where monandrous females have the opportunity to mate with a relative early in life. Whether they do so depends on their genotype at the inbreeding locus or the genotype of their male relative. The simulation ends when the inbreeding allele is purged from the population, it reaches a high frequency in the population, the population goes extinct, or the time limit elapses.\nFollowing Ekrem and Kokko (2023), mortality events are drawn from an exponential distribution with rate \\(\\lambda = 1/\\mu\\), where \\(\\mu\\) is the mean time till death. The probability of mortality is therefore constant across life for each sex.\nLets have a look at the mean lifespan drawn from the exponential distribution parameterised with different mortality rates:\n\n\nCode\n#exponential_draws &lt;-\n  tibble(`Mean lifespan` = seq(from = 0.001, to = 1.001, by = 0.1)) %&gt;% \n  mutate(`Corresponding mortality rate` = round(1/`Mean lifespan`, 1),\n         `Mean lifespan` = round(`Mean lifespan`, 3)) %&gt;% \n  arrange(-`Mean lifespan`) %&gt;% \n  pander()\n\n\nWe use these values to inform our parameterisation of inbreeding depression (\\(\\delta\\)). Females that outcross produce offspring with a mean lifespan of 1 time unit (\\(\\lambda = 1\\)). For inbred offspring, we model inbreeding depression by increasing the risk of mortality (\\(\\lambda = 1 + \\delta\\)), lowering the mean lifespan of inbred individuals relative to their outbred counterparts.\nFemale-male encounters are found using the mass action law (also called fertilisation kinetics in this biological context), with male search efficiency \\(v\\). Crucially, a female’s first encounter with a receptive male is always with a brother (if they exist). While this may seem somewhat artificial, it allows us to test whether alleles coding for inbreeding are favoured by selection, and is an assumption grounded in biological reality as individuals often live as juveniles with close kin before dispersing and mixing with the larger population.\nTo get an idea of how \\(v\\) influences mating encounters, we plot the mean proportion of the opposite-sex part of the population that an individual male meets across his entire life.\n\n\nCode\ndata &lt;-\n  expand_grid(v = c(0.02, 0.05, 2, 5),\n              lifespan = c(0.01, 0.1, 0.5, 1),\n         pop_size = rep(100, 10000)) %&gt;% \n  mutate(encounter = rexp(160000, rate = v)) %&gt;% \n  group_by(v, lifespan) %&gt;% \n  summarise(n_females = n(),\n              lifetime_encounters = sum(encounter &lt; lifespan),\n              prop_females_encountered = lifetime_encounters / n_females) %&gt;% \n  ungroup() %&gt;% \n   mutate(v = as.factor(v),\n         lifespan = as.factor(lifespan))\n\ndata  %&gt;% \n  ggplot(aes(x = lifespan, y = prop_females_encountered)) +\n   geom_col(fill = \"#d0e2af\", alpha = 1) +\n  scale_y_continuous(expand = c(0.0, 0.01), limits = c(0, 1)) + \n  labs(x = \"Mean lifespan\",\n       y = \"Proportion of female population encountered throughout lifetime\") +\n  #facet_wrap(~ lifespan) +\n  facet_wrap(~v, nrow = 2,\n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('Male search efficiency = {`v`}')) +\n  theme_bw() +\n  theme(strip.background = element_rect(colour = \"black\", fill = \"aliceblue\"),\n        strip.text = element_text(size = 12),\n        axis.title = element_text(size = 12))\n\n\nFigure. SX: the proportion of the female population encountered by a single male across his lifetime, split by how efficiently males search for females. If there are 100 females in the population, a value of 0.1 indicates the male encounters 10 females on average. The decline in potential mating encounters as lifespan decreases indicates the severity of the inbreeding depression cost for males.\nThe cost of inbreeding depression manifests differently for females, where the ability to reproduce depends on mating with a male and securing a breeding site. If the population is at carrying capacity, the latter criterion is a function of age, as breeding sites are allocated randomly to non-breeding females once a breeder dies. Therefore, the longer a female lives, the more opportunities she has of becoming a breeder. If the population is below carrying capacity, the cost of inbreeding is less severe, as a new female can immediately secure a breeding site, leaving mating as the only restriction to offspring production.\n\n\nTo simulate the invasion of alleles found on different chromosomes, we consider simple single-locus, two-allele dynamics. For each chromosomal inheritance system, we build a mating table, which tracks the production of new genotypes from each possible mother-father pair of genotypes in the population. Inheritance is mendelian, except for cytoplasmic chromosomes, which are exclusively maternally inherited.\nThe simulation tracks the invasion of an allele encoding a preference for inbreeding (denoted I), into a population initially dominated by an allele that encodes inbreeding avoidance (denoted O for outbreeding).\n\n\nCode\nmake_mating_table &lt;- function(gene_location){\n  \n  make_offspring &lt;- function(X, Y, offspring_genotype, zygote_freq, gene_location){\n    tibble(Female_genotype = X,\n           Male_genotype = Y,\n           offspring_genotype,\n           zygote_freq,\n           locus_type = gene_location)\n  }\n  \n  # Specify the possible offspring genotypes for all the potential crosses; we use these for the offspring_genotype argument in the make_offspring function\n  \n  # autosomal\n  \n  # II x II\n  # 2 X 2\n  \n  #a_genotype_1 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\")\n  a_cross_1 &lt;- 2\n  \n  # II x IO\n  # 2 X 1\n  #a_genotype_2 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\", \n                    #\"A_IA_O.Female\", \"A_IA_O.Male\")\n  a_cross_2 &lt;- c(1, 2)\n  \n  # II x OO\n  # 2 X 0\n  #a_genotype_3 &lt;- c(\"A_IA_O.Female\", \"A_IA_O.Male\")\n  a_cross_3 &lt;- 1\n  \n  # IO x IO\n  \n  #a_genotype_4 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\", \n   #                 \"A_IA_O.Female\", \"A_IA_O.Male\", \n    #                \"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  a_cross_4 &lt;- c(0, 1, 2)\n  \n  # IO x OO\n  \n  #a_genotype_5 &lt;- c(\"A_IA_O.Female\", \"A_IA_O.Male\",\n   #                 \"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  a_cross_5 &lt;- c(0, 1)\n  \n  # OO x OO\n  \n  #a_genotype_6 &lt;- c(\"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  a_cross_6 &lt;- 0\n  \n  # XY\n  \n  \n  # II x IY_I\n  \n  xy_genotype_1 &lt;- c(\"X_IX_I.Female\", \"X_IY_I.Male\")\n  \n  # II x IY_O\n  \n  xy_genotype_2 &lt;- c(\"X_IX_I.Female\", \"X_IY_O.Male\")\n  \n  # II x OY_I\n  \n  xy_genotype_3 &lt;- c(\"X_IX_O.Female\", \"X_IY_I.Male\")\n  \n  # II x OY_O\n  \n  xy_genotype_4 &lt;- c(\"X_IX_O.Female\", \"X_IY_O.Male\")\n  \n  # IO x IY_I\n  \n  xy_genotype_5 &lt;- c(\"X_IX_I.Female\", \"X_IY_I.Male\",\n                     \"X_IX_O.Female\", \"X_OY_I.Male\")\n  \n  # IO x IY_O\n  \n  xy_genotype_6 &lt;- c(\"X_IX_I.Female\", \"X_IY_O.Male\", \n                     \"X_IX_O.Female\", \"X_OY_O.Male\")\n  \n  # IO x OY_I\n  \n  xy_genotype_7 &lt;- c(\"X_IX_O.Female\", \"X_IY_I.Male\",\n                     \"X_OX_O.Female\", \"X_OY_I.Male\")\n  \n  # IO x OY_O\n  \n  xy_genotype_8 &lt;- c(\"X_IX_O.Female\", \"X_IY_O.Male\",\n                     \"X_OX_O.Female\", \"X_OY_O.Male\")\n  \n  # OO x IY_I\n  \n  xy_genotype_9 &lt;- c(\"X_IX_O.Female\", \"X_OY_I.Male\")\n  \n  # OO x IY_O\n  \n  xy_genotype_10 &lt;- c(\"X_IX_O.Female\", \"X_OY_O.Male\")\n  \n  # OO x OY_I\n  \n  xy_genotype_11 &lt;- c(\"X_OX_O.Female\", \"X_OY_I.Male\")\n  \n  # OO x OY_O\n  \n  xy_genotype_12 &lt;- c(\"X_OX_O.Female\", \"X_OY_O.Male\")\n  \n  # ZW\n  \n  # IW_I x II\n  \n  zw_genotype_1 &lt;- c(\"Z_IZ_I.Male\", \"Z_IW_I.Female\")\n  \n  # IW_I x IO\n  \n  zw_genotype_2 &lt;- c(\"Z_IZ_I.Male\", \"Z_IZ_O.Male\", \n                     \"Z_IW_I.Female\", \"Z_OW_I.Male\")\n  \n  # IW_I x OO\n  \n  zw_genotype_3 &lt;- c(\"Z_IZ_O.Male\", \"Z_OW_I.Female\")\n  \n  # IW_O x II\n  \n  zw_genotype_4 &lt;- c(\"Z_IZ_I.Male\", \"Z_IW_O.Female\")\n  \n  # IW_O x IO\n  \n  zw_genotype_5 &lt;- c(\"Z_IZ_I.Male\", \"Z_IZ_O.Male\",\n                     \"Z_IW_O.Female\", \"Z_OW_O.Female\")\n  \n  # IW_O x OO\n  \n  zw_genotype_6 &lt;- c(\"Z_IZ_O.Male\", \"Z_OW_O.Female\")\n  \n  # OW_I X II\n  \n  zw_genotype_7 &lt;- c(\"Z_IZ_O.Male\", \"Z_IW_I.Female\")\n  \n  # OW_I x IO\n  \n  zw_genotype_8 &lt;- c(\"Z_IZ_O.Male\", \"Z_OZ_O.Male\",\n                     \"Z_IW_I.Female\", \"Z_OW_I.Female\")\n  \n  # OW_I x OO\n  \n  zw_genotype_9 &lt;- c(\"Z_OZ_O.Male\", \"Z_OW_I.Female\")\n  \n  # OW_O X II\n  \n  zw_genotype_10 &lt;- c(\"Z_IZ_O.Male\", \"Z_IW_O.Female\")\n  \n  # OW_O x IO\n  \n  zw_genotype_11 &lt;- c(\"Z_IZ_O.Male\", \"Z_OZ_O.Male\",\n                      \"Z_IW_O.Female\", \"Z_OW_O.Female\")\n  \n  # OW_O x OO\n  \n  zw_genotype_12 &lt;- c(\"Z_OZ_O.Male\", \"Z_OW_O.Female\")\n  \n  # cytoplasmic\n  \n  # I x I\n  # I x O\n  \n  c_genotype_1 &lt;- c(\"C_I.Female\", \"C_I.Male\")\n  \n  # O x O\n  # O x I\n  \n  c_genotype_2 &lt;- c(\"C_O.Female\", \"C_O.Male\")\n  \n  \n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # autosomal\n  \n  # even frequency of two offspring genotypes\n  \n  freq_2 &lt;- rep(0.5, 2)\n  \n  # even frequency between four offspring types\n  \n  freq_4 &lt;- rep(0.25, 4)\n  \n  # when there are 6 offspring genotypes\n  \n  freq_6 &lt;- c(0.125, 0.125,\n              0.25, 0.25,\n              0.125, 0.125)\n  \n  bind_rows(\n    list(\n      make_offspring(\"A_IA_I\", \"A_IA_I\", a_genotype_1, freq_2, \"autosomal\"),\n      make_offspring(\"A_IA_I\", \"A_IA_O\", a_genotype_2, freq_4, \"autosomal\"),\n      make_offspring(\"A_IA_I\", \"A_OA_O\", a_genotype_3, freq_2, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_IA_I\", a_genotype_2, freq_4, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_IA_O\", a_genotype_4, freq_6, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_OA_O\", a_genotype_5, freq_4, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_IA_I\", a_genotype_3, freq_2, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_IA_O\", a_genotype_5, freq_4, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_OA_O\", a_genotype_6, freq_2, \"autosomal\"),\n      \n      make_offspring(\"X_IX_I\", \"X_IY_I\", xy_genotype_1, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_IY_O\", xy_genotype_2, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_OY_I\", xy_genotype_3, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_OY_O\", xy_genotype_4, freq_2, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_IY_I\", xy_genotype_5, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_IY_O\", xy_genotype_6, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_OY_I\", xy_genotype_7, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_OY_O\", xy_genotype_8, freq_4, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_IY_I\", xy_genotype_9, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_IY_O\", xy_genotype_10, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_OY_I\", xy_genotype_11, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_OY_O\", xy_genotype_12, freq_2, \"XY\"),\n      \n      make_offspring(\"Z_IW_I\", \"Z_IZ_I\", zw_genotype_1, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_I\", \"Z_IZ_O\", zw_genotype_2, freq_4, \"ZW\"),\n      make_offspring(\"Z_IW_I\", \"Z_OZ_O\", zw_genotype_3, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_IZ_I\", zw_genotype_4, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_IZ_O\", zw_genotype_5, freq_4, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_OZ_O\", zw_genotype_6, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_I\", \"Z_IZ_I\", zw_genotype_7, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_I\", \"Z_IZ_O\", zw_genotype_8, freq_4, \"ZW\"),\n      make_offspring(\"Z_OW_I\", \"Z_OZ_O\", zw_genotype_9, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_IZ_I\", zw_genotype_10, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_IZ_O\", zw_genotype_11, freq_4, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_OZ_O\", zw_genotype_12, freq_2, \"ZW\"),\n      \n      make_offspring(\"C_I\", \"C_I\", c_genotype_1, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_I\", \"C_O\", c_genotype_1, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_O\", \"C_I\", c_genotype_2, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_O\", \"C_O\", c_genotype_2, freq_2, \"cytoplasmic\")\n    )) %&gt;% \n    filter(locus_type == gene_location)\n}\n\n\n\nAutosomalXYZWCytoplasmic\n\n\n\n\nCode\nmake_mating_table(gene_location = \"autosomal\") %&gt;% \n  select(locus_type, everything()) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\n\nCode\nmake_mating_table(gene_location = \"XY\") %&gt;% \n  select(locus_type, everything()) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\n\nCode\nmake_mating_table(gene_location = \"ZW\") %&gt;% \n  select(locus_type, everything()) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\n\nCode\nmake_mating_table(gene_location = \"cytoplasmic\") %&gt;% \n  select(locus_type, everything()) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\nLoad the inheritance schemes, to speed up the simulation\n\n\nCode\n# load the possible inheritance schemes\n\noffspring_genotypes_autosome &lt;- \n  make_mating_table(gene_location = \"autosomal\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  as.data.table()\n\noffspring_genotypes_X &lt;- \n  make_mating_table(gene_location = \"XY\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Male_genotype, \"Y_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_Y &lt;- \n  make_mating_table(gene_location = \"XY\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Female_genotype, \"X_I\"),\n         !str_detect(Male_genotype, \"X_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_Z &lt;- \n  make_mating_table(gene_location = \"ZW\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Female_genotype, \"W_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_W &lt;- \n  make_mating_table(gene_location = \"ZW\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Female_genotype, \"Z_I\"),\n         !str_detect(Male_genotype, \"Z_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_cytoplasmic &lt;- \n  make_mating_table(gene_location = \"cytoplasmic\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  as.data.table()\n\n\n\n\n\nRun a quick set of simulations to work this out, where female-male pairs of all possible genotypes at the inbreeding locus initate new families. We simulate the autosomal, X and Z cases, as these are where the homozygote frequency matters.\n\n\nCode\np_space &lt;-\n  bind_rows(\n    expand_grid(Dominance = c(\"dominant\", \"additive\", \"recessive\"),\n                starting_female = c(\"A_IA_O\", \"A_IA_I\", \"A_OA_O\"),\n                starting_male = c(\"A_OA_O\", \"A_IA_O\", \"A_IA_I\"),\n                expressed_sex = c(\"females\", \"males\")) %&gt;%  \n      mutate(inheritance_scheme = \"offspring_genotypes_autosome\",\n             homozygous_genotype = \"A_IA_I\",\n             heterozygous_genotype = \"A_IA_O\",\n             hemizygous_genotype = \"NA\"),\n    \n    expand_grid(Dominance = c(\"dominant\", \"additive\", \"recessive\"),\n                starting_female = c(\"X_IX_O\", \"X_IX_I\", \"X_OX_O\"),\n                starting_male = c(\"X_IY_O\", \"X_OY_O\"),\n                expressed_sex = c(\"females\", \"males\")) %&gt;%  \n      mutate(inheritance_scheme = \"offspring_genotypes_X\",\n             homozygous_genotype = \"X_IX_I\",\n             heterozygous_genotype = \"X_IX_O\",\n             hemizygous_genotype = \"X_IY_O\"),\n    \n    expand_grid(Dominance = c(\"dominant\", \"additive\", \"recessive\"),\n                starting_female = c(\"Z_IW_O\", \"Z_OW_O\"),\n                starting_male = c(\"Z_IZ_O\", \"Z_IZ_I\", \"Z_OZ_O\"),\n                expressed_sex = c(\"females\", \"males\")) %&gt;%  \n      mutate(inheritance_scheme = \"offspring_genotypes_Z\",\n             homozygous_genotype = \"Z_IZ_I\",\n             heterozygous_genotype = \"Z_IZ_O\",\n             hemizygous_genotype = \"Z_IW_O\"))  \n\nfamily_homozygosity_sim &lt;- function(row, # which parameter\n                                    parameters, # the parameter space\n                                    gens){  # max number of generations to run for\n  \n  expressed_sex &lt;- parameters$expressed_sex[row]\n  dominance &lt;- parameters$Dominance[row]\n  starting_female &lt;- parameters$starting_female[row]\n  starting_male &lt;- parameters$starting_male[row]\n  homozygous_genotype &lt;- parameters$homozygous_genotype[row]\n  heterozygous_genotype &lt;- parameters$heterozygous_genotype[row]\n  hemizygous_genotype &lt;- parameters$hemizygous_genotype[row]\n  inheritance_scheme &lt;- eval(parse(text = parameters$inheritance_scheme[row])) \n  \n  # start with individual pair\n  mating_partners &lt;- \n    data.table(Female_genotype = starting_female,\n               Male_genotype = starting_male,\n               mating_freq = 1)\n  \n  # set gen_counter to 1\n  gen_counter &lt;- 1\n  \n  tracking_table &lt;- data.table(Female_homozygote_freq = numeric(), \n                               Female_heterozygote_freq = numeric(),\n                               Female_hemizygote_freq = numeric(),\n                               Male_homozygote_freq = numeric(), \n                               Male_heterozygote_freq = numeric(),\n                               Male_hemizygote_freq = numeric(),\n                               Generation = numeric()) # filled in as sim progresses\n  \n  mating_partners &lt;- \n    data.table(Female_genotype = starting_female,\n               Male_genotype = starting_male,\n               mating_freq = 1)\n  \n  \n  while(gen_counter &lt;= gens){\n    \n    if(dominance == \"dominant\" & expressed_sex == \"females\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == homozygous_genotype & Sex == 1 | # outbreeding females leave family\n          Genotype == heterozygous_genotype & Sex == 1 | \n          Genotype == hemizygous_genotype & Sex == 1 |\n          Sex == 0] \n    }\n    \n    if(dominance == \"dominant\" & expressed_sex == \"males\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == homozygous_genotype & Sex == 0 | # outbreeding males leave family\n          Genotype == heterozygous_genotype & Sex == 0 | \n          Genotype == hemizygous_genotype & Sex == 0 |\n          Sex == 1] \n    }\n    \n    if(dominance == \"additive\" & expressed_sex == \"females\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == heterozygous_genotype & Sex == 1, zygote_freq := zygote_freq * 0.5 # half the heterozygous females don't express I allele\n      ][Genotype == homozygous_genotype & Sex == 1 | # outbreeding females leave family\n          Genotype == heterozygous_genotype & Sex == 1 | \n          Genotype == hemizygous_genotype & Sex == 1 |\n          Sex == 0] \n    }  \n    \n    if(dominance == \"additive\" & expressed_sex == \"males\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == heterozygous_genotype & Sex == 0, zygote_freq := zygote_freq * 0.5 # half the heterozygous males don't express I allele\n      ][Genotype == homozygous_genotype & Sex == 0 | # outbreeding males leave family\n          Genotype == heterozygous_genotype & Sex == 0 | \n          Genotype == hemizygous_genotype & Sex == 0 |\n          Sex == 1] \n    }    \n    \n    if(dominance == \"recessive\" & expressed_sex == \"females\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == homozygous_genotype & Sex == 1 | # outbreeding females leave family\n          Genotype == hemizygous_genotype & Sex == 1 |\n          Sex == 0] \n    } \n    \n    if(dominance == \"recessive\" & expressed_sex == \"males\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == homozygous_genotype & Sex == 0 | # outbreeding females leave family\n          Genotype == hemizygous_genotype & Sex == 0 |\n          Sex == 1] \n    }   \n    \n    adult_females &lt;- \n      offspring[Sex == 1, .(Female_genotype = Genotype, Female_freq = zygote_freq)\n      ][, Female_freq := Female_freq / sum(Female_freq)\n      ][, .(Female_freq = sum(Female_freq)), by = Female_genotype]\n    \n    if(nrow(adult_females[Female_genotype == homozygous_genotype]) &gt; 0){ # fix this and the rest\n      f_homozygote &lt;- adult_females[Female_genotype == homozygous_genotype]$Female_freq\n    } else f_homozygote &lt;- 0\n    \n    if(nrow(adult_females[Female_genotype == heterozygous_genotype]) &gt; 0){  \n      f_heterozygote &lt;- adult_females[Female_genotype == heterozygous_genotype]$Female_freq\n    } else f_heterozygote &lt;- 0\n    \n    if(nrow(adult_females[Female_genotype == hemizygous_genotype]) &gt; 0){  \n      f_hemizygote &lt;- adult_females[Female_genotype == hemizygous_genotype]$Female_freq\n    } else f_hemizygote &lt;- 0\n    \n    adult_males &lt;- \n      offspring[Sex == 0, .(Male_genotype = Genotype, Male_freq = zygote_freq)\n      ][, Male_freq := Male_freq / sum(Male_freq)\n      ][, .(Male_freq = sum(Male_freq)), by = Male_genotype]\n    \n    if(nrow(adult_males[Male_genotype == homozygous_genotype]) &gt; 0){\n      m_homozygote &lt;- adult_males[Male_genotype == homozygous_genotype]$Male_freq\n    } else m_homozygote &lt;- 0\n    \n    if(nrow(adult_males[Male_genotype == heterozygous_genotype]) &gt; 0){  \n      m_heterozygote &lt;- adult_males[Male_genotype == heterozygous_genotype]$Male_freq\n    } else m_heterozygote &lt;- 0\n    \n    if(nrow(adult_males[Male_genotype == hemizygous_genotype]) &gt; 0){  \n      m_hemizygote &lt;- adult_males[Male_genotype == hemizygous_genotype]$Male_freq\n    } else m_hemizygote &lt;- 0\n    \n    tracking_table &lt;- \n      rbindlist(list(tracking_table, \n                     list(f_homozygote,\n                          f_heterozygote,\n                          f_hemizygote,\n                          m_homozygote,\n                          m_heterozygote,\n                          m_hemizygote,\n                          gen_counter)), \n                ignore.attr=TRUE)\n    \n    mating_partners &lt;- \n      CJ(Female_genotype = adult_females$Female_genotype, \n         Male_genotype = adult_males$Male_genotype)[\n           adult_females, on = \"Female_genotype\"][\n             adult_males, on = \"Male_genotype\"\n           ][, mating_freq := Female_freq * Male_freq]\n    \n    gen_counter &lt;- gen_counter + 1\n    \n  }\n  tracking_table %&gt;% \n    mutate(Dominance = dominance,\n           starting_female = starting_female,\n           starting_male = starting_male,\n           expressed_sex = expressed_sex)\n}\n\n#family_homozygosity_sim(13, p_space, 10)\n\noutput &lt;- map_dfr(1:nrow(p_space),\n                      family_homozygosity_sim,\n                      p_space,\n                      20) \n\n\n\n\nCode\nplotting_data &lt;-\n  output %&gt;% as_tibble() %&gt;% \n  mutate(chromosome = case_when(str_detect(starting_female, \"A\") ~ \"Autosome\",\n                                str_detect(starting_female, \"X\") ~ \"X\",\n                                str_detect(starting_female, \"Z\") ~ \"Z\")) %&gt;%\n  unite(\"Mating pair\", starting_female, starting_male, sep = \" x \") %&gt;% \n  filter(`Mating pair` != \"A_IA_I x A_IA_I\" &\n           `Mating pair` != \"A_OA_O x A_OA_O\" &\n           `Mating pair` != \"X_IX_I x X_IY_O\" &\n           `Mating pair` != \"X_OX_O x X_OY_O\" &\n           `Mating pair` != \"Z_IW_O x Z_IZ_I\" &\n           `Mating pair` != \"Z_OW_O x Z_OZ_O\") %&gt;% \n  mutate(Female = case_when(chromosome == \"Autosome\" | chromosome == \"X\" ~ \n                                  Female_homozygote_freq/\n                                  (Female_homozygote_freq + Female_heterozygote_freq),\n                                chromosome == \"Z\" ~ Female_hemizygote_freq),\n         Male = case_when(chromosome == \"Autosome\" | chromosome == \"Z\" ~ \n                                  Male_homozygote_freq/\n                                  (Male_homozygote_freq + Male_heterozygote_freq),\n                                chromosome == \"X\" ~ Male_hemizygote_freq)) %&gt;% \n  select(Generation, Dominance, `Mating pair`, expressed_sex, chromosome, Female,\n         Male) %&gt;% \n  pivot_longer(cols = Female:Male, names_to = \"Sex\", values_to = \"prop_hom\") %&gt;% \n  mutate(prop_hom = if_else(prop_hom == \"NaN\", 0, prop_hom))\n\n\n\nAutosomal lociX-linked lociZ-linked loci\n\n\n\n\nCode\nplotting_data %&gt;% \n  filter(str_detect(`Mating pair`, \"A\")) %&gt;% \n  ggplot(aes(x = Generation, \n                y = prop_hom,\n                colour = Dominance, linetype = Sex)) +\n  geom_line(linewidth = 1.75, alpha = 0.75) +\n  scale_colour_manual(values = c(\"#38A6A5\",\n                                 \"#73AF48\",\n                                 \"#F89C74\")) +\n  labs(x = \"Generation of inbreeding\",\n       y = \"Prop. _I_ carriers that are homozygous\",\n       linetype =\" Sex genotyped\",\n       title = \"Autosomal loci\") +\n  scale_y_continuous(limits = c(0, 1)) +\n  scale_x_continuous(expand = c(0,0),\n                     limits = c(0, 20),\n                     breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)) +\n  facet_grid(`Mating pair`~expressed_sex,\n             labeller = label_glue(\n      rows = '{`Mating pair`}',\n      cols = 'Inbreeding controlled by {`expressed_sex`}')) +\n  theme_bw() +\n  theme(axis.title = element_markdown(),\n        strip.background = element_rect(fill = \"aliceblue\"),\n        plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\n\nCode\nplotting_data %&gt;% \n  filter(str_detect(`Mating pair`, \"X\")) %&gt;% \n  ggplot(aes(x = Generation, \n                y = prop_hom,\n                colour = Dominance, linetype = Sex)) +\n  geom_line(linewidth = 1.75, alpha = 0.75) +\n  scale_colour_manual(values = c(\"#38A6A5\",\n                                 \"#73AF48\",\n                                 \"#F89C74\")) +\n  labs(x = \"Generation of inbreeding\",\n       y = \"Prop. _I_ carriers that are homozygous\",\n       linetype =\" Sex genotyped\",\n       title = \"X-linked loci\") +\n  scale_y_continuous(limits = c(0, 1)) +\n  scale_x_continuous(expand = c(0,0),\n                     limits = c(0, 20),\n                     breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)) +\n  facet_grid(`Mating pair`~expressed_sex,\n             labeller = label_glue(\n      rows = '{`Mating pair`}',\n      cols = 'Inbreeding controlled by {expressed_sex}')) +\n  theme_bw() +\n  theme(axis.title = element_markdown(),\n        strip.background = element_rect(fill = \"aliceblue\"),\n        plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\n\nCode\nplotting_data %&gt;% \n  filter(str_detect(`Mating pair`, \"Z\")) %&gt;% \n  ggplot(aes(x = Generation, \n                y = prop_hom,\n                colour = Dominance, linetype = Sex)) +\n  geom_line(linewidth = 1.75, alpha = 0.75) +\n  scale_colour_manual(values = c(\"#38A6A5\",\n                                 \"#73AF48\",\n                                 \"#F89C74\")) +\n  labs(x = \"Generation of inbreeding\",\n       y = \"Prop. _I_ carriers that are homozygous\",\n       linetype =\" Sex genotyped\",\n       title = \"Z-linked loci\") +\n  scale_y_continuous(limits = c(0, 1)) +\n  scale_x_continuous(expand = c(0,0),\n                     limits = c(0, 20),\n                     breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)) +\n  facet_grid(`Mating pair`~expressed_sex,\n             labeller = label_glue(\n      rows = '{`Mating pair`}',\n      cols = 'Inbreeding controlled by {expressed_sex}')) +\n  theme_bw() +\n  theme(axis.title = element_markdown(),\n        strip.background = element_rect(fill = \"aliceblue\"),\n        plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\n\n\n\n\n\nCode\ncontinuous_time_simulation &lt;- function(row,\n                                       parameters,\n                                       inheritance_scheme){\n  # package loading need to be done within the function to run on a cluster - local environment is not inherited by cluster\n  library(data.table) \n  library(tidyverse)\n  \n  sample_vec &lt;- function(x, ...) x[sample(length(x), ...)] # so we can sample from vectors with length 1 without this being interpreted as an integer\n  \n  print(paste(\"Doing row\", row)) # this shows which row in the parameter space is being modelled\n  \n   prop_i_table &lt;- data.table(time = numeric(), \n                             proportion_I = numeric(),\n                            population_size = numeric()) # filled in as sim progresses\n  \n  keep_going &lt;- TRUE # if the inbreeding allele fixes or goes extinct, this will change to false and the while loop will quit early\n  \n  Starting_pop_size &lt;- parameters$Starting_pop_size[row] \n  N &lt;- parameters$N[row] # constant\n  number_mutants &lt;- parameters$number_mutants[row] # constant at 1 \n  baseline_mean_lifespan &lt;- parameters$baseline_mean_lifespan[row] # constant at 2\n  time_end &lt;- parameters$time_end[row] # a cut-off point for each run \n  sex_expressed &lt;- parameters$sex_expressed[row]\n  chromosome &lt;- parameters$chromosome[row]\n  heterozygous_genotype &lt;- parameters$heterozygous_genotype[row]\n  homozygous_genotype &lt;- parameters$homozygous_genotype[row]\n  hemizygous_genotype &lt;- parameters$hemizygous_genotype[row]\n  #C &lt;- parameters$C[row]\n  v &lt;- parameters$v[row]\n  refractory_period &lt;- parameters$refractory_period[row]\n  D &lt;- parameters$D[row]\n  dominance &lt;- parameters$dominance[row]\n  parameter_space_ID &lt;- parameters$parameter_space_ID[row]\n  \n  # define the starting genotypes for each sex so the population table can be built\n  \n  Female_starting_genotype &lt;- inheritance_scheme[.N]$Female_genotype\n  \n  Male_starting_genotype &lt;- inheritance_scheme[.N]$Male_genotype\n  \n  # Set the number of breeding sites\n  \n  breeding_sites &lt;- 0.5*Starting_pop_size\n  \n  # Initialize the Individual_ID  and Family_ID counters\n  \n  Individual_ID_counter &lt;- Starting_pop_size\n  \n  Family_ID_counter &lt;- Starting_pop_size/N # family size equals the no. offspring produced by a single female\n  \n  # the simulation tracks the population via a data.table\n  \n  # create the starting population - note that females are sex = 1 and males are sex = 0\n  \n  population &lt;-\n    data.table(mortality_rate = 1/baseline_mean_lifespan,\n               Sex = rbinom(n = Starting_pop_size, 1, prob = 0.5),\n               birth_time = 0,\n               matings = 0,\n               reproduced = 0,\n               mated_with = \"NA\",\n               inbred_mating = 0,\n               refractory_period_end = 0,\n               relative_encountered = 0\n    )[, `:=` (Genotype = ifelse(Sex &gt; 0, Female_starting_genotype, Male_starting_genotype),\n              breeding = Sex,\n              Individual_ID = .I,\n              Family_ID = rep(1:(.N/N), each = N, length.out = .N))]\n  \n  # seed population with the inbreeding allele\n  \n  # original - random alleles are mutated \n  \n  #population[sample(which(str_detect(Genotype, pattern = chromosome)), size = number_mutants, replace = F),\n   #         Genotype := str_replace(Genotype, pattern = paste0(chromosome, \"_O\"), replacement = paste0(chromosome, \"_I\"))]\n  \n  # current - entire family is mutated on one chromosome (producing heterozygotes), unless the inbreeding allele is on a hemizygous chromosome, then the minimum number of families are mutated to make 5 mutations\n  \n  if(chromosome != \"W\" & chromosome != \"Y\"){\n    population[Family_ID %in% sample(unique(population[, Family_ID]), size = 1),\n               Genotype := str_replace(Genotype, pattern = paste0(chromosome, \"_O\"), replacement = paste0(chromosome, \"_I\"))]\n  } else{\n    # number_mutants is loaded from the parameter table\n    mutations_made &lt;- 0\n    \n    # Iterate through unique families as needed\n    Families &lt;- sample(unique(population$Family_ID), Starting_pop_size/N)\n    Family_index &lt;- 1\n    \n    while (mutations_made &lt; number_mutants && Family_index &lt;= length(Families)) {\n      current_family &lt;- Families[Family_index]\n      \n      # Identify mutate-able rows from the current family\n      Family_rows &lt;- population[Family_ID == current_family & str_detect(Genotype, pattern = chromosome)]\n      \n      # Calculate how many mutations we can make in this family\n      changes_needed &lt;- number_mutants - mutations_made\n      changes_to_make &lt;- min(nrow(Family_rows), changes_needed)\n      \n      # Select the individuals to mutate\n      rows_to_modify &lt;- Family_rows[1:changes_to_make]\n      \n      # Modify the genotype column in the selected rows\n      population[rows_to_modify, \n                 Genotype := str_replace(Genotype, pattern = paste0(chromosome, \"_O\"), replacement = paste0(chromosome, \"_I\")),\n                 on = \"Individual_ID\"]\n      \n      # Update the count of changes made\n      mutations_made &lt;- nrow(population[str_detect(Genotype, \"I\")])\n      \n      # Move to the next group\n      Family_index &lt;- Family_index + 1\n    } \n  }\n  \n  # Determining the next event\n  \n  # check when the next death occurs: this is the sum of the mortality rates for all individuals in the population\n  \n  next_death &lt;- rexp(n = 1, rate = sum(population[, mortality_rate]))\n  \n  # check when the next receptive female-male encounter occurs\n  \n  receptive_females &lt;- population[Sex &gt; 0]$Individual_ID # everyone's receptive at the start\n  receptive_males &lt;- population[Sex &lt; 1]$Individual_ID\n  \n  # below is the slow way, which I still include to show it's equivalent to the fast way\n  #encounter_possibilities &lt;- \n  # CJ(Female_ID = population[Sex &gt; 0]$Individual_ID,\n  #   Male_ID = population[Sex &lt; 1]$Individual_ID)[, encounter_rate := v/number_females]\n  \n  # Find the time the next encounter occurs: plug the sum of the rates into the exponential function. \n  # The population level encounter rate is the product of the rate at which a single male finds a single female, the number of receptive females in the population, and the number of receptive males in the population\n\n  # \n  \n  next_encounter &lt;- rexp(n = 1, rate = length(receptive_females)*length(receptive_males)*v)\n  \n  # Initialize the timer t to the first encounter\n  \n  t &lt;- pmin(next_death, next_encounter)\n  \n  # With the initial population ready to go and the first event found, start the timer and let the simulation run. In short, time progresses as events occur. Events can trigger state changes for the individuals in the population, leading to death, mating and offspring production.\n  \n  while (t &lt;= time_end & keep_going){\n    \n    # death and mating: what type of encounter happens at time t\n    \n    if(next_death &lt; next_encounter){\n      \n      who_died &lt;- population[sample(.N, 1, prob = mortality_rate)]$Individual_ID \n      \n      # remove individual from population table\n      \n      population &lt;- population[Individual_ID != who_died]\n      \n      # check if mortality event frees up breeding site\n      \n      current_breeders &lt;- sum(population$breeding &gt; 0)\n      \n      # If there is an available breeding site, and at least one female to fill it, recruit a new breeder\n      \n      if(current_breeders &lt; breeding_sites && sum(population$Sex &gt; 0 & population$breeding &lt; 1) &gt; 0){\n        \n        # assign the new breeders\n        \n        population &lt;- population[sample_vec(which(breeding &lt; 1 & Sex &gt; 0),\n                                        size = 1), # note that all living females have equal prob of becoming a breeder\n                                 breeding := 1]\n      }\n    } \n    else{\n      \n      which_encounter &lt;- c(sample_vec(receptive_females, 1), sample_vec(receptive_males, 1))\n      \n      mates &lt;- NULL # reset this every time as a safeguard\n      \n      # Opposite sex encounters\n      \n      female &lt;- population[Individual_ID %chin% which_encounter[1]]\n      male &lt;- population[Individual_ID %chin% which_encounter[2]]\n      \n      # First determine if a homogametic individual, heterozygous for the I allele, will inbreed on this occasion.  \n      \n      heterozygote_inbreeds &lt;- rbinom(1, 1, prob = dominance)\n      \n      # find a brother for the female to encounter, if required\n      \n      brother_encountered &lt;-\n        population[Family_ID %chin% female$Family_ID\n                   # assign a receptive sibling - this is the behavioural trait under selection: \n                   # should an individual accept an inbred mating early in life occur or not.\n        ][Sex &lt; 1 & t &gt; refractory_period_end, .SD[sample(.N, 1)]] \n      \n      if(nrow(brother_encountered)&gt;0 &\n         female$relative_encountered &lt; 1){\n        \n        # do inbreeding\n        \n        if(# female heterozygotes\n          sex_expressed &gt; 0 & \n          str_detect(female$Genotype, heterozygous_genotype) & \n          heterozygote_inbreeds &gt; 0 |\n          # female homozygotes\n          sex_expressed &gt; 0 & \n          str_detect(female$Genotype, homozygous_genotype) |\n          # female hemizygotes\n          sex_expressed &gt; 0 & \n          str_detect(female$Genotype, hemizygous_genotype) |\n          # male heterozygotes\n          sex_expressed &lt; 1 & \n          str_detect(brother_encountered$Genotype, heterozygous_genotype) & \n          heterozygote_inbreeds &gt; 0 |\n          # male homozygotes\n          sex_expressed &lt; 1 & \n          str_detect(brother_encountered$Genotype, homozygous_genotype) |\n          # male hemizygotes\n          sex_expressed &lt; 1 &\n          str_detect(brother_encountered$Genotype, hemizygous_genotype)){\n          \n          # if mating occurred, update the population\n          \n          mates &lt;- rbindlist(list(female, brother_encountered))\n          \n          population[mates,\n                     `:=`(matings = matings + 1,\n                          inbred_mating = fifelse(Sex &gt; 0, 1, 0),\n                          mated_with = fifelse(Sex &gt; 0, brother_encountered$Genotype, NA),\n                          refractory_period_end = fifelse(Sex &lt; 1, t + (refractory_period * baseline_mean_lifespan), 0)),\n                     on = .(Individual_ID)]\n        }\n        \n        # females that had not encountered a relative early in life are coded to have now done so\n        \n        population[female,\n                   relative_encountered := 1,\n                   on = .(Individual_ID)]\n        \n      }\n      \n      if(female$relative_encountered &lt; 1 &\n         nrow(brother_encountered) &lt; 1){\n      \n       # females that had no receptive brother to encounter are recorded as having had their chance for inbreeding early in life. When the male refractory period != 0, this is unlikely (because all siblings are produced at the same time) but possible. Most commonly, this will occur when a female produces an all-female brood (0.03125 probability)\n        \n        population[female,\n                   relative_encountered := 1,\n                   on = .(Individual_ID)]\n      }\n      \n      # If the individual has already encountered their sibling, don't swap and let encounter proceed. \n      \n      # If the pair happen to be from the same family, assume individuals can recognise this and depending on genotype, avoid or accept the inbred mating\n      \n      if(# female heterozygotes\n        sex_expressed &gt; 0 & # female expressed allele\n        female$relative_encountered &gt; 0 & # already encountered their relative\n        female$Family_ID == male$Family_ID & # they've run into another relative \n        str_detect(female$Genotype, heterozygous_genotype) & # they carry 1 inbreeding allele\n        heterozygote_inbreeds &gt; 0 | # the allele is expressed\n        # female homozygotes\n        sex_expressed &gt; 0 & # female expressed allele\n        male$relative_encountered &gt; 0 & # already encountered relative\n        female$Family_ID == male$Family_ID & # # they've run into another relative\n        str_detect(female$Genotype, homozygous_genotype) |\n        # female hemizygotes\n        sex_expressed &gt; 0 & \n        male$relative_encountered &gt; 0 & # already encountered relative\n        female$Family_ID == male$Family_ID & # # they've run into another relative\n        str_detect(female$Genotype, hemizygous_genotype) |\n        # male heterozygotes\n        sex_expressed &lt; 1 & # male expressed allele\n        female$relative_encountered &gt; 0 & # already encountered relative\n        female$Family_ID == male$Family_ID & # they've encountered another relative \n        str_detect(male$Genotype, heterozygous_genotype) & # they carry 1 inbreeding allele\n        heterozygote_inbreeds &gt; 0 | # the allele is expressed\n        # male homozygotes\n        sex_expressed &lt; 1 & # male expressed allele\n        female$relative_encountered &gt; 0 & # already encountered their relative\n        female$Family_ID == male$Family_ID & # # they've run into another relative\n        str_detect(male$Genotype, homozygous_genotype) |\n        # male hemizygotes\n        sex_expressed &lt; 1 & # male expressed allele\n        female$relative_encountered &gt; 0 & # already encountered their relative\n        female$Family_ID == male$Family_ID & # # they've run into another relative\n        str_detect(male$Genotype, hemizygous_genotype)){\n        \n        mates &lt;- rbindlist(list(female, male))\n        \n        population[mates,\n                   `:=`(matings = matings + 1,\n                        inbred_mating = fifelse(Sex &gt; 0, 1, 0),\n                        mated_with = fifelse(Sex &gt; 0, male$Genotype, NA),\n                        refractory_period_end = fifelse(Sex &lt; 1, t + (refractory_period * baseline_mean_lifespan), 0)),\n                   on = .(Individual_ID)]\n      }\n      \n      # encounters between non-relatives\n      \n      if(female$Family_ID != male$Family_ID &\n         female$relative_encountered &gt; 0){\n        \n        mates &lt;- rbindlist(list(female, male))\n        \n        population[mates,\n                   `:=`(matings = matings + 1,\n                        mated_with = fifelse(Sex &gt; 0, male$Genotype, NA),\n                        refractory_period_end = fifelse(Sex &lt; 1, t + (refractory_period * baseline_mean_lifespan), 0)),\n                   on = .(Individual_ID)]\n      }\n      \n    }\n    \n    # Are there consequences of death and mating: reproduction\n    \n    # check if a female can now produce offspring, either because they're previously mated and have secured a breeding site or because they already held a breeding site and have now mated\n    \n    new_mated_breeder &lt;- population[Sex &gt; 0 & matings &gt; 0 & breeding &gt; 0 & reproduced &lt; 1, \n                                    .(Individual_ID,\n                                      inbred_mating,\n                                      Female_genotype = Genotype,\n                                      Male_genotype = mated_with)]\n    \n    if(nrow(new_mated_breeder) &gt; 0) {\n      # add offspring to the population. Each mated female that holds a breeding site produces N offspring\n      offspring &lt;- \n        new_mated_breeder[inheritance_scheme, \n                          on = .(Female_genotype = Female_genotype,\n                                 Male_genotype = Male_genotype), \n                          nomatch = NULL, allow.cartesian  = TRUE\n        ][, .SD[sample(.N,\n                       size = N, \n                       prob = zygote_freq, \n                       replace = T)]\n        ][, Family_ID := .GRP + Family_ID_counter # assign these offspring to a new family \n        ][, .(Genotype, \n              Sex, \n              inbred_mating,\n              Family_ID)\n        ][, `:=`(mortality_rate = fifelse(inbred_mating &gt; 0, \n                                         1/(baseline_mean_lifespan + D), # the cost of inbreeding: D &lt;= 0\n                                         1/baseline_mean_lifespan), # outbred offspring mortality rate\n                 birth_time = t,\n                 breeding = 0,\n                 matings = 0,\n                 reproduced = 0,\n                 mated_with = \"NA\",\n                 refractory_period_end = t,\n                 relative_encountered = 0,\n                 Individual_ID = .I + Individual_ID_counter,\n                 inbred_mating = 0)]\n      \n      # bind the offspring table to the existing population table and update which females have reproduced \n      \n      population &lt;- rbindlist(list(population, offspring), use.names = TRUE\n      )[new_mated_breeder, reproduced := 1, on = .(Individual_ID)]\n      \n      # update the Individual_ID counter\n      Individual_ID_counter &lt;- max(population$Individual_ID)\n      Family_ID_counter &lt;- max(population$Family_ID) \n    }\n    \n    # Calculate the frequency of the I allele, quit early if I fixes or goes extinct\n    \n    # calc allele freq if autosomal locus   \n    if(chromosome == \"A\"){\n      prop_i &lt;-\n        (length(population$Genotype[str_detect(population$Genotype, heterozygous_genotype)]) + \n           2*length(population$Genotype[str_detect(population$Genotype, homozygous_genotype)]))/ (nrow(population)*2)\n    }\n    \n    # calc allele freq if hemizygous locus: W, Y or cytoplasmic\n    if(chromosome == \"W\" | chromosome == \"Y\" | chromosome == \"C\"){\n      prop_i &lt;-\n        (length(population$Genotype[str_detect(population$Genotype, hemizygous_genotype)])/ \n           length(population$Genotype[str_detect(population$Genotype, chromosome)]))\n    }\n    \n    # calc allele freq if diploid in one sex and haploid in the other: X and Z\n    if(chromosome == \"X\" | chromosome == \"Z\"){\n      prop_i &lt;-\n        if(hemizygous_genotype == \"X_IY_O\"){\n          (length(population$Genotype[str_detect(population$Genotype, heterozygous_genotype)]) + \n             2*length(population$Genotype[str_detect(population$Genotype, homozygous_genotype)]) +\n             length(population$Genotype[str_detect(population$Genotype, hemizygous_genotype)]))/ \n            (nrow(population[Sex &gt; 0])*2 + nrow(population[Sex &lt; 1]))}\n      else{\n        (length(population$Genotype[str_detect(population$Genotype, heterozygous_genotype)]) + \n           2*length(population$Genotype[str_detect(population$Genotype, homozygous_genotype)]) +\n           length(population$Genotype[str_detect(population$Genotype, hemizygous_genotype)]))/ \n          (nrow(population[Sex &lt; 1])*2 + nrow(population[Sex &gt; 0]))}\n    }\n    \n    # this is a diagnostic to make sure the model is running well - it can be commented out when running the big simulation\n    prop_i_table &lt;- rbindlist(list(prop_i_table, list(t, prop_i, nrow(population))))\n    \n    print(paste0(\"Population size = \", nrow(population), \", breeders = \", sum(population$breeding &gt; 0), \n                 \", time = \", round(t, 3)))\n    \n    if(prop_i &gt; 0.5 | prop_i &lt; 0.0001 | nrow(population) &lt; 2) keep_going &lt;- FALSE\n    \n    # Move t to next encounter\n    \n    # determining the next event\n    \n    # check when the next death occurs\n    \n    next_death &lt;- rexp(n = 1, rate = sum(population[, mortality_rate]))\n    \n    # check when the next receptive female-male encounter occurs\n    \n    receptive_females &lt;- population[Sex &gt; 0 & matings &lt; 1]$Individual_ID\n    receptive_males &lt;- population[Sex &lt; 1 & refractory_period_end &lt;= t]$Individual_ID\n    \n    if(length(receptive_females)*length(receptive_males) &gt; 0){\n      \n      # check the time: this is the sum of the rates, because each male finds each female at the same rate\n      \n      next_encounter &lt;- rexp(n = 1, rate = length(receptive_females)*length(receptive_males)*v)\n      \n      # Initialize the timer t to the next encounter\n      \n    }else{next_encounter &lt;- 10^3} # make this a number that will never be exceeded by a death time\n    \n    t &lt;- t + pmin(next_death, next_encounter) \n    \n  }\n  finish_time &lt;- t\n  final_pop_size = nrow(population)\n\n# cut the i table down to 1 row per 0.1 time increment, join with the relevant parameter space info and save as a csv.  \n    \nprop_i_table %&gt;%\n  mutate(time_group = floor(time / 0.1) * 0.1) %&gt;%\n  group_by(time_group) %&gt;%\n  slice(1) %&gt;%\n  ungroup() %&gt;%\n  select(-time_group) %&gt;%\n  bind_rows(prop_i_table %&gt;% filter(row_number()==n())) %&gt;%\n  distinct() %&gt;% \n  bind_cols(parameters[row, 15]) %&gt;% \n    #select(-c(heterozygous_genotype, homozygous_genotype, hemizygous_genotype,\n     #         number_mutants, baseline_mean_lifespan, N, time_end))) %&gt;% \n    write_csv(paste(\"sim_results/rowID_\", parameter_space_ID, chromosome, \".csv\", sep = \"\"))\n}\n\n\n\n\n\nThe effect of the individual-level relatedness coefficient on the propagation of an inbreeding allele when there is non-zero inbreeding depression is well described. Therefore, we choose to set \\(r = 0.5\\) for all inbreeding events and instead focus on the effect of varying 1) \\(v\\), 2) \\(\\delta\\), 3) the male cost to mating, here coded as a refractory period following mating, and 4) the chromosome upon which the the allele is found.\nPopulations also differ in the number of breeding females they can support, in order to standardise the number of chromosomes carrying the focal locus. For example, when the inbreeding locus is found on an autosome, a population of 200 individuals harbours 400 copies of the inbreeding locus. If the allele is instead found on a cytoplasmic chromosome (and we assume no heteroplasmy), each individual only carries one copy of the locus and a population size of 400 individuals is needed to equalise the population size of chromosomes. \\(v\\) is adjusted in accordance with the individual population size, so as to ensure that males meet the same number of individuals on average across simulation runs - this is akin to keeping the population density constant between simulation runs.\nThe population is seeded with a small number of inbreeding alleles, equal to number of offspring produced by a single female. Where the chromosome system allows, the inbreeding mutation is initially found within a single family, as would be the case if a single mutation appeared in the previous generation and was passed on to that individuals progeny. Where chromosomes are only carried by individuals of one sex, the mutation is spread across the minimum number of families to match the number of mutations in all other simulations i.e. if the inbreeding allele is Y-linked and only one individual in the family is male, then only this male is mutated. Males from a second family are then mutated and the process re-iterated until the required number of mutations are present.\n\n\nCode\nresolution &lt;- 25\nstarting_pop_size_autosomes &lt;- 1000 # both sexes harbour two copies of each autosomal chromosome = 1000 autosomal haplotypes\n\nparameters &lt;-\n  expand_grid(\n    chromosome = c(\"A\", \"X\", \"Y\", \"Z\", \"W\", \"C\"),\n    v = c(1, 10, 100),\n    D = seq(0, -0.99, length = resolution), # inbreeding depression\n    refractory_period = seq(0, 1, length = 10)\n  ) %&gt;% \n  full_join(tibble(chromosome = c(\"A\", \"A\", \"A\", \"A\", \"A\", \"A\",\n                                  \"X\", \"X\", \"X\", \"X\",\n                                  \"Y\",\n                                  \"Z\", \"Z\", \"Z\", \"Z\",\n                                  \"W\",\n                                  \"C\", \"C\"),\n                   sex_expressed = c(0, 0, 0, 1, 1, 1,\n                                     0, 1, 1, 1,\n                                     0,\n                                     0, 0, 0, 1,\n                                     1,\n                                     0, 1),\n                   dominance = c(0, 0.5, 1, 0, 0.5, 1,\n                                 1, 0, 0.5, 1, \n                                 1, \n                                 0, 0.5, 1, 1,\n                                 1,\n                                 1, 1)) %&gt;% \n              mutate(Starting_pop_size = case_when(chromosome == \"A\" ~ starting_pop_size_autosomes,\n                                                   chromosome == \"X\" | chromosome == \"Z\" ~ \n                                                     starting_pop_size_autosomes / 0.75,\n                                                   chromosome == \"Y\" | chromosome == \"W\" ~ starting_pop_size_autosomes*4,\n                                                   chromosome == \"C\" ~ starting_pop_size_autosomes*2)),\n            relationship = \"many-to-many\", by = \"chromosome\") %&gt;% \n  mutate(baseline_mean_lifespan = 1,\n         v = v / (Starting_pop_size / 2),\n         f = 5, # subject to change\n         mutation_time = 5, # this is when the mutation can be introduced from\n         time_end = 1000, # with avg lifespan = 1, this is ~ roughly 1000 gens\n         parameter_space_ID = row_number())\n\nparameters_autosome &lt;- parameters %&gt;% filter(chromosome == \"A\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_X &lt;- parameters %&gt;% filter(chromosome == \"X\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Y &lt;- parameters %&gt;% filter(chromosome == \"Y\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Z &lt;- parameters %&gt;% filter(chromosome == \"Z\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_W &lt;- parameters %&gt;% filter(chromosome == \"W\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_C &lt;- parameters %&gt;% filter(chromosome == \"C\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\n\n# make a parameter space that is replicated x5\n\nparameters_2 &lt;- \n  parameters %&gt;% \n  filter(dominance != 0.5) %&gt;% \n  mutate(count = 5) %&gt;% \n  uncount(count, .id = \"rep\") %&gt;% \n  mutate(parameter_space_ID = row_number())\n\nparameters_autosome_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"A\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_X_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"X\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Y_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"Y\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Z_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"Z\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_W_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"W\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_C_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"C\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\n\n\n\n\n\nWe run one simulation per row in the parameter space table.\n\n\nCode\n# run the simulation in parallel using all local CPUs on your computer. The code below uses the autosomal parameter space as an example.\n\nif(!file.exists(\"results/complete_results.csv\")){\n  \n  # get the number of cores on the computer \n  n.cores &lt;- parallel::detectCores()\n  \n  # make the cluster\n  cluster &lt;- parallel::makeCluster(n.cores)\n  \n  # split parameters across cluster\n  parallel::clusterExport(cluster, paste(\"parameters_Z_2\"))\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_autosome_2),\n                      continuous_time_simulation,\n                      parameters_autosome_2,\n                      offspring_genotypes_autosome)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_X_2),\n                      continuous_time_simulation,\n                      parameters_X_2,\n                      offspring_genotypes_X)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_Z_2),\n                      continuous_time_simulation,\n                      parameters_Z_2,\n                      offspring_genotypes_Z)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_Y_2),\n                      continuous_time_simulation,\n                      parameters_Y_2,\n                      offspring_genotypes_Y)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_W_2),\n                      continuous_time_simulation,\n                      parameters_W_2,\n                      offspring_genotypes_W)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_C_2),\n                      continuous_time_simulation,\n                      parameters_C_2,\n                      offspring_genotypes_cytoplasmic)\n}\n\n\n\n\n\n\n\nCode\n# build a function to load the individual runs and join them into a single tibble\n\nload_results &lt;- function(chromosome){\n  \n  files &lt;-\n    list.files(path = \"sim_results\") %&gt;% \n    str_subset(chromosome)\n  \n  \n  paste(\"sim_results/\", files, sep = \"\") %&gt;% \n    vroom() \n}\n\nif(!file.exists(\"results/complete_results.csv\")){\n  cytoplasmic_results &lt;- load_results(\"C\")\n  y_sim_results &lt;- load_results(\"Y\") \n  X_sim_results &lt;- load_results(\"X\")\n  Z_sim_results &lt;- load_results(\"Z\")\n  W_sim_results &lt;- load_results(\"W\")\n  A_sim_results &lt;- load_results(\"A\")\n  \n  sim_results &lt;-  \n    bind_rows(A_sim_results,\n              y_sim_results,\n              X_sim_results,\n              Z_sim_results,\n              W_sim_results,\n              cytoplasmic_results) \n  \n  sim_results %&gt;% \n    write_csv(\"results/complete_results_small_space.csv\")} else{\n      sim_results &lt;- read_csv(\"results/complete_results.csv\")\n      sim_results_2 &lt;- read_csv(\"results/complete_results_small_space.csv\")\n    }\n\n\n\n\n\n\n\n\n\nCode\n# load a palette used in all tabs\ntemp &lt;- pnw_palette(\"Shuksan2\",100)\nheatmap_colours &lt;- met.brewer(\"Hokusai2\", 100)\n\n\n\nAutosomesXZYWCytoplasmic\n\n\n\n\nCode\nA_allele_tracking &lt;-\n  all_results %&gt;%\n  filter(chromosome == \"A\" & dominance == 0) %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.08 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = I_prop)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200), breaks = c(0, 50, 100, 150)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.9)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nA_pop_tracking &lt;-\n  autosome_results %&gt;%\n  filter(chromosome == \"A\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.08 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = pop_size, colour = 1-refractory_period_prop_cohort_alive)) + \n  geom_line(aes(group = parameter_space_ID), alpha = 0.6) +\n  geom_vline(xintercept = 10, linetype = 2) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Male refractory period\") +\n  facet_wrap(sex_expressed~v, nrow = 2,\n             labeller = \n               label_glue('Sex expressing inbreeding allele: {`sex_expressed`}\\nMale search efficiency: {`v`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        axis.text = element_text(size = 12),\n        legend.position = \"bottom\")\n        \nA_pop_tracking / A_allele_tracking\n\n\n\n\n\n\nCode\nX_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"X\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"very low\",\n                           v == 0.038 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200), breaks = c(0, 50, 100, 150)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(~sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nX_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"X\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\")) %&gt;% \n  ggplot(aes(x = time, y = population_size),\n         v_cat = case_when(v == 0.015 ~ \"very low\",\n                           v == 0.038 ~ \"low\",\n                           .default = \"high\")) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nX_pop_tracking/X_allele_tracking\n\n\n\n\n\n\nCode\nZ_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Z\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"very low\",\n                           v == 0.038 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200), breaks = c(0, 50, 100, 150)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nZ_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Z\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"very low\",\n                           v == 0.038 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nZ_pop_tracking /Z_allele_tracking\n\n\n\n\n\n\nCode\nY_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Y\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n                  v_cat = case_when(v == 0.005 ~ \"very low\",\n                           v == 0.0125 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200), breaks = c(0, 50, 100, 150)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nY_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Y\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n                  v_cat = case_when(v == 0.005 ~ \"very low\",\n                           v == 0.0125 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nY_pop_tracking/Y_allele_tracking\n\n\n\n\n\n\nCode\nW_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"W\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n                  v_cat = case_when(v == 0.005 ~ \"very low\",\n                           v == 0.0125 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 125), breaks = c(0, 25, 50, 75, 100)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nW_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"W\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n                  v_cat = case_when(v == 0.005 ~ \"very low\",\n                           v == 0.0125 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nW_pop_tracking/W_allele_tracking\n\n\n\n\n\n\nCode\nC_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"C\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.01 ~ \"very low\",\n                           v == 0.025 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 125), breaks = c(0, 25, 50, 75, 100)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nC_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"C\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.01 ~ \"very low\",\n                           v == 0.025 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         \n        strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nC_pop_tracking/C_allele_tracking\n\n\n\n\n\n\n\n\n\nAutosomalXZYWCytoplasmic\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"A\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.02 ~ \"Very low\",\n                           v == 0.05 ~ \"Low\",\n                           .default = \"High\"))\n\nA_heatmap &lt;-\n  data %&gt;%\n  filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"white\", linewidth = .8) +\n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*1)/(1 + 0.5*1)), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"Autosomal inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nA_heatmap\n\n\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"X\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"Very low\",\n                           v == 0.038 ~ \"Low\",\n                           .default = \"High\"))\n\nX_heatmap &lt;-\n  data %&gt;%\n  filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"white\", linewidth = .8) +\n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*0.5)/(1 + 0.5*0.5)), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"X-linked inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nX_heatmap\n\n\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Z\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"Very low\",\n                           v == 0.038 ~ \"Low\",\n                           .default = \"High\"))\n\nZ_heatmap &lt;-\n  data %&gt;%\n  filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + (0.5*0.5))), linetype = 2, colour = \"white\", linewidth = .8) +\n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*1)/(1 + (0.5*1))), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"Z-linked inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nZ_heatmap\n\n\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Y\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.005 ~ \"Very low\",\n                           v == 0.0125 ~ \"Low\",\n                           .default = \"High\"))\n\nY_heatmap &lt;-\n  data %&gt;%\n  #filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"Y-linked inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nY_heatmap\n\n\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"W\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.005 ~ \"Very low\",\n                           v == 0.0125 ~ \"Low\",\n                           .default = \"High\"))\n\nW_heatmap &lt;-\n  data %&gt;%\n  #filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(aes(xintercept = 0), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"W-linked inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nW_heatmap\n\n\n\n\n\n\nCode\ndata &lt;- \n  sim_results %&gt;%\n  filter(chromosome == \"C\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;%\n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.01 ~ \"Very low\",\n                           v == 0.025 ~ \"Low\",\n                           .default = \"High\"))\n\nC_heatmap &lt;-\n  data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(aes(xintercept = 0), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], pnw_palette(\"Shuksan2\", n = 5)[4], pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"Cytoplasmic inbreeding alleles\") +\n  facet_wrap(sex_expressed ~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nC_heatmap\n\n\n\n\n\n\n\n\nNow lets plot a smaller parameter space, where each region of the space has been simulated 5 times.\n\n\nCode\nsim_results_small_space &lt;-\nsim_results_2 %&gt;% \n  left_join(parameters_2, by = \"parameter_space_ID\")\n\nheatmap_colours &lt;- rcartocolor::carto_pal(\"Emrld\", n = 20)\n\n\n\nAutosomalXZYWCytoplasmic\n\n\n\n\nCode\nA_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"A\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.025 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nA_heatmap &lt;-\n  A_data %&gt;%\n  #filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  geom_vline(data = A_data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = A_data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*1)/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Autosomal inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nA_heatmap\n\n\n\n\n\n\nCode\nX_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"X\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.019 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nX_heatmap &lt;-\n  X_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                         limits = c(0, 1)) +\n  geom_vline(data = X_data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = X_data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*0.5)/(1 + 0.5*0.5)), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"X-linked inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nX_heatmap\n\n\n\n\n\n\nCode\nZ_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"Z\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.019 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nZ_heatmap &lt;-\n  Z_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                         limits = c(0, 1)) +\n  geom_vline(data = Z_data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + (0.5*0.5))), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = Z_data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*1)/(1 + (0.5*1))), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Z-linked inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nZ_heatmap\n\n\n\n\n\n\nCode\nY_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"Y\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.006 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nY_heatmap &lt;-\n  Y_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  geom_vline(aes(xintercept = 1), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Y-linked inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nY_heatmap\n\n\n\n\n\n\nCode\nW_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"W\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.006 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nW_heatmap &lt;-\n  W_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                         limits = c(0, 1)) +\n  geom_vline(aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"W-linked inbreeding alleles\") +\n      facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nW_heatmap\n\n\n\n\n\n\nCode\nC_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"C\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.013 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nC_heatmap &lt;-\n  C_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                         limits = c(0, 1)) +\n  geom_vline(aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Cytoplasmic inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nC_heatmap\n\n\n\n\n\nFinally, lets compare invasion across chromosomes, taking only the dominant, high encounter rate cases.\n\n\nCode\nchromosome_invasion_data &lt;-\nbind_rows(\n  A_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  X_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  Z_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  W_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  Y_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  C_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq)) %&gt;% \n  mutate(Location = case_when(chromosome == \"A\"~ \"Autosome\",\n                              chromosome == \"X\" ~ \"X\",\n                              chromosome == \"Z\" ~ \"Z\",\n                              chromosome == \"Y\" ~ \"Y\",\n                              chromosome == \"W\" ~ \"W\",\n                              chromosome == \"C\"~ \"Cytoplasmic\")) %&gt;% \n  mutate(Location = fct_relevel(Location, \"Autosome\", \"X\", \"Z\", \"Y\", \"W\", \"Cytoplasmic\"))\n  \np1 &lt;-\nchromosome_invasion_data %&gt;% \n  filter(sex_expressed == \"Females\") %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Autosome\"),\n             aes(xintercept = (0.5*1)/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"X\"),\n             aes(xintercept = (0.5*0.5)/(1 + 0.5*0.5)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Z\"),\n             aes(xintercept = (0.5*1)/(1 + (0.5*1))), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"W\"),\n             aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Cytoplasmic\"),\n             aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period (prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Inbreeding controlled by females\") +\n  facet_wrap(~Location, nrow = 5,\n             labeller = label_glue('Location: {`Location`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 14),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown(size = 14))\n\np2 &lt;-\nchromosome_invasion_data %&gt;% \n  filter(sex_expressed == \"Males\") %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Autosome\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"X\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Z\"),\n             aes(xintercept = 1/(1 + (0.5*0.5))), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Y\"),\n             aes(xintercept = 1), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Cytoplasmic\"),\n             aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = NULL,\n       fill = \"Prop. _I_ invades\",\n       title = \"Inbreeding controlled by males\") +\n  facet_wrap(~Location, nrow = 5,\n             labeller = label_glue('Location: {`Location`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 14),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown(size = 14))\n\np1 + p2 + plot_layout(guides = \"collect\", axes = \"collect\")"
  },
  {
    "objectID": "Cuts/old_sim_with_plots.html#build-a-mating-table",
    "href": "Cuts/old_sim_with_plots.html#build-a-mating-table",
    "title": "old_sim_with_plots",
    "section": "",
    "text": "To simulate the invasion of alleles found on different chromosomes, we consider simple single-locus, two-allele dynamics. For each chromosomal inheritance system, we build a mating table, which tracks the production of new genotypes from each possible mother-father pair of genotypes in the population. Inheritance is mendelian, except for cytoplasmic chromosomes, which are exclusively maternally inherited.\nThe simulation tracks the invasion of an allele encoding a preference for inbreeding (denoted I), into a population initially dominated by an allele that encodes inbreeding avoidance (denoted O for outbreeding).\n\n\nCode\nmake_mating_table &lt;- function(gene_location){\n  \n  make_offspring &lt;- function(X, Y, offspring_genotype, zygote_freq, gene_location){\n    tibble(Female_genotype = X,\n           Male_genotype = Y,\n           offspring_genotype,\n           zygote_freq,\n           locus_type = gene_location)\n  }\n  \n  # Specify the possible offspring genotypes for all the potential crosses; we use these for the offspring_genotype argument in the make_offspring function\n  \n  # autosomal\n  \n  # II x II\n  # 2 X 2\n  \n  #a_genotype_1 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\")\n  a_cross_1 &lt;- 2\n  \n  # II x IO\n  # 2 X 1\n  #a_genotype_2 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\", \n                    #\"A_IA_O.Female\", \"A_IA_O.Male\")\n  a_cross_2 &lt;- c(1, 2)\n  \n  # II x OO\n  # 2 X 0\n  #a_genotype_3 &lt;- c(\"A_IA_O.Female\", \"A_IA_O.Male\")\n  a_cross_3 &lt;- 1\n  \n  # IO x IO\n  \n  #a_genotype_4 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\", \n   #                 \"A_IA_O.Female\", \"A_IA_O.Male\", \n    #                \"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  a_cross_4 &lt;- c(0, 1, 2)\n  \n  # IO x OO\n  \n  #a_genotype_5 &lt;- c(\"A_IA_O.Female\", \"A_IA_O.Male\",\n   #                 \"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  a_cross_5 &lt;- c(0, 1)\n  \n  # OO x OO\n  \n  #a_genotype_6 &lt;- c(\"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  a_cross_6 &lt;- 0\n  \n  # XY\n  \n  \n  # II x IY_I\n  \n  xy_genotype_1 &lt;- c(\"X_IX_I.Female\", \"X_IY_I.Male\")\n  \n  # II x IY_O\n  \n  xy_genotype_2 &lt;- c(\"X_IX_I.Female\", \"X_IY_O.Male\")\n  \n  # II x OY_I\n  \n  xy_genotype_3 &lt;- c(\"X_IX_O.Female\", \"X_IY_I.Male\")\n  \n  # II x OY_O\n  \n  xy_genotype_4 &lt;- c(\"X_IX_O.Female\", \"X_IY_O.Male\")\n  \n  # IO x IY_I\n  \n  xy_genotype_5 &lt;- c(\"X_IX_I.Female\", \"X_IY_I.Male\",\n                     \"X_IX_O.Female\", \"X_OY_I.Male\")\n  \n  # IO x IY_O\n  \n  xy_genotype_6 &lt;- c(\"X_IX_I.Female\", \"X_IY_O.Male\", \n                     \"X_IX_O.Female\", \"X_OY_O.Male\")\n  \n  # IO x OY_I\n  \n  xy_genotype_7 &lt;- c(\"X_IX_O.Female\", \"X_IY_I.Male\",\n                     \"X_OX_O.Female\", \"X_OY_I.Male\")\n  \n  # IO x OY_O\n  \n  xy_genotype_8 &lt;- c(\"X_IX_O.Female\", \"X_IY_O.Male\",\n                     \"X_OX_O.Female\", \"X_OY_O.Male\")\n  \n  # OO x IY_I\n  \n  xy_genotype_9 &lt;- c(\"X_IX_O.Female\", \"X_OY_I.Male\")\n  \n  # OO x IY_O\n  \n  xy_genotype_10 &lt;- c(\"X_IX_O.Female\", \"X_OY_O.Male\")\n  \n  # OO x OY_I\n  \n  xy_genotype_11 &lt;- c(\"X_OX_O.Female\", \"X_OY_I.Male\")\n  \n  # OO x OY_O\n  \n  xy_genotype_12 &lt;- c(\"X_OX_O.Female\", \"X_OY_O.Male\")\n  \n  # ZW\n  \n  # IW_I x II\n  \n  zw_genotype_1 &lt;- c(\"Z_IZ_I.Male\", \"Z_IW_I.Female\")\n  \n  # IW_I x IO\n  \n  zw_genotype_2 &lt;- c(\"Z_IZ_I.Male\", \"Z_IZ_O.Male\", \n                     \"Z_IW_I.Female\", \"Z_OW_I.Male\")\n  \n  # IW_I x OO\n  \n  zw_genotype_3 &lt;- c(\"Z_IZ_O.Male\", \"Z_OW_I.Female\")\n  \n  # IW_O x II\n  \n  zw_genotype_4 &lt;- c(\"Z_IZ_I.Male\", \"Z_IW_O.Female\")\n  \n  # IW_O x IO\n  \n  zw_genotype_5 &lt;- c(\"Z_IZ_I.Male\", \"Z_IZ_O.Male\",\n                     \"Z_IW_O.Female\", \"Z_OW_O.Female\")\n  \n  # IW_O x OO\n  \n  zw_genotype_6 &lt;- c(\"Z_IZ_O.Male\", \"Z_OW_O.Female\")\n  \n  # OW_I X II\n  \n  zw_genotype_7 &lt;- c(\"Z_IZ_O.Male\", \"Z_IW_I.Female\")\n  \n  # OW_I x IO\n  \n  zw_genotype_8 &lt;- c(\"Z_IZ_O.Male\", \"Z_OZ_O.Male\",\n                     \"Z_IW_I.Female\", \"Z_OW_I.Female\")\n  \n  # OW_I x OO\n  \n  zw_genotype_9 &lt;- c(\"Z_OZ_O.Male\", \"Z_OW_I.Female\")\n  \n  # OW_O X II\n  \n  zw_genotype_10 &lt;- c(\"Z_IZ_O.Male\", \"Z_IW_O.Female\")\n  \n  # OW_O x IO\n  \n  zw_genotype_11 &lt;- c(\"Z_IZ_O.Male\", \"Z_OZ_O.Male\",\n                      \"Z_IW_O.Female\", \"Z_OW_O.Female\")\n  \n  # OW_O x OO\n  \n  zw_genotype_12 &lt;- c(\"Z_OZ_O.Male\", \"Z_OW_O.Female\")\n  \n  # cytoplasmic\n  \n  # I x I\n  # I x O\n  \n  c_genotype_1 &lt;- c(\"C_I.Female\", \"C_I.Male\")\n  \n  # O x O\n  # O x I\n  \n  c_genotype_2 &lt;- c(\"C_O.Female\", \"C_O.Male\")\n  \n  \n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # autosomal\n  \n  # even frequency of two offspring genotypes\n  \n  freq_2 &lt;- rep(0.5, 2)\n  \n  # even frequency between four offspring types\n  \n  freq_4 &lt;- rep(0.25, 4)\n  \n  # when there are 6 offspring genotypes\n  \n  freq_6 &lt;- c(0.125, 0.125,\n              0.25, 0.25,\n              0.125, 0.125)\n  \n  bind_rows(\n    list(\n      make_offspring(\"A_IA_I\", \"A_IA_I\", a_genotype_1, freq_2, \"autosomal\"),\n      make_offspring(\"A_IA_I\", \"A_IA_O\", a_genotype_2, freq_4, \"autosomal\"),\n      make_offspring(\"A_IA_I\", \"A_OA_O\", a_genotype_3, freq_2, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_IA_I\", a_genotype_2, freq_4, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_IA_O\", a_genotype_4, freq_6, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_OA_O\", a_genotype_5, freq_4, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_IA_I\", a_genotype_3, freq_2, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_IA_O\", a_genotype_5, freq_4, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_OA_O\", a_genotype_6, freq_2, \"autosomal\"),\n      \n      make_offspring(\"X_IX_I\", \"X_IY_I\", xy_genotype_1, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_IY_O\", xy_genotype_2, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_OY_I\", xy_genotype_3, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_OY_O\", xy_genotype_4, freq_2, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_IY_I\", xy_genotype_5, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_IY_O\", xy_genotype_6, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_OY_I\", xy_genotype_7, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_OY_O\", xy_genotype_8, freq_4, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_IY_I\", xy_genotype_9, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_IY_O\", xy_genotype_10, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_OY_I\", xy_genotype_11, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_OY_O\", xy_genotype_12, freq_2, \"XY\"),\n      \n      make_offspring(\"Z_IW_I\", \"Z_IZ_I\", zw_genotype_1, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_I\", \"Z_IZ_O\", zw_genotype_2, freq_4, \"ZW\"),\n      make_offspring(\"Z_IW_I\", \"Z_OZ_O\", zw_genotype_3, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_IZ_I\", zw_genotype_4, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_IZ_O\", zw_genotype_5, freq_4, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_OZ_O\", zw_genotype_6, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_I\", \"Z_IZ_I\", zw_genotype_7, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_I\", \"Z_IZ_O\", zw_genotype_8, freq_4, \"ZW\"),\n      make_offspring(\"Z_OW_I\", \"Z_OZ_O\", zw_genotype_9, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_IZ_I\", zw_genotype_10, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_IZ_O\", zw_genotype_11, freq_4, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_OZ_O\", zw_genotype_12, freq_2, \"ZW\"),\n      \n      make_offspring(\"C_I\", \"C_I\", c_genotype_1, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_I\", \"C_O\", c_genotype_1, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_O\", \"C_I\", c_genotype_2, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_O\", \"C_O\", c_genotype_2, freq_2, \"cytoplasmic\")\n    )) %&gt;% \n    filter(locus_type == gene_location)\n}\n\n\n\nAutosomalXYZWCytoplasmic\n\n\n\n\nCode\nmake_mating_table(gene_location = \"autosomal\") %&gt;% \n  select(locus_type, everything()) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\n\nCode\nmake_mating_table(gene_location = \"XY\") %&gt;% \n  select(locus_type, everything()) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\n\nCode\nmake_mating_table(gene_location = \"ZW\") %&gt;% \n  select(locus_type, everything()) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\n\nCode\nmake_mating_table(gene_location = \"cytoplasmic\") %&gt;% \n  select(locus_type, everything()) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\nLoad the inheritance schemes, to speed up the simulation\n\n\nCode\n# load the possible inheritance schemes\n\noffspring_genotypes_autosome &lt;- \n  make_mating_table(gene_location = \"autosomal\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  as.data.table()\n\noffspring_genotypes_X &lt;- \n  make_mating_table(gene_location = \"XY\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Male_genotype, \"Y_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_Y &lt;- \n  make_mating_table(gene_location = \"XY\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Female_genotype, \"X_I\"),\n         !str_detect(Male_genotype, \"X_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_Z &lt;- \n  make_mating_table(gene_location = \"ZW\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Female_genotype, \"W_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_W &lt;- \n  make_mating_table(gene_location = \"ZW\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Female_genotype, \"Z_I\"),\n         !str_detect(Male_genotype, \"Z_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_cytoplasmic &lt;- \n  make_mating_table(gene_location = \"cytoplasmic\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = offspring_genotype) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  as.data.table()"
  },
  {
    "objectID": "Cuts/old_sim_with_plots.html#sec-familysim",
    "href": "Cuts/old_sim_with_plots.html#sec-familysim",
    "title": "old_sim_with_plots",
    "section": "",
    "text": "Run a quick set of simulations to work this out, where female-male pairs of all possible genotypes at the inbreeding locus initate new families. We simulate the autosomal, X and Z cases, as these are where the homozygote frequency matters.\n\n\nCode\np_space &lt;-\n  bind_rows(\n    expand_grid(Dominance = c(\"dominant\", \"additive\", \"recessive\"),\n                starting_female = c(\"A_IA_O\", \"A_IA_I\", \"A_OA_O\"),\n                starting_male = c(\"A_OA_O\", \"A_IA_O\", \"A_IA_I\"),\n                expressed_sex = c(\"females\", \"males\")) %&gt;%  \n      mutate(inheritance_scheme = \"offspring_genotypes_autosome\",\n             homozygous_genotype = \"A_IA_I\",\n             heterozygous_genotype = \"A_IA_O\",\n             hemizygous_genotype = \"NA\"),\n    \n    expand_grid(Dominance = c(\"dominant\", \"additive\", \"recessive\"),\n                starting_female = c(\"X_IX_O\", \"X_IX_I\", \"X_OX_O\"),\n                starting_male = c(\"X_IY_O\", \"X_OY_O\"),\n                expressed_sex = c(\"females\", \"males\")) %&gt;%  \n      mutate(inheritance_scheme = \"offspring_genotypes_X\",\n             homozygous_genotype = \"X_IX_I\",\n             heterozygous_genotype = \"X_IX_O\",\n             hemizygous_genotype = \"X_IY_O\"),\n    \n    expand_grid(Dominance = c(\"dominant\", \"additive\", \"recessive\"),\n                starting_female = c(\"Z_IW_O\", \"Z_OW_O\"),\n                starting_male = c(\"Z_IZ_O\", \"Z_IZ_I\", \"Z_OZ_O\"),\n                expressed_sex = c(\"females\", \"males\")) %&gt;%  \n      mutate(inheritance_scheme = \"offspring_genotypes_Z\",\n             homozygous_genotype = \"Z_IZ_I\",\n             heterozygous_genotype = \"Z_IZ_O\",\n             hemizygous_genotype = \"Z_IW_O\"))  \n\nfamily_homozygosity_sim &lt;- function(row, # which parameter\n                                    parameters, # the parameter space\n                                    gens){  # max number of generations to run for\n  \n  expressed_sex &lt;- parameters$expressed_sex[row]\n  dominance &lt;- parameters$Dominance[row]\n  starting_female &lt;- parameters$starting_female[row]\n  starting_male &lt;- parameters$starting_male[row]\n  homozygous_genotype &lt;- parameters$homozygous_genotype[row]\n  heterozygous_genotype &lt;- parameters$heterozygous_genotype[row]\n  hemizygous_genotype &lt;- parameters$hemizygous_genotype[row]\n  inheritance_scheme &lt;- eval(parse(text = parameters$inheritance_scheme[row])) \n  \n  # start with individual pair\n  mating_partners &lt;- \n    data.table(Female_genotype = starting_female,\n               Male_genotype = starting_male,\n               mating_freq = 1)\n  \n  # set gen_counter to 1\n  gen_counter &lt;- 1\n  \n  tracking_table &lt;- data.table(Female_homozygote_freq = numeric(), \n                               Female_heterozygote_freq = numeric(),\n                               Female_hemizygote_freq = numeric(),\n                               Male_homozygote_freq = numeric(), \n                               Male_heterozygote_freq = numeric(),\n                               Male_hemizygote_freq = numeric(),\n                               Generation = numeric()) # filled in as sim progresses\n  \n  mating_partners &lt;- \n    data.table(Female_genotype = starting_female,\n               Male_genotype = starting_male,\n               mating_freq = 1)\n  \n  \n  while(gen_counter &lt;= gens){\n    \n    if(dominance == \"dominant\" & expressed_sex == \"females\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == homozygous_genotype & Sex == 1 | # outbreeding females leave family\n          Genotype == heterozygous_genotype & Sex == 1 | \n          Genotype == hemizygous_genotype & Sex == 1 |\n          Sex == 0] \n    }\n    \n    if(dominance == \"dominant\" & expressed_sex == \"males\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == homozygous_genotype & Sex == 0 | # outbreeding males leave family\n          Genotype == heterozygous_genotype & Sex == 0 | \n          Genotype == hemizygous_genotype & Sex == 0 |\n          Sex == 1] \n    }\n    \n    if(dominance == \"additive\" & expressed_sex == \"females\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == heterozygous_genotype & Sex == 1, zygote_freq := zygote_freq * 0.5 # half the heterozygous females don't express I allele\n      ][Genotype == homozygous_genotype & Sex == 1 | # outbreeding females leave family\n          Genotype == heterozygous_genotype & Sex == 1 | \n          Genotype == hemizygous_genotype & Sex == 1 |\n          Sex == 0] \n    }  \n    \n    if(dominance == \"additive\" & expressed_sex == \"males\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == heterozygous_genotype & Sex == 0, zygote_freq := zygote_freq * 0.5 # half the heterozygous males don't express I allele\n      ][Genotype == homozygous_genotype & Sex == 0 | # outbreeding males leave family\n          Genotype == heterozygous_genotype & Sex == 0 | \n          Genotype == hemizygous_genotype & Sex == 0 |\n          Sex == 1] \n    }    \n    \n    if(dominance == \"recessive\" & expressed_sex == \"females\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == homozygous_genotype & Sex == 1 | # outbreeding females leave family\n          Genotype == hemizygous_genotype & Sex == 1 |\n          Sex == 0] \n    } \n    \n    if(dominance == \"recessive\" & expressed_sex == \"males\"){\n      offspring &lt;- mating_partners[inheritance_scheme, \n                                   on = .(Female_genotype = Female_genotype,\n                                          Male_genotype = Male_genotype), \n                                   nomatch = NULL, allow.cartesian  = TRUE\n      ][, zygote_freq := zygote_freq * mating_freq\n      ][Genotype == homozygous_genotype & Sex == 0 | # outbreeding females leave family\n          Genotype == hemizygous_genotype & Sex == 0 |\n          Sex == 1] \n    }   \n    \n    adult_females &lt;- \n      offspring[Sex == 1, .(Female_genotype = Genotype, Female_freq = zygote_freq)\n      ][, Female_freq := Female_freq / sum(Female_freq)\n      ][, .(Female_freq = sum(Female_freq)), by = Female_genotype]\n    \n    if(nrow(adult_females[Female_genotype == homozygous_genotype]) &gt; 0){ # fix this and the rest\n      f_homozygote &lt;- adult_females[Female_genotype == homozygous_genotype]$Female_freq\n    } else f_homozygote &lt;- 0\n    \n    if(nrow(adult_females[Female_genotype == heterozygous_genotype]) &gt; 0){  \n      f_heterozygote &lt;- adult_females[Female_genotype == heterozygous_genotype]$Female_freq\n    } else f_heterozygote &lt;- 0\n    \n    if(nrow(adult_females[Female_genotype == hemizygous_genotype]) &gt; 0){  \n      f_hemizygote &lt;- adult_females[Female_genotype == hemizygous_genotype]$Female_freq\n    } else f_hemizygote &lt;- 0\n    \n    adult_males &lt;- \n      offspring[Sex == 0, .(Male_genotype = Genotype, Male_freq = zygote_freq)\n      ][, Male_freq := Male_freq / sum(Male_freq)\n      ][, .(Male_freq = sum(Male_freq)), by = Male_genotype]\n    \n    if(nrow(adult_males[Male_genotype == homozygous_genotype]) &gt; 0){\n      m_homozygote &lt;- adult_males[Male_genotype == homozygous_genotype]$Male_freq\n    } else m_homozygote &lt;- 0\n    \n    if(nrow(adult_males[Male_genotype == heterozygous_genotype]) &gt; 0){  \n      m_heterozygote &lt;- adult_males[Male_genotype == heterozygous_genotype]$Male_freq\n    } else m_heterozygote &lt;- 0\n    \n    if(nrow(adult_males[Male_genotype == hemizygous_genotype]) &gt; 0){  \n      m_hemizygote &lt;- adult_males[Male_genotype == hemizygous_genotype]$Male_freq\n    } else m_hemizygote &lt;- 0\n    \n    tracking_table &lt;- \n      rbindlist(list(tracking_table, \n                     list(f_homozygote,\n                          f_heterozygote,\n                          f_hemizygote,\n                          m_homozygote,\n                          m_heterozygote,\n                          m_hemizygote,\n                          gen_counter)), \n                ignore.attr=TRUE)\n    \n    mating_partners &lt;- \n      CJ(Female_genotype = adult_females$Female_genotype, \n         Male_genotype = adult_males$Male_genotype)[\n           adult_females, on = \"Female_genotype\"][\n             adult_males, on = \"Male_genotype\"\n           ][, mating_freq := Female_freq * Male_freq]\n    \n    gen_counter &lt;- gen_counter + 1\n    \n  }\n  tracking_table %&gt;% \n    mutate(Dominance = dominance,\n           starting_female = starting_female,\n           starting_male = starting_male,\n           expressed_sex = expressed_sex)\n}\n\n#family_homozygosity_sim(13, p_space, 10)\n\noutput &lt;- map_dfr(1:nrow(p_space),\n                      family_homozygosity_sim,\n                      p_space,\n                      20) \n\n\n\n\nCode\nplotting_data &lt;-\n  output %&gt;% as_tibble() %&gt;% \n  mutate(chromosome = case_when(str_detect(starting_female, \"A\") ~ \"Autosome\",\n                                str_detect(starting_female, \"X\") ~ \"X\",\n                                str_detect(starting_female, \"Z\") ~ \"Z\")) %&gt;%\n  unite(\"Mating pair\", starting_female, starting_male, sep = \" x \") %&gt;% \n  filter(`Mating pair` != \"A_IA_I x A_IA_I\" &\n           `Mating pair` != \"A_OA_O x A_OA_O\" &\n           `Mating pair` != \"X_IX_I x X_IY_O\" &\n           `Mating pair` != \"X_OX_O x X_OY_O\" &\n           `Mating pair` != \"Z_IW_O x Z_IZ_I\" &\n           `Mating pair` != \"Z_OW_O x Z_OZ_O\") %&gt;% \n  mutate(Female = case_when(chromosome == \"Autosome\" | chromosome == \"X\" ~ \n                                  Female_homozygote_freq/\n                                  (Female_homozygote_freq + Female_heterozygote_freq),\n                                chromosome == \"Z\" ~ Female_hemizygote_freq),\n         Male = case_when(chromosome == \"Autosome\" | chromosome == \"Z\" ~ \n                                  Male_homozygote_freq/\n                                  (Male_homozygote_freq + Male_heterozygote_freq),\n                                chromosome == \"X\" ~ Male_hemizygote_freq)) %&gt;% \n  select(Generation, Dominance, `Mating pair`, expressed_sex, chromosome, Female,\n         Male) %&gt;% \n  pivot_longer(cols = Female:Male, names_to = \"Sex\", values_to = \"prop_hom\") %&gt;% \n  mutate(prop_hom = if_else(prop_hom == \"NaN\", 0, prop_hom))\n\n\n\nAutosomal lociX-linked lociZ-linked loci\n\n\n\n\nCode\nplotting_data %&gt;% \n  filter(str_detect(`Mating pair`, \"A\")) %&gt;% \n  ggplot(aes(x = Generation, \n                y = prop_hom,\n                colour = Dominance, linetype = Sex)) +\n  geom_line(linewidth = 1.75, alpha = 0.75) +\n  scale_colour_manual(values = c(\"#38A6A5\",\n                                 \"#73AF48\",\n                                 \"#F89C74\")) +\n  labs(x = \"Generation of inbreeding\",\n       y = \"Prop. _I_ carriers that are homozygous\",\n       linetype =\" Sex genotyped\",\n       title = \"Autosomal loci\") +\n  scale_y_continuous(limits = c(0, 1)) +\n  scale_x_continuous(expand = c(0,0),\n                     limits = c(0, 20),\n                     breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)) +\n  facet_grid(`Mating pair`~expressed_sex,\n             labeller = label_glue(\n      rows = '{`Mating pair`}',\n      cols = 'Inbreeding controlled by {`expressed_sex`}')) +\n  theme_bw() +\n  theme(axis.title = element_markdown(),\n        strip.background = element_rect(fill = \"aliceblue\"),\n        plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\n\nCode\nplotting_data %&gt;% \n  filter(str_detect(`Mating pair`, \"X\")) %&gt;% \n  ggplot(aes(x = Generation, \n                y = prop_hom,\n                colour = Dominance, linetype = Sex)) +\n  geom_line(linewidth = 1.75, alpha = 0.75) +\n  scale_colour_manual(values = c(\"#38A6A5\",\n                                 \"#73AF48\",\n                                 \"#F89C74\")) +\n  labs(x = \"Generation of inbreeding\",\n       y = \"Prop. _I_ carriers that are homozygous\",\n       linetype =\" Sex genotyped\",\n       title = \"X-linked loci\") +\n  scale_y_continuous(limits = c(0, 1)) +\n  scale_x_continuous(expand = c(0,0),\n                     limits = c(0, 20),\n                     breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)) +\n  facet_grid(`Mating pair`~expressed_sex,\n             labeller = label_glue(\n      rows = '{`Mating pair`}',\n      cols = 'Inbreeding controlled by {expressed_sex}')) +\n  theme_bw() +\n  theme(axis.title = element_markdown(),\n        strip.background = element_rect(fill = \"aliceblue\"),\n        plot.title = element_text(hjust = 0.5)) \n\n\n\n\n\n\nCode\nplotting_data %&gt;% \n  filter(str_detect(`Mating pair`, \"Z\")) %&gt;% \n  ggplot(aes(x = Generation, \n                y = prop_hom,\n                colour = Dominance, linetype = Sex)) +\n  geom_line(linewidth = 1.75, alpha = 0.75) +\n  scale_colour_manual(values = c(\"#38A6A5\",\n                                 \"#73AF48\",\n                                 \"#F89C74\")) +\n  labs(x = \"Generation of inbreeding\",\n       y = \"Prop. _I_ carriers that are homozygous\",\n       linetype =\" Sex genotyped\",\n       title = \"Z-linked loci\") +\n  scale_y_continuous(limits = c(0, 1)) +\n  scale_x_continuous(expand = c(0,0),\n                     limits = c(0, 20),\n                     breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)) +\n  facet_grid(`Mating pair`~expressed_sex,\n             labeller = label_glue(\n      rows = '{`Mating pair`}',\n      cols = 'Inbreeding controlled by {expressed_sex}')) +\n  theme_bw() +\n  theme(axis.title = element_markdown(),\n        strip.background = element_rect(fill = \"aliceblue\"),\n        plot.title = element_text(hjust = 0.5))"
  },
  {
    "objectID": "Cuts/old_sim_with_plots.html#build-the-main-simulation-function",
    "href": "Cuts/old_sim_with_plots.html#build-the-main-simulation-function",
    "title": "old_sim_with_plots",
    "section": "",
    "text": "Code\ncontinuous_time_simulation &lt;- function(row,\n                                       parameters,\n                                       inheritance_scheme){\n  # package loading need to be done within the function to run on a cluster - local environment is not inherited by cluster\n  library(data.table) \n  library(tidyverse)\n  \n  sample_vec &lt;- function(x, ...) x[sample(length(x), ...)] # so we can sample from vectors with length 1 without this being interpreted as an integer\n  \n  print(paste(\"Doing row\", row)) # this shows which row in the parameter space is being modelled\n  \n   prop_i_table &lt;- data.table(time = numeric(), \n                             proportion_I = numeric(),\n                            population_size = numeric()) # filled in as sim progresses\n  \n  keep_going &lt;- TRUE # if the inbreeding allele fixes or goes extinct, this will change to false and the while loop will quit early\n  \n  Starting_pop_size &lt;- parameters$Starting_pop_size[row] \n  N &lt;- parameters$N[row] # constant\n  number_mutants &lt;- parameters$number_mutants[row] # constant at 1 \n  baseline_mean_lifespan &lt;- parameters$baseline_mean_lifespan[row] # constant at 2\n  time_end &lt;- parameters$time_end[row] # a cut-off point for each run \n  sex_expressed &lt;- parameters$sex_expressed[row]\n  chromosome &lt;- parameters$chromosome[row]\n  heterozygous_genotype &lt;- parameters$heterozygous_genotype[row]\n  homozygous_genotype &lt;- parameters$homozygous_genotype[row]\n  hemizygous_genotype &lt;- parameters$hemizygous_genotype[row]\n  #C &lt;- parameters$C[row]\n  v &lt;- parameters$v[row]\n  refractory_period &lt;- parameters$refractory_period[row]\n  D &lt;- parameters$D[row]\n  dominance &lt;- parameters$dominance[row]\n  parameter_space_ID &lt;- parameters$parameter_space_ID[row]\n  \n  # define the starting genotypes for each sex so the population table can be built\n  \n  Female_starting_genotype &lt;- inheritance_scheme[.N]$Female_genotype\n  \n  Male_starting_genotype &lt;- inheritance_scheme[.N]$Male_genotype\n  \n  # Set the number of breeding sites\n  \n  breeding_sites &lt;- 0.5*Starting_pop_size\n  \n  # Initialize the Individual_ID  and Family_ID counters\n  \n  Individual_ID_counter &lt;- Starting_pop_size\n  \n  Family_ID_counter &lt;- Starting_pop_size/N # family size equals the no. offspring produced by a single female\n  \n  # the simulation tracks the population via a data.table\n  \n  # create the starting population - note that females are sex = 1 and males are sex = 0\n  \n  population &lt;-\n    data.table(mortality_rate = 1/baseline_mean_lifespan,\n               Sex = rbinom(n = Starting_pop_size, 1, prob = 0.5),\n               birth_time = 0,\n               matings = 0,\n               reproduced = 0,\n               mated_with = \"NA\",\n               inbred_mating = 0,\n               refractory_period_end = 0,\n               relative_encountered = 0\n    )[, `:=` (Genotype = ifelse(Sex &gt; 0, Female_starting_genotype, Male_starting_genotype),\n              breeding = Sex,\n              Individual_ID = .I,\n              Family_ID = rep(1:(.N/N), each = N, length.out = .N))]\n  \n  # seed population with the inbreeding allele\n  \n  # original - random alleles are mutated \n  \n  #population[sample(which(str_detect(Genotype, pattern = chromosome)), size = number_mutants, replace = F),\n   #         Genotype := str_replace(Genotype, pattern = paste0(chromosome, \"_O\"), replacement = paste0(chromosome, \"_I\"))]\n  \n  # current - entire family is mutated on one chromosome (producing heterozygotes), unless the inbreeding allele is on a hemizygous chromosome, then the minimum number of families are mutated to make 5 mutations\n  \n  if(chromosome != \"W\" & chromosome != \"Y\"){\n    population[Family_ID %in% sample(unique(population[, Family_ID]), size = 1),\n               Genotype := str_replace(Genotype, pattern = paste0(chromosome, \"_O\"), replacement = paste0(chromosome, \"_I\"))]\n  } else{\n    # number_mutants is loaded from the parameter table\n    mutations_made &lt;- 0\n    \n    # Iterate through unique families as needed\n    Families &lt;- sample(unique(population$Family_ID), Starting_pop_size/N)\n    Family_index &lt;- 1\n    \n    while (mutations_made &lt; number_mutants && Family_index &lt;= length(Families)) {\n      current_family &lt;- Families[Family_index]\n      \n      # Identify mutate-able rows from the current family\n      Family_rows &lt;- population[Family_ID == current_family & str_detect(Genotype, pattern = chromosome)]\n      \n      # Calculate how many mutations we can make in this family\n      changes_needed &lt;- number_mutants - mutations_made\n      changes_to_make &lt;- min(nrow(Family_rows), changes_needed)\n      \n      # Select the individuals to mutate\n      rows_to_modify &lt;- Family_rows[1:changes_to_make]\n      \n      # Modify the genotype column in the selected rows\n      population[rows_to_modify, \n                 Genotype := str_replace(Genotype, pattern = paste0(chromosome, \"_O\"), replacement = paste0(chromosome, \"_I\")),\n                 on = \"Individual_ID\"]\n      \n      # Update the count of changes made\n      mutations_made &lt;- nrow(population[str_detect(Genotype, \"I\")])\n      \n      # Move to the next group\n      Family_index &lt;- Family_index + 1\n    } \n  }\n  \n  # Determining the next event\n  \n  # check when the next death occurs: this is the sum of the mortality rates for all individuals in the population\n  \n  next_death &lt;- rexp(n = 1, rate = sum(population[, mortality_rate]))\n  \n  # check when the next receptive female-male encounter occurs\n  \n  receptive_females &lt;- population[Sex &gt; 0]$Individual_ID # everyone's receptive at the start\n  receptive_males &lt;- population[Sex &lt; 1]$Individual_ID\n  \n  # below is the slow way, which I still include to show it's equivalent to the fast way\n  #encounter_possibilities &lt;- \n  # CJ(Female_ID = population[Sex &gt; 0]$Individual_ID,\n  #   Male_ID = population[Sex &lt; 1]$Individual_ID)[, encounter_rate := v/number_females]\n  \n  # Find the time the next encounter occurs: plug the sum of the rates into the exponential function. \n  # The population level encounter rate is the product of the rate at which a single male finds a single female, the number of receptive females in the population, and the number of receptive males in the population\n\n  # \n  \n  next_encounter &lt;- rexp(n = 1, rate = length(receptive_females)*length(receptive_males)*v)\n  \n  # Initialize the timer t to the first encounter\n  \n  t &lt;- pmin(next_death, next_encounter)\n  \n  # With the initial population ready to go and the first event found, start the timer and let the simulation run. In short, time progresses as events occur. Events can trigger state changes for the individuals in the population, leading to death, mating and offspring production.\n  \n  while (t &lt;= time_end & keep_going){\n    \n    # death and mating: what type of encounter happens at time t\n    \n    if(next_death &lt; next_encounter){\n      \n      who_died &lt;- population[sample(.N, 1, prob = mortality_rate)]$Individual_ID \n      \n      # remove individual from population table\n      \n      population &lt;- population[Individual_ID != who_died]\n      \n      # check if mortality event frees up breeding site\n      \n      current_breeders &lt;- sum(population$breeding &gt; 0)\n      \n      # If there is an available breeding site, and at least one female to fill it, recruit a new breeder\n      \n      if(current_breeders &lt; breeding_sites && sum(population$Sex &gt; 0 & population$breeding &lt; 1) &gt; 0){\n        \n        # assign the new breeders\n        \n        population &lt;- population[sample_vec(which(breeding &lt; 1 & Sex &gt; 0),\n                                        size = 1), # note that all living females have equal prob of becoming a breeder\n                                 breeding := 1]\n      }\n    } \n    else{\n      \n      which_encounter &lt;- c(sample_vec(receptive_females, 1), sample_vec(receptive_males, 1))\n      \n      mates &lt;- NULL # reset this every time as a safeguard\n      \n      # Opposite sex encounters\n      \n      female &lt;- population[Individual_ID %chin% which_encounter[1]]\n      male &lt;- population[Individual_ID %chin% which_encounter[2]]\n      \n      # First determine if a homogametic individual, heterozygous for the I allele, will inbreed on this occasion.  \n      \n      heterozygote_inbreeds &lt;- rbinom(1, 1, prob = dominance)\n      \n      # find a brother for the female to encounter, if required\n      \n      brother_encountered &lt;-\n        population[Family_ID %chin% female$Family_ID\n                   # assign a receptive sibling - this is the behavioural trait under selection: \n                   # should an individual accept an inbred mating early in life occur or not.\n        ][Sex &lt; 1 & t &gt; refractory_period_end, .SD[sample(.N, 1)]] \n      \n      if(nrow(brother_encountered)&gt;0 &\n         female$relative_encountered &lt; 1){\n        \n        # do inbreeding\n        \n        if(# female heterozygotes\n          sex_expressed &gt; 0 & \n          str_detect(female$Genotype, heterozygous_genotype) & \n          heterozygote_inbreeds &gt; 0 |\n          # female homozygotes\n          sex_expressed &gt; 0 & \n          str_detect(female$Genotype, homozygous_genotype) |\n          # female hemizygotes\n          sex_expressed &gt; 0 & \n          str_detect(female$Genotype, hemizygous_genotype) |\n          # male heterozygotes\n          sex_expressed &lt; 1 & \n          str_detect(brother_encountered$Genotype, heterozygous_genotype) & \n          heterozygote_inbreeds &gt; 0 |\n          # male homozygotes\n          sex_expressed &lt; 1 & \n          str_detect(brother_encountered$Genotype, homozygous_genotype) |\n          # male hemizygotes\n          sex_expressed &lt; 1 &\n          str_detect(brother_encountered$Genotype, hemizygous_genotype)){\n          \n          # if mating occurred, update the population\n          \n          mates &lt;- rbindlist(list(female, brother_encountered))\n          \n          population[mates,\n                     `:=`(matings = matings + 1,\n                          inbred_mating = fifelse(Sex &gt; 0, 1, 0),\n                          mated_with = fifelse(Sex &gt; 0, brother_encountered$Genotype, NA),\n                          refractory_period_end = fifelse(Sex &lt; 1, t + (refractory_period * baseline_mean_lifespan), 0)),\n                     on = .(Individual_ID)]\n        }\n        \n        # females that had not encountered a relative early in life are coded to have now done so\n        \n        population[female,\n                   relative_encountered := 1,\n                   on = .(Individual_ID)]\n        \n      }\n      \n      if(female$relative_encountered &lt; 1 &\n         nrow(brother_encountered) &lt; 1){\n      \n       # females that had no receptive brother to encounter are recorded as having had their chance for inbreeding early in life. When the male refractory period != 0, this is unlikely (because all siblings are produced at the same time) but possible. Most commonly, this will occur when a female produces an all-female brood (0.03125 probability)\n        \n        population[female,\n                   relative_encountered := 1,\n                   on = .(Individual_ID)]\n      }\n      \n      # If the individual has already encountered their sibling, don't swap and let encounter proceed. \n      \n      # If the pair happen to be from the same family, assume individuals can recognise this and depending on genotype, avoid or accept the inbred mating\n      \n      if(# female heterozygotes\n        sex_expressed &gt; 0 & # female expressed allele\n        female$relative_encountered &gt; 0 & # already encountered their relative\n        female$Family_ID == male$Family_ID & # they've run into another relative \n        str_detect(female$Genotype, heterozygous_genotype) & # they carry 1 inbreeding allele\n        heterozygote_inbreeds &gt; 0 | # the allele is expressed\n        # female homozygotes\n        sex_expressed &gt; 0 & # female expressed allele\n        male$relative_encountered &gt; 0 & # already encountered relative\n        female$Family_ID == male$Family_ID & # # they've run into another relative\n        str_detect(female$Genotype, homozygous_genotype) |\n        # female hemizygotes\n        sex_expressed &gt; 0 & \n        male$relative_encountered &gt; 0 & # already encountered relative\n        female$Family_ID == male$Family_ID & # # they've run into another relative\n        str_detect(female$Genotype, hemizygous_genotype) |\n        # male heterozygotes\n        sex_expressed &lt; 1 & # male expressed allele\n        female$relative_encountered &gt; 0 & # already encountered relative\n        female$Family_ID == male$Family_ID & # they've encountered another relative \n        str_detect(male$Genotype, heterozygous_genotype) & # they carry 1 inbreeding allele\n        heterozygote_inbreeds &gt; 0 | # the allele is expressed\n        # male homozygotes\n        sex_expressed &lt; 1 & # male expressed allele\n        female$relative_encountered &gt; 0 & # already encountered their relative\n        female$Family_ID == male$Family_ID & # # they've run into another relative\n        str_detect(male$Genotype, homozygous_genotype) |\n        # male hemizygotes\n        sex_expressed &lt; 1 & # male expressed allele\n        female$relative_encountered &gt; 0 & # already encountered their relative\n        female$Family_ID == male$Family_ID & # # they've run into another relative\n        str_detect(male$Genotype, hemizygous_genotype)){\n        \n        mates &lt;- rbindlist(list(female, male))\n        \n        population[mates,\n                   `:=`(matings = matings + 1,\n                        inbred_mating = fifelse(Sex &gt; 0, 1, 0),\n                        mated_with = fifelse(Sex &gt; 0, male$Genotype, NA),\n                        refractory_period_end = fifelse(Sex &lt; 1, t + (refractory_period * baseline_mean_lifespan), 0)),\n                   on = .(Individual_ID)]\n      }\n      \n      # encounters between non-relatives\n      \n      if(female$Family_ID != male$Family_ID &\n         female$relative_encountered &gt; 0){\n        \n        mates &lt;- rbindlist(list(female, male))\n        \n        population[mates,\n                   `:=`(matings = matings + 1,\n                        mated_with = fifelse(Sex &gt; 0, male$Genotype, NA),\n                        refractory_period_end = fifelse(Sex &lt; 1, t + (refractory_period * baseline_mean_lifespan), 0)),\n                   on = .(Individual_ID)]\n      }\n      \n    }\n    \n    # Are there consequences of death and mating: reproduction\n    \n    # check if a female can now produce offspring, either because they're previously mated and have secured a breeding site or because they already held a breeding site and have now mated\n    \n    new_mated_breeder &lt;- population[Sex &gt; 0 & matings &gt; 0 & breeding &gt; 0 & reproduced &lt; 1, \n                                    .(Individual_ID,\n                                      inbred_mating,\n                                      Female_genotype = Genotype,\n                                      Male_genotype = mated_with)]\n    \n    if(nrow(new_mated_breeder) &gt; 0) {\n      # add offspring to the population. Each mated female that holds a breeding site produces N offspring\n      offspring &lt;- \n        new_mated_breeder[inheritance_scheme, \n                          on = .(Female_genotype = Female_genotype,\n                                 Male_genotype = Male_genotype), \n                          nomatch = NULL, allow.cartesian  = TRUE\n        ][, .SD[sample(.N,\n                       size = N, \n                       prob = zygote_freq, \n                       replace = T)]\n        ][, Family_ID := .GRP + Family_ID_counter # assign these offspring to a new family \n        ][, .(Genotype, \n              Sex, \n              inbred_mating,\n              Family_ID)\n        ][, `:=`(mortality_rate = fifelse(inbred_mating &gt; 0, \n                                         1/(baseline_mean_lifespan + D), # the cost of inbreeding: D &lt;= 0\n                                         1/baseline_mean_lifespan), # outbred offspring mortality rate\n                 birth_time = t,\n                 breeding = 0,\n                 matings = 0,\n                 reproduced = 0,\n                 mated_with = \"NA\",\n                 refractory_period_end = t,\n                 relative_encountered = 0,\n                 Individual_ID = .I + Individual_ID_counter,\n                 inbred_mating = 0)]\n      \n      # bind the offspring table to the existing population table and update which females have reproduced \n      \n      population &lt;- rbindlist(list(population, offspring), use.names = TRUE\n      )[new_mated_breeder, reproduced := 1, on = .(Individual_ID)]\n      \n      # update the Individual_ID counter\n      Individual_ID_counter &lt;- max(population$Individual_ID)\n      Family_ID_counter &lt;- max(population$Family_ID) \n    }\n    \n    # Calculate the frequency of the I allele, quit early if I fixes or goes extinct\n    \n    # calc allele freq if autosomal locus   \n    if(chromosome == \"A\"){\n      prop_i &lt;-\n        (length(population$Genotype[str_detect(population$Genotype, heterozygous_genotype)]) + \n           2*length(population$Genotype[str_detect(population$Genotype, homozygous_genotype)]))/ (nrow(population)*2)\n    }\n    \n    # calc allele freq if hemizygous locus: W, Y or cytoplasmic\n    if(chromosome == \"W\" | chromosome == \"Y\" | chromosome == \"C\"){\n      prop_i &lt;-\n        (length(population$Genotype[str_detect(population$Genotype, hemizygous_genotype)])/ \n           length(population$Genotype[str_detect(population$Genotype, chromosome)]))\n    }\n    \n    # calc allele freq if diploid in one sex and haploid in the other: X and Z\n    if(chromosome == \"X\" | chromosome == \"Z\"){\n      prop_i &lt;-\n        if(hemizygous_genotype == \"X_IY_O\"){\n          (length(population$Genotype[str_detect(population$Genotype, heterozygous_genotype)]) + \n             2*length(population$Genotype[str_detect(population$Genotype, homozygous_genotype)]) +\n             length(population$Genotype[str_detect(population$Genotype, hemizygous_genotype)]))/ \n            (nrow(population[Sex &gt; 0])*2 + nrow(population[Sex &lt; 1]))}\n      else{\n        (length(population$Genotype[str_detect(population$Genotype, heterozygous_genotype)]) + \n           2*length(population$Genotype[str_detect(population$Genotype, homozygous_genotype)]) +\n           length(population$Genotype[str_detect(population$Genotype, hemizygous_genotype)]))/ \n          (nrow(population[Sex &lt; 1])*2 + nrow(population[Sex &gt; 0]))}\n    }\n    \n    # this is a diagnostic to make sure the model is running well - it can be commented out when running the big simulation\n    prop_i_table &lt;- rbindlist(list(prop_i_table, list(t, prop_i, nrow(population))))\n    \n    print(paste0(\"Population size = \", nrow(population), \", breeders = \", sum(population$breeding &gt; 0), \n                 \", time = \", round(t, 3)))\n    \n    if(prop_i &gt; 0.5 | prop_i &lt; 0.0001 | nrow(population) &lt; 2) keep_going &lt;- FALSE\n    \n    # Move t to next encounter\n    \n    # determining the next event\n    \n    # check when the next death occurs\n    \n    next_death &lt;- rexp(n = 1, rate = sum(population[, mortality_rate]))\n    \n    # check when the next receptive female-male encounter occurs\n    \n    receptive_females &lt;- population[Sex &gt; 0 & matings &lt; 1]$Individual_ID\n    receptive_males &lt;- population[Sex &lt; 1 & refractory_period_end &lt;= t]$Individual_ID\n    \n    if(length(receptive_females)*length(receptive_males) &gt; 0){\n      \n      # check the time: this is the sum of the rates, because each male finds each female at the same rate\n      \n      next_encounter &lt;- rexp(n = 1, rate = length(receptive_females)*length(receptive_males)*v)\n      \n      # Initialize the timer t to the next encounter\n      \n    }else{next_encounter &lt;- 10^3} # make this a number that will never be exceeded by a death time\n    \n    t &lt;- t + pmin(next_death, next_encounter) \n    \n  }\n  finish_time &lt;- t\n  final_pop_size = nrow(population)\n\n# cut the i table down to 1 row per 0.1 time increment, join with the relevant parameter space info and save as a csv.  \n    \nprop_i_table %&gt;%\n  mutate(time_group = floor(time / 0.1) * 0.1) %&gt;%\n  group_by(time_group) %&gt;%\n  slice(1) %&gt;%\n  ungroup() %&gt;%\n  select(-time_group) %&gt;%\n  bind_rows(prop_i_table %&gt;% filter(row_number()==n())) %&gt;%\n  distinct() %&gt;% \n  bind_cols(parameters[row, 15]) %&gt;% \n    #select(-c(heterozygous_genotype, homozygous_genotype, hemizygous_genotype,\n     #         number_mutants, baseline_mean_lifespan, N, time_end))) %&gt;% \n    write_csv(paste(\"sim_results/rowID_\", parameter_space_ID, chromosome, \".csv\", sep = \"\"))\n}"
  },
  {
    "objectID": "Cuts/old_sim_with_plots.html#define-the-parameter-space",
    "href": "Cuts/old_sim_with_plots.html#define-the-parameter-space",
    "title": "old_sim_with_plots",
    "section": "",
    "text": "The effect of the individual-level relatedness coefficient on the propagation of an inbreeding allele when there is non-zero inbreeding depression is well described. Therefore, we choose to set \\(r = 0.5\\) for all inbreeding events and instead focus on the effect of varying 1) \\(v\\), 2) \\(\\delta\\), 3) the male cost to mating, here coded as a refractory period following mating, and 4) the chromosome upon which the the allele is found.\nPopulations also differ in the number of breeding females they can support, in order to standardise the number of chromosomes carrying the focal locus. For example, when the inbreeding locus is found on an autosome, a population of 200 individuals harbours 400 copies of the inbreeding locus. If the allele is instead found on a cytoplasmic chromosome (and we assume no heteroplasmy), each individual only carries one copy of the locus and a population size of 400 individuals is needed to equalise the population size of chromosomes. \\(v\\) is adjusted in accordance with the individual population size, so as to ensure that males meet the same number of individuals on average across simulation runs - this is akin to keeping the population density constant between simulation runs.\nThe population is seeded with a small number of inbreeding alleles, equal to number of offspring produced by a single female. Where the chromosome system allows, the inbreeding mutation is initially found within a single family, as would be the case if a single mutation appeared in the previous generation and was passed on to that individuals progeny. Where chromosomes are only carried by individuals of one sex, the mutation is spread across the minimum number of families to match the number of mutations in all other simulations i.e. if the inbreeding allele is Y-linked and only one individual in the family is male, then only this male is mutated. Males from a second family are then mutated and the process re-iterated until the required number of mutations are present.\n\n\nCode\nresolution &lt;- 25\nstarting_pop_size_autosomes &lt;- 1000 # both sexes harbour two copies of each autosomal chromosome = 1000 autosomal haplotypes\n\nparameters &lt;-\n  expand_grid(\n    chromosome = c(\"A\", \"X\", \"Y\", \"Z\", \"W\", \"C\"),\n    v = c(1, 10, 100),\n    D = seq(0, -0.99, length = resolution), # inbreeding depression\n    refractory_period = seq(0, 1, length = 10)\n  ) %&gt;% \n  full_join(tibble(chromosome = c(\"A\", \"A\", \"A\", \"A\", \"A\", \"A\",\n                                  \"X\", \"X\", \"X\", \"X\",\n                                  \"Y\",\n                                  \"Z\", \"Z\", \"Z\", \"Z\",\n                                  \"W\",\n                                  \"C\", \"C\"),\n                   sex_expressed = c(0, 0, 0, 1, 1, 1,\n                                     0, 1, 1, 1,\n                                     0,\n                                     0, 0, 0, 1,\n                                     1,\n                                     0, 1),\n                   dominance = c(0, 0.5, 1, 0, 0.5, 1,\n                                 1, 0, 0.5, 1, \n                                 1, \n                                 0, 0.5, 1, 1,\n                                 1,\n                                 1, 1)) %&gt;% \n              mutate(Starting_pop_size = case_when(chromosome == \"A\" ~ starting_pop_size_autosomes,\n                                                   chromosome == \"X\" | chromosome == \"Z\" ~ \n                                                     starting_pop_size_autosomes / 0.75,\n                                                   chromosome == \"Y\" | chromosome == \"W\" ~ starting_pop_size_autosomes*4,\n                                                   chromosome == \"C\" ~ starting_pop_size_autosomes*2)),\n            relationship = \"many-to-many\", by = \"chromosome\") %&gt;% \n  mutate(baseline_mean_lifespan = 1,\n         v = v / (Starting_pop_size / 2),\n         f = 5, # subject to change\n         mutation_time = 5, # this is when the mutation can be introduced from\n         time_end = 1000, # with avg lifespan = 1, this is ~ roughly 1000 gens\n         parameter_space_ID = row_number())\n\nparameters_autosome &lt;- parameters %&gt;% filter(chromosome == \"A\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_X &lt;- parameters %&gt;% filter(chromosome == \"X\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Y &lt;- parameters %&gt;% filter(chromosome == \"Y\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Z &lt;- parameters %&gt;% filter(chromosome == \"Z\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_W &lt;- parameters %&gt;% filter(chromosome == \"W\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_C &lt;- parameters %&gt;% filter(chromosome == \"C\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\n\n# make a parameter space that is replicated x5\n\nparameters_2 &lt;- \n  parameters %&gt;% \n  filter(dominance != 0.5) %&gt;% \n  mutate(count = 5) %&gt;% \n  uncount(count, .id = \"rep\") %&gt;% \n  mutate(parameter_space_ID = row_number())\n\nparameters_autosome_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"A\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_X_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"X\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Y_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"Y\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Z_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"Z\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_W_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"W\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_C_2 &lt;- parameters_2 %&gt;% filter(chromosome == \"C\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs"
  },
  {
    "objectID": "Cuts/old_sim_with_plots.html#run-the-simulation",
    "href": "Cuts/old_sim_with_plots.html#run-the-simulation",
    "title": "old_sim_with_plots",
    "section": "",
    "text": "We run one simulation per row in the parameter space table.\n\n\nCode\n# run the simulation in parallel using all local CPUs on your computer. The code below uses the autosomal parameter space as an example.\n\nif(!file.exists(\"results/complete_results.csv\")){\n  \n  # get the number of cores on the computer \n  n.cores &lt;- parallel::detectCores()\n  \n  # make the cluster\n  cluster &lt;- parallel::makeCluster(n.cores)\n  \n  # split parameters across cluster\n  parallel::clusterExport(cluster, paste(\"parameters_Z_2\"))\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_autosome_2),\n                      continuous_time_simulation,\n                      parameters_autosome_2,\n                      offspring_genotypes_autosome)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_X_2),\n                      continuous_time_simulation,\n                      parameters_X_2,\n                      offspring_genotypes_X)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_Z_2),\n                      continuous_time_simulation,\n                      parameters_Z_2,\n                      offspring_genotypes_Z)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_Y_2),\n                      continuous_time_simulation,\n                      parameters_Y_2,\n                      offspring_genotypes_Y)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_W_2),\n                      continuous_time_simulation,\n                      parameters_W_2,\n                      offspring_genotypes_W)\n  \n  parallel::parLapply(cluster,\n                      1:nrow(parameters_C_2),\n                      continuous_time_simulation,\n                      parameters_C_2,\n                      offspring_genotypes_cytoplasmic)\n}"
  },
  {
    "objectID": "Cuts/old_sim_with_plots.html#load-the-results",
    "href": "Cuts/old_sim_with_plots.html#load-the-results",
    "title": "old_sim_with_plots",
    "section": "",
    "text": "Code\n# build a function to load the individual runs and join them into a single tibble\n\nload_results &lt;- function(chromosome){\n  \n  files &lt;-\n    list.files(path = \"sim_results\") %&gt;% \n    str_subset(chromosome)\n  \n  \n  paste(\"sim_results/\", files, sep = \"\") %&gt;% \n    vroom() \n}\n\nif(!file.exists(\"results/complete_results.csv\")){\n  cytoplasmic_results &lt;- load_results(\"C\")\n  y_sim_results &lt;- load_results(\"Y\") \n  X_sim_results &lt;- load_results(\"X\")\n  Z_sim_results &lt;- load_results(\"Z\")\n  W_sim_results &lt;- load_results(\"W\")\n  A_sim_results &lt;- load_results(\"A\")\n  \n  sim_results &lt;-  \n    bind_rows(A_sim_results,\n              y_sim_results,\n              X_sim_results,\n              Z_sim_results,\n              W_sim_results,\n              cytoplasmic_results) \n  \n  sim_results %&gt;% \n    write_csv(\"results/complete_results_small_space.csv\")} else{\n      sim_results &lt;- read_csv(\"results/complete_results.csv\")\n      sim_results_2 &lt;- read_csv(\"results/complete_results_small_space.csv\")\n    }"
  },
  {
    "objectID": "Cuts/old_sim_with_plots.html#plot-the-results",
    "href": "Cuts/old_sim_with_plots.html#plot-the-results",
    "title": "old_sim_with_plots",
    "section": "",
    "text": "Code\n# load a palette used in all tabs\ntemp &lt;- pnw_palette(\"Shuksan2\",100)\nheatmap_colours &lt;- met.brewer(\"Hokusai2\", 100)\n\n\n\nAutosomesXZYWCytoplasmic\n\n\n\n\nCode\nA_allele_tracking &lt;-\n  all_results %&gt;%\n  filter(chromosome == \"A\" & dominance == 0) %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.08 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = I_prop)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200), breaks = c(0, 50, 100, 150)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.9)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nA_pop_tracking &lt;-\n  autosome_results %&gt;%\n  filter(chromosome == \"A\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.08 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = pop_size, colour = 1-refractory_period_prop_cohort_alive)) + \n  geom_line(aes(group = parameter_space_ID), alpha = 0.6) +\n  geom_vline(xintercept = 10, linetype = 2) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Male refractory period\") +\n  facet_wrap(sex_expressed~v, nrow = 2,\n             labeller = \n               label_glue('Sex expressing inbreeding allele: {`sex_expressed`}\\nMale search efficiency: {`v`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        axis.text = element_text(size = 12),\n        legend.position = \"bottom\")\n        \nA_pop_tracking / A_allele_tracking\n\n\n\n\n\n\nCode\nX_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"X\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"very low\",\n                           v == 0.038 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200), breaks = c(0, 50, 100, 150)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(~sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nX_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"X\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\")) %&gt;% \n  ggplot(aes(x = time, y = population_size),\n         v_cat = case_when(v == 0.015 ~ \"very low\",\n                           v == 0.038 ~ \"low\",\n                           .default = \"high\")) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nX_pop_tracking/X_allele_tracking\n\n\n\n\n\n\nCode\nZ_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Z\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"very low\",\n                           v == 0.038 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200), breaks = c(0, 50, 100, 150)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nZ_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Z\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"very low\",\n                           v == 0.038 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nZ_pop_tracking /Z_allele_tracking\n\n\n\n\n\n\nCode\nY_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Y\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n                  v_cat = case_when(v == 0.005 ~ \"very low\",\n                           v == 0.0125 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 200), breaks = c(0, 50, 100, 150)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nY_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Y\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n                  v_cat = case_when(v == 0.005 ~ \"very low\",\n                           v == 0.0125 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nY_pop_tracking/Y_allele_tracking\n\n\n\n\n\n\nCode\nW_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"W\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n                  v_cat = case_when(v == 0.005 ~ \"very low\",\n                           v == 0.0125 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 125), breaks = c(0, 25, 50, 75, 100)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nW_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"W\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n                  v_cat = case_when(v == 0.005 ~ \"very low\",\n                           v == 0.0125 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nW_pop_tracking/W_allele_tracking\n\n\n\n\n\n\nCode\nC_allele_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"C\") %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.01 ~ \"very low\",\n                           v == 0.025 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = parameter_space_ID, colour = D_prop), alpha = 0.4) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 125), breaks = c(0, 25, 50, 75, 100)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Frequency of _I_ allele\",\n       colour = \"Inbreeding depression\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n\nC_pop_tracking &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"C\") %&gt;%   \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.01 ~ \"very low\",\n                           v == 0.025 ~ \"low\",\n                           .default = \"high\")) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = parameter_space_ID, colour = refractory_period), alpha = 0.6) +\n  #geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 75)) + \n  #scale_y_continuous(expand = c(0, 0), limits = c(0, 0.5)) +\n  scale_colour_gradientn(colours = temp) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       colour = \"Mating system\") +\n  facet_wrap(sex_expressed~v_cat, nrow = 2,\n             labeller = \n               label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),         \n        strip.text = element_text(size = 9),\n        axis.text = element_text(size = 12))\n        \nC_pop_tracking/C_allele_tracking\n\n\n\n\n\n\n\n\n\nAutosomalXZYWCytoplasmic\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"A\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.02 ~ \"Very low\",\n                           v == 0.05 ~ \"Low\",\n                           .default = \"High\"))\n\nA_heatmap &lt;-\n  data %&gt;%\n  filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"white\", linewidth = .8) +\n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*1)/(1 + 0.5*1)), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"Autosomal inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nA_heatmap\n\n\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"X\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"Very low\",\n                           v == 0.038 ~ \"Low\",\n                           .default = \"High\"))\n\nX_heatmap &lt;-\n  data %&gt;%\n  filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"white\", linewidth = .8) +\n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*0.5)/(1 + 0.5*0.5)), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"X-linked inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nX_heatmap\n\n\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Z\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.015 ~ \"Very low\",\n                           v == 0.038 ~ \"Low\",\n                           .default = \"High\"))\n\nZ_heatmap &lt;-\n  data %&gt;%\n  filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + (0.5*0.5))), linetype = 2, colour = \"white\", linewidth = .8) +\n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*1)/(1 + (0.5*1))), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"Z-linked inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nZ_heatmap\n\n\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"Y\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.005 ~ \"Very low\",\n                           v == 0.0125 ~ \"Low\",\n                           .default = \"High\"))\n\nY_heatmap &lt;-\n  data %&gt;%\n  #filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(data = data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"Y-linked inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nY_heatmap\n\n\n\n\n\n\nCode\ndata &lt;-\n  sim_results %&gt;%\n  filter(chromosome == \"W\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.005 ~ \"Very low\",\n                           v == 0.0125 ~ \"Low\",\n                           .default = \"High\"))\n\nW_heatmap &lt;-\n  data %&gt;%\n  #filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(aes(xintercept = 0), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], \n                               pnw_palette(\"Shuksan2\", n = 5)[4], \n                               pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"W-linked inbreeding alleles\") +\n  facet_wrap(sex_expressed~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nW_heatmap\n\n\n\n\n\n\nCode\ndata &lt;- \n  sim_results %&gt;%\n  filter(chromosome == \"C\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;%\n  ungroup() %&gt;% \n  mutate(D_prop = D*-1,\n         Fate = case_when(population_size &lt; Starting_pop_size*0.1 ~ \"Extinction\",\n                          proportion_I  &gt; 0.5 ~ \"Invades\",\n                          proportion_I  &lt; 0.001 ~ \"Purged\"),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.01 ~ \"Very low\",\n                           v == 0.025 ~ \"Low\",\n                           .default = \"High\"))\n\nC_heatmap &lt;-\n  data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = Fate), alpha = 1) + \n  geom_vline(aes(xintercept = 0), linetype = 2, colour = \"white\", linewidth = .8) +\n  scale_fill_manual(values = c(pnw_palette(\"Shuksan2\", n = 5)[2], pnw_palette(\"Shuksan2\", n = 5)[4], pnw_palette(\"Shuksan2\", n = 5)[5])) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Fate of _I_ allele\",\n       title = \"Cytoplasmic inbreeding alleles\") +\n  facet_wrap(sex_expressed ~ v_cat, nrow = 2,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}')) +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nC_heatmap\n\n\n\n\n\n\n\n\nNow lets plot a smaller parameter space, where each region of the space has been simulated 5 times.\n\n\nCode\nsim_results_small_space &lt;-\nsim_results_2 %&gt;% \n  left_join(parameters_2, by = \"parameter_space_ID\")\n\nheatmap_colours &lt;- rcartocolor::carto_pal(\"Emrld\", n = 20)\n\n\n\nAutosomalXZYWCytoplasmic\n\n\n\n\nCode\nA_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"A\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.025 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nA_heatmap &lt;-\n  A_data %&gt;%\n  #filter(dominance == 1) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  geom_vline(data = A_data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = A_data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*1)/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Autosomal inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nA_heatmap\n\n\n\n\n\n\nCode\nX_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"X\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.019 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nX_heatmap &lt;-\n  X_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                         limits = c(0, 1)) +\n  geom_vline(data = X_data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = X_data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*0.5)/(1 + 0.5*0.5)), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"X-linked inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nX_heatmap\n\n\n\n\n\n\nCode\nZ_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"Z\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.019 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nZ_heatmap &lt;-\n  Z_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                         limits = c(0, 1)) +\n  geom_vline(data = Z_data %&gt;% filter(sex_expressed == \"Males\"),\n             aes(xintercept = 1/(1 + (0.5*0.5))), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = Z_data %&gt;% filter(sex_expressed == \"Females\"),\n             aes(xintercept = (0.5*1)/(1 + (0.5*1))), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Z-linked inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nZ_heatmap\n\n\n\n\n\n\nCode\nY_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"Y\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.006 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nY_heatmap &lt;-\n  Y_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  geom_vline(aes(xintercept = 1), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Y-linked inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nY_heatmap\n\n\n\n\n\n\nCode\nW_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"W\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.006 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nW_heatmap &lt;-\n  W_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                         limits = c(0, 1)) +\n  geom_vline(aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"W-linked inbreeding alleles\") +\n      facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nW_heatmap\n\n\n\n\n\n\nCode\nC_data &lt;-\n  sim_results_small_space %&gt;%\n  filter(chromosome == \"C\") %&gt;%  \n  group_by(parameter_space_ID) %&gt;% \n  slice_tail() %&gt;% \n  ungroup() %&gt;%\n  group_by(space = rep(row_number(), length.out = n(), each = 5)) %&gt;% \n  group_by(space) %&gt;% \n  mutate(invasion_freq = sum(proportion_I &gt; 0.5)/5) %&gt;%\n  ungroup() %&gt;% \n  distinct(space, .keep_all = T) %&gt;% \n  mutate(D_prop = D*-1,\n         v = round(v, 3),\n         sex_expressed = case_when(sex_expressed == 0 ~ \"Males\",\n                                   .default = \"Females\"),\n         v_cat = case_when(v == 0.013 ~ \"Low\",\n                           .default = \"High\"),\n          dominance = case_when(dominance == 0 ~ \"Recessive\",\n                           .default = \"Dominant\"))\n\nC_heatmap &lt;-\n  C_data %&gt;%\n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                         limits = c(0, 1)) +\n  geom_vline(aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\\n(prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Cytoplasmic inbreeding alleles\") +\n  facet_wrap(dominance + v_cat~ sex_expressed, nrow = 4,\n             labeller = label_glue('Sex: {`sex_expressed`}\\nEncounter rate: {`v_cat`}\\nExpression: {`dominance`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown())\n\nC_heatmap\n\n\n\n\n\nFinally, lets compare invasion across chromosomes, taking only the dominant, high encounter rate cases.\n\n\nCode\nchromosome_invasion_data &lt;-\nbind_rows(\n  A_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  X_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  Z_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  W_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  Y_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq),\n  \n  C_data %&gt;% \n    filter(v_cat == \"High\" & dominance == \"Dominant\") %&gt;% \n    select(chromosome, sex_expressed, D_prop, refractory_period, invasion_freq)) %&gt;% \n  mutate(Location = case_when(chromosome == \"A\"~ \"Autosome\",\n                              chromosome == \"X\" ~ \"X\",\n                              chromosome == \"Z\" ~ \"Z\",\n                              chromosome == \"Y\" ~ \"Y\",\n                              chromosome == \"W\" ~ \"W\",\n                              chromosome == \"C\"~ \"Cytoplasmic\")) %&gt;% \n  mutate(Location = fct_relevel(Location, \"Autosome\", \"X\", \"Z\", \"Y\", \"W\", \"Cytoplasmic\"))\n  \np1 &lt;-\nchromosome_invasion_data %&gt;% \n  filter(sex_expressed == \"Females\") %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Autosome\"),\n             aes(xintercept = (0.5*1)/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"X\"),\n             aes(xintercept = (0.5*0.5)/(1 + 0.5*0.5)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Z\"),\n             aes(xintercept = (0.5*1)/(1 + (0.5*1))), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"W\"),\n             aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Cytoplasmic\"),\n             aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period (prop. mean lifespan)\",\n       fill = \"Prop. _I_ invades\",\n       title = \"Inbreeding controlled by females\") +\n  facet_wrap(~Location, nrow = 5,\n             labeller = label_glue('Location: {`Location`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 14),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown(size = 14))\n\np2 &lt;-\nchromosome_invasion_data %&gt;% \n  filter(sex_expressed == \"Males\") %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = invasion_freq), alpha = 1) + \n  scale_fill_gradientn(colours = heatmap_colours,\n                       limits = c(0, 1)) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Autosome\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"X\"),\n             aes(xintercept = 1/(1 + 0.5*1)), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Z\"),\n             aes(xintercept = 1/(1 + (0.5*0.5))), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Y\"),\n             aes(xintercept = 1), linetype = 2, colour = \"black\", linewidth = .8) +\n  geom_vline(data = chromosome_invasion_data %&gt;% filter(Location == \"Cytoplasmic\"),\n             aes(xintercept = 0), linetype = 2, colour = \"black\", linewidth = .8) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = NULL,\n       fill = \"Prop. _I_ invades\",\n       title = \"Inbreeding controlled by males\") +\n  facet_wrap(~Location, nrow = 5,\n             labeller = label_glue('Location: {`Location`}'),\n             scales = \"free\") +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 14),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14),\n        legend.title = element_markdown(size = 14))\n\np1 + p2 + plot_layout(guides = \"collect\", axes = \"collect\")"
  },
  {
    "objectID": "Selfish_inbreeding.html",
    "href": "Selfish_inbreeding.html",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "I think we can answer our question using the Kokko and Ots framework, but is it the right choice? Given we take a gene’s eye view, is a population genetic model (or if too difficult, a simulation) required.\nKin selection pop-gen models are well developed, by the time in, time out investment into reproduction dynamics is going to require lots of thinking on my behalf.\nThis is my first goal…\n\n\n\nLet’s build a single autosomal locus, bi-allelic model, assuming Hardy-Weinberg equilibrium.\n\nThe \\(A\\) allele is the ‘non-donor’ allele (can be thought of as an allele encoding outbreeding preference). The frequency of this allele is \\(p\\).\nThe \\(a\\) allele is the donor allele (the altruistic allele, which may encode inbreeding preference). The frequency of this allele is \\(q = 1 - p\\).\n\\(1 - h^2\\) is the likelihood that the \\(Aa\\) genotype exhibits the altruistic behaviour. If \\(h^2 = 1\\) then the allele is completely recessive.\n\nThe next step is to find all possible mating types:\n\n\nCode\nmake_mating_table &lt;- function(){#k, normalP1, P1cost, P2cost){\n  \n  make_offspring &lt;- function(X, Y, type, zygote_freq){\n    tibble(mother = X,\n           father = Y,\n           type,\n           zygote_freq)\n  }\n\n  # Set up the 9 possible mating combinations\n  \n  mating_types &lt;- expand_grid(\n    mother = c(\"AA_female\",\n               \"Aa_female\",\n               \"aa_female\"),\n    father = c(\"AA_male\",\n                \"Aa_male\",\n                \"aa_male\"))\n\n\n # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function\n  \n  # AA x AA\n  \n  g0 &lt;- c(\"AA_female\", \"AA_male\")\n  \n  # Aa x AA & AA x Aa\n  \n  g1 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\")\n  \n  # aa x AA & AA x aa\n  \n  g2 &lt;- c(\"Aa_female\", \"Aa_male\")\n  \n  # Aa x Aa\n  \n  g3 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # Aa x aa & aa x Aa\n  \n  g4 &lt;- c(\"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # aa x aa\n  \n  g5 &lt;- c(\"aa_female\", \"aa_male\")\n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # even frequency of four offspring types\n  \n  rep25 &lt;- rep(0.25, 4)\n  \n  # even frequency between two offspring types\n  \n  rep5 &lt;- rep(0.5, 2)\n  \n  # Aa * Aa\n  \n  p1 &lt;- c(0.5*0.25,\n          0.5*0.25,\n          0.5*0.5,\n          0.5*0.5,\n          0.5*0.25,\n          0.5*0.25)\n  \n    bind_rows(\n    list(\n      make_offspring(\"AA\", \"AA\", g0, rep5),\n      make_offspring(\"AA\", \"Aa\", g1, rep25),\n      make_offspring(\"AA\", \"aa\", g2, rep5),\n      make_offspring(\"Aa\", \"AA\", g1, rep25),\n      make_offspring(\"Aa\", \"Aa\", g3, p1),\n      make_offspring(\"Aa\", \"aa\", g4, rep25),\n      make_offspring(\"aa\", \"AA\", g2, rep5),\n      make_offspring(\"aa\", \"Aa\", g4, rep25),\n      make_offspring(\"aa\", \"aa\", g5, rep5)\n    )) %&gt;% \n    arrange(mother, father)\n  \n}\n\nmake_mating_table() %&gt;% \n  rename(zygote_type = type) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\nThe frequency of each mating type can be generated using the terms of the classic equation:\n\\[(p^2 + 2pq + q^2)^2\\] Note the final square generates the mating combination.\nThe frequencies of each genotype are\n\n\nCode\n(Mating_type_freqs &lt;-\n  tibble(mother = c(\"AA\",\"AA\",\"AA\",\"Aa\",\"Aa\",\"Aa\",\"aa\",\"aa\",\"aa\"),\n         father = c(\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\"),\n         frequency = c(\"(p^4)/2\", \"(4p^3*q)/2\", \"(2p^2*2q^2)/2\", \"(4p^3*q)/2\",\n                       \"(4p^2*q^2)/2\", \"(4p*q^3)/2\", \"(2p^2*2q^2)/2\", \"(4p*q^3)/2\",\n                       \"(q^4)/2\"\n                       )) %&gt;% \n  kable() %&gt;% \n    kable_styling())\n\n\n\n\n\n\nThis is a two-step process. First we determine the frequencies of each genotype in the mating population (this could be, for example, after we’ve accounted for inbreeding costs), then we calculate the frequencies of each potential mating combination between these genotypes.\nStep 1 - finding the genotype frequencies in the mating population\nHere we can model an inbreeding depression effect, by changing the viability of different genotypes. I make this a constant for now, to aid my initial understanding, but later this will be one of the key parameters to vary.\nI have also allowed the dominance of \\(a\\) to vary. While inbreeding depression is the result of the increased expression of recessive alleles through homozygosity, partially recessive alleles are likely to be common. When \\(h = 1\\), the \\(a\\) allele is completely recessive.\n\n\nCode\negg_adult_viability_Aa_finder &lt;- function(h){1 - 0.33*(1 - h)}\n\n\n# viability of each genotype \n\negg_adult_viability_AA_female &lt;- 1\n\negg_adult_viability_Aa_female &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_female &lt;- 0.67\n\negg_adult_viability_AA_male &lt;- 1\n\negg_adult_viability_Aa_male &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_male &lt;- 0.67\n\n\nUsing these parameters, we implement selection, so that each genotype is represented in the mating combinations according to the product of its frequency and its viability, which is determined by inbreeding depression. I assume that mating success is constant across genotypes (this may not be possible if one allele approaches extinction).\nStep 2 - finding the frequency of all potential mating combinations in the mating population\nNext, we model the effect of inbreeding preference on inclusive fitness (direct + indirect fitness). I first assume that individuals are faced with a simultaneous choice situation - between mating with a relative or mating with an unrelated individual.\nFor simplicity at the outset, I assume that inbreeding preference is only expressed in females. To simulate inbreeding preference, females carrying the \\(a\\) allele mate with siblings (those individuals produced by the same parental genotype combination). However, dominance also plays a role here. A proportion \\(1 - h\\) of \\(Aa\\) females express inbreeding preference, whereas a proportion \\(h\\) do not.\nWith the above in mind, I calculate the expected frequencies of each possible ‘mating combination’ (i.e. the combination of the maternal and paternal genotypes) across the population. For singly-mated females with genotype \\(AA\\), the frequency of each mating type is simply given by \\(F_iM_j\\), where \\(F_i\\) and \\(M_j\\) are the female and male parental genotype frequencies, that is they choose mates at random. For females with genotype \\(Aa\\) a proportion \\(1 - h\\) express a preference for inbreeding. For these females, the expected frequencies for each mating type are determined by the parental mating type combination they were produced by. These females randomly choose a mate from a subset of possible genotypes produced by the parental combination e.g. an \\(AA\\) x \\(aa\\) mating will produce a female that will choose to mate with a \\(Aa\\) male (the only possible genotype of her brothers). The proportion \\(h\\) of \\(Aa\\) females not expressing the \\(a\\) allele choose mates at random. Finally, All \\(aa\\) females choose to mate with individuals sired by the same parental genotypes.\n\n\nCode\nfind_mating_type_frequencies &lt;- function(pop, prob_remating_SD, prob_remating_W){\n  \n  # Step 1\n  \n  pop$prop &lt;- pop$prop * pop$egg_adult_viability # here's the selection step \n  pop$prop &lt;- pop$prop / sum(pop$prop) # now restandardise so that the props sum to 1\n  \n  # Step 2\n  \n  # Calculate the frequency of each single-mating combination\n  \n  first_mating_types &lt;- \n    expand_grid(mother = pop$type[str_detect(pop$type, \"female\")], # find all possible mother genotypes\n                father = pop$type[!str_detect(pop$type, \"female\")]) %&gt;% # find all possible father1 genotypes\n    mutate(prop_matings = 0, remating_probability = 0) # make placeholder columns we will fill in below\n  \n  # find genotype frequencies calculated for each sex (mate choice means these will not necessarily be 50:50)\n  \n  female_frequencies &lt;- pop %&gt;% filter(str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  male_frequencies &lt;- pop %&gt;% filter(!str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  \n  # This next step multiplies the proportion[i] of females with genotype[i] with the proportion[i] of males with genotype[i] \n  \n  for(i in 1:nrow(first_mating_types)){\n    first_mating_types$prop_matings[i] &lt;- female_frequencies$prop[female_frequencies$type == first_mating_types$mother[i]] * \n      male_frequencies$prop[male_frequencies$type == first_mating_types$father1[i]]\n  }\n  \n  # Now we incorporate female remating probabilities (SDSD males assumed to have same effect on females as WW males)\n  \n  first_mating_types$remating_probability &lt;- ifelse(str_detect(first_mating_types$father1, \"WSD\"), prob_remating_SD, prob_remating_W)\n  \n  # Now lets calculate the frequency of each double-mating combination, with the end product being the mating_type_frequency of each mating possibility\n  \n  second_mating_types &lt;- expand_grid(first_mating_types, father2 = c(\"none\", unique(first_mating_types$father1))) %&gt;%\n    mutate(mating_type_freq = 0)\n  \n  # scale the proportion of matings calculated above by the likelihood that these females will mate once\n  \n  for(i in 1:nrow(second_mating_types)){\n    if(second_mating_types$father2[i] == \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        (1 - second_mating_types$remating_probability[i])\n    }\n    \n    # now calculate the frequency of mating tryads for the females that mate twice\n    \n    if(second_mating_types$father2[i] != \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        second_mating_types$remating_probability[i] *\n        male_frequencies$prop[male_frequencies$type == second_mating_types$father2[i]] # pop. freq of the 2nd male type\n    }\n  }\n  \n  second_mating_types %&gt;% # output\n    select(mother, father1, father2, mating_type_freq) %&gt;%\n    # clean up the output by remving redundant info (makes it easier later)\n    mutate(mother = str_remove_all(mother, \"_female\"),\n           father1 = str_remove_all(father1, \"_male\"),\n           father2 = str_remove_all(father2, \"_male\"))\n}\n\n\n\n\n\n\n\n\\(~\\)\nThis is hard, but everything should be in the Kokko and Ots paper\nWe can now directly follow Kokko and Ots (2006), altering the equations where required to reflect the fitness consequences of inbreeding for different chromosomes.\n\n\n\n\n\n\nParameter definitions\n\n\n\n\\(\\delta\\): fraction of offspring lost due to inbreeding (inbreeding depression)\n\\(v_I\\): ‘time in’ reproductive value of individuals of the choosing sex\n\\(w_I\\): ‘time in’ reproductive value of individuals of the opposite sex\n\\(v_O\\): ‘time out’ reproductive value of individuals of the choosing sex\n\\(w_O\\): ‘time out’ reproductive value of individuals of the opposite sex\n\\(M\\): the unrelated mate encounter rate during time in (when sex ratio is unbiased)\n\\(m_v = M \\sqrt{\\beta}\\): the mating rate for the choosy sex\n\\(m_w = \\frac{M}{\\sqrt{\\beta}}\\): the mating rate for the opposite sex\n\\(\\beta\\): the operational sex ratio (males:females)\n\\(a\\): average number of offspring produced from a mating (I think - needs to be found numerically)\n\\(T_v\\): time out duration for choosing sex\n\\(T_w\\): time out duration for opposite sex\n\\(\\mu_{Iv}\\): ‘time in’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Iw}\\): ‘time in’ mortality risk of individuals of the opposite sex\n\\(\\mu_{Ov}\\): ‘time out’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Ow}\\): ‘time out’ mortality risk of individuals of the opposite sex\n\n\nAfter mating, offspring are produced, with a direct fitness benefit of \\[a(v_I + w_I)\\]\n\n\nThe choosing sex can either mate with an unrelated individual or an individual related by \\(r\\).\nMate with unrelated individual: \\(v_O + ro_iw_I + a(v_I + w_1)\\)\nMate with kin: \\(v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1)\\)\nWe continue to frame our study around the value of \\(\\delta\\) that can be tolerated, or put another way, to what extent can inbreeding reduce offspring viability and still be the selected strategy?\nWe therefore rearrange the equation to find the threshold value of \\(\\delta\\) where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_O + ro_iw_I + a(v_I + w_1)\\]\nto\n\\[\\delta_{sim} = 1 - \\frac{a(v_I + w_I) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] which can be more neatly expressed as\n\\[\\delta_{sim} = \\frac{a ro_i(v_I + w_I) - ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\]\n\n\n\nIn this scenario, a choosy individual (note that our models are framed around the strategy adopted by the choosy individuals) encounters a single potential mate, related by \\(r\\). The choosing sex can either mate with this individual or elect not to mate and wait for a future opportunity.\nNot mating produces the inclusive fitness:\n\\[v_I + ro_iw_I\\] Now an inbreeding preference strategy is favoured where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_I + ro_iw_I\\]\nThus, the threshold \\(\\delta\\) value below which inbreeding is adaptive is\n\\[\\delta_{seq} = 1 - \\frac{(v_I - v_O) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] \\(~\\)\n\n\n\n\n\\(~\\)\n$$\n\\[\\begin{bmatrix}dv_I/dt\\\\\ndv_O/dt\\\\\ndw_I/dt\\\\\ndw_O/dt\n\\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix}-\\mu_{Iv} + m_v(a - 1)  & m_v & am_v &  0\\\\\n1/T_v & 1/T_v -\\mu_{Ov} & 0 & 0\\\\\nam_w & 0 & -\\mu_{Iw} + m_w(a - 1) & m_w\\\\\n0 & 0 & 1/Tw & 1/T_w -\\mu_{Ow}\n\\end{bmatrix}\\]\n\n\\[\\begin{bmatrix}v_I\\\\\nv_O\\\\\nw_I\\\\\nw_O\n\\end{bmatrix}\\]\n$$\n\n\n\nCode\nm1 &lt;- matrix(c(1:4), ncol = 1)\n\nm2 &lt;- matrix(c(1:16), nrow = 4, ncol = 4)\n\nm2 %*% m1\n\n\n     [,1]\n[1,]   90\n[2,]  100\n[3,]  110\n[4,]  120\n\n\nCreate a function to calculate reproductive value for each state\n\n\nCode\nchange_repro_values &lt;- \n  matrix(c(-1*death_rate_in_choosy_sex + mating_rate_choosy_sex *(a - 1),\n           mating_rate_choosy_sex,\n           a*mating_rate_choosy_sex,\n           0,\n           1/time_out_duration_choosy_sex,\n           -1/time_out_duration_choosy_sex - death_rate_out_choosy_sex,\n           0,\n           0,\n           a*mating_rate_opp_sex,\n           0,\n           -1*death_rate_in_opp_sex + mating_rate_opp_sex *(a - 1),\n           mating_rate_opp_sex,\n           0,\n           0,\n           1/time_out_duration_opp_sex,\n           -1/time_out_duration_opp_sex - death_rate_out_opp_sex),\n         nrow = 4, ncol = 4)\n\nstate_repro_values &lt;- c(vI, vO, wI, wO)\n\nparameters &lt;- \n  expand_grid(r = 0.5,\n              x = c(0, 0.5, 1),\n              death_rate_in_choosy_sex = 1,\n              mating_rate_choosy_sex = ,\n              time_out_duration_choosy_sex = c(0.1, 0.01),\n              death_rate_out_choosy_sex = 1,\n              mating_rate_opp_sex = ,\n              death_rate_in_opp_sex = 1,\n              time_out_duration_opp_sex = ,\n              death_rate_out_opp_sex = 1,\n              a = ((mating_rate_choosy_sex*(1/time_out_duration_choosy_sex + death_rate_in_choosy_sex)/\n                      (death_rate_out_choosy_sex/time_out_duration_choosy_sex + \n                         death_rate_in_choosy_sex*(mating_rate_choosy_sex + death_rate_out_choosy_sex)))^-1)/2\n  )"
  },
  {
    "objectID": "Selfish_inbreeding.html#changing-the-focus-from-chromosomes-to-alleles",
    "href": "Selfish_inbreeding.html#changing-the-focus-from-chromosomes-to-alleles",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "I think we can answer our question using the Kokko and Ots framework, but is it the right choice? Given we take a gene’s eye view, is a population genetic model (or if too difficult, a simulation) required.\nKin selection pop-gen models are well developed, by the time in, time out investment into reproduction dynamics is going to require lots of thinking on my behalf.\nThis is my first goal…\n\n\n\nLet’s build a single autosomal locus, bi-allelic model, assuming Hardy-Weinberg equilibrium.\n\nThe \\(A\\) allele is the ‘non-donor’ allele (can be thought of as an allele encoding outbreeding preference). The frequency of this allele is \\(p\\).\nThe \\(a\\) allele is the donor allele (the altruistic allele, which may encode inbreeding preference). The frequency of this allele is \\(q = 1 - p\\).\n\\(1 - h^2\\) is the likelihood that the \\(Aa\\) genotype exhibits the altruistic behaviour. If \\(h^2 = 1\\) then the allele is completely recessive.\n\nThe next step is to find all possible mating types:\n\n\nCode\nmake_mating_table &lt;- function(){#k, normalP1, P1cost, P2cost){\n  \n  make_offspring &lt;- function(X, Y, type, zygote_freq){\n    tibble(mother = X,\n           father = Y,\n           type,\n           zygote_freq)\n  }\n\n  # Set up the 9 possible mating combinations\n  \n  mating_types &lt;- expand_grid(\n    mother = c(\"AA_female\",\n               \"Aa_female\",\n               \"aa_female\"),\n    father = c(\"AA_male\",\n                \"Aa_male\",\n                \"aa_male\"))\n\n\n # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function\n  \n  # AA x AA\n  \n  g0 &lt;- c(\"AA_female\", \"AA_male\")\n  \n  # Aa x AA & AA x Aa\n  \n  g1 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\")\n  \n  # aa x AA & AA x aa\n  \n  g2 &lt;- c(\"Aa_female\", \"Aa_male\")\n  \n  # Aa x Aa\n  \n  g3 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # Aa x aa & aa x Aa\n  \n  g4 &lt;- c(\"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # aa x aa\n  \n  g5 &lt;- c(\"aa_female\", \"aa_male\")\n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # even frequency of four offspring types\n  \n  rep25 &lt;- rep(0.25, 4)\n  \n  # even frequency between two offspring types\n  \n  rep5 &lt;- rep(0.5, 2)\n  \n  # Aa * Aa\n  \n  p1 &lt;- c(0.5*0.25,\n          0.5*0.25,\n          0.5*0.5,\n          0.5*0.5,\n          0.5*0.25,\n          0.5*0.25)\n  \n    bind_rows(\n    list(\n      make_offspring(\"AA\", \"AA\", g0, rep5),\n      make_offspring(\"AA\", \"Aa\", g1, rep25),\n      make_offspring(\"AA\", \"aa\", g2, rep5),\n      make_offspring(\"Aa\", \"AA\", g1, rep25),\n      make_offspring(\"Aa\", \"Aa\", g3, p1),\n      make_offspring(\"Aa\", \"aa\", g4, rep25),\n      make_offspring(\"aa\", \"AA\", g2, rep5),\n      make_offspring(\"aa\", \"Aa\", g4, rep25),\n      make_offspring(\"aa\", \"aa\", g5, rep5)\n    )) %&gt;% \n    arrange(mother, father)\n  \n}\n\nmake_mating_table() %&gt;% \n  rename(zygote_type = type) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\nThe frequency of each mating type can be generated using the terms of the classic equation:\n\\[(p^2 + 2pq + q^2)^2\\] Note the final square generates the mating combination.\nThe frequencies of each genotype are\n\n\nCode\n(Mating_type_freqs &lt;-\n  tibble(mother = c(\"AA\",\"AA\",\"AA\",\"Aa\",\"Aa\",\"Aa\",\"aa\",\"aa\",\"aa\"),\n         father = c(\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\"),\n         frequency = c(\"(p^4)/2\", \"(4p^3*q)/2\", \"(2p^2*2q^2)/2\", \"(4p^3*q)/2\",\n                       \"(4p^2*q^2)/2\", \"(4p*q^3)/2\", \"(2p^2*2q^2)/2\", \"(4p*q^3)/2\",\n                       \"(q^4)/2\"\n                       )) %&gt;% \n  kable() %&gt;% \n    kable_styling())"
  },
  {
    "objectID": "Selfish_inbreeding.html#function-to-determine-the-mating-type-frequencies-of-the-population",
    "href": "Selfish_inbreeding.html#function-to-determine-the-mating-type-frequencies-of-the-population",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "This is a two-step process. First we determine the frequencies of each genotype in the mating population (this could be, for example, after we’ve accounted for inbreeding costs), then we calculate the frequencies of each potential mating combination between these genotypes.\nStep 1 - finding the genotype frequencies in the mating population\nHere we can model an inbreeding depression effect, by changing the viability of different genotypes. I make this a constant for now, to aid my initial understanding, but later this will be one of the key parameters to vary.\nI have also allowed the dominance of \\(a\\) to vary. While inbreeding depression is the result of the increased expression of recessive alleles through homozygosity, partially recessive alleles are likely to be common. When \\(h = 1\\), the \\(a\\) allele is completely recessive.\n\n\nCode\negg_adult_viability_Aa_finder &lt;- function(h){1 - 0.33*(1 - h)}\n\n\n# viability of each genotype \n\negg_adult_viability_AA_female &lt;- 1\n\negg_adult_viability_Aa_female &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_female &lt;- 0.67\n\negg_adult_viability_AA_male &lt;- 1\n\negg_adult_viability_Aa_male &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_male &lt;- 0.67\n\n\nUsing these parameters, we implement selection, so that each genotype is represented in the mating combinations according to the product of its frequency and its viability, which is determined by inbreeding depression. I assume that mating success is constant across genotypes (this may not be possible if one allele approaches extinction).\nStep 2 - finding the frequency of all potential mating combinations in the mating population\nNext, we model the effect of inbreeding preference on inclusive fitness (direct + indirect fitness). I first assume that individuals are faced with a simultaneous choice situation - between mating with a relative or mating with an unrelated individual.\nFor simplicity at the outset, I assume that inbreeding preference is only expressed in females. To simulate inbreeding preference, females carrying the \\(a\\) allele mate with siblings (those individuals produced by the same parental genotype combination). However, dominance also plays a role here. A proportion \\(1 - h\\) of \\(Aa\\) females express inbreeding preference, whereas a proportion \\(h\\) do not.\nWith the above in mind, I calculate the expected frequencies of each possible ‘mating combination’ (i.e. the combination of the maternal and paternal genotypes) across the population. For singly-mated females with genotype \\(AA\\), the frequency of each mating type is simply given by \\(F_iM_j\\), where \\(F_i\\) and \\(M_j\\) are the female and male parental genotype frequencies, that is they choose mates at random. For females with genotype \\(Aa\\) a proportion \\(1 - h\\) express a preference for inbreeding. For these females, the expected frequencies for each mating type are determined by the parental mating type combination they were produced by. These females randomly choose a mate from a subset of possible genotypes produced by the parental combination e.g. an \\(AA\\) x \\(aa\\) mating will produce a female that will choose to mate with a \\(Aa\\) male (the only possible genotype of her brothers). The proportion \\(h\\) of \\(Aa\\) females not expressing the \\(a\\) allele choose mates at random. Finally, All \\(aa\\) females choose to mate with individuals sired by the same parental genotypes.\n\n\nCode\nfind_mating_type_frequencies &lt;- function(pop, prob_remating_SD, prob_remating_W){\n  \n  # Step 1\n  \n  pop$prop &lt;- pop$prop * pop$egg_adult_viability # here's the selection step \n  pop$prop &lt;- pop$prop / sum(pop$prop) # now restandardise so that the props sum to 1\n  \n  # Step 2\n  \n  # Calculate the frequency of each single-mating combination\n  \n  first_mating_types &lt;- \n    expand_grid(mother = pop$type[str_detect(pop$type, \"female\")], # find all possible mother genotypes\n                father = pop$type[!str_detect(pop$type, \"female\")]) %&gt;% # find all possible father1 genotypes\n    mutate(prop_matings = 0, remating_probability = 0) # make placeholder columns we will fill in below\n  \n  # find genotype frequencies calculated for each sex (mate choice means these will not necessarily be 50:50)\n  \n  female_frequencies &lt;- pop %&gt;% filter(str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  male_frequencies &lt;- pop %&gt;% filter(!str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  \n  # This next step multiplies the proportion[i] of females with genotype[i] with the proportion[i] of males with genotype[i] \n  \n  for(i in 1:nrow(first_mating_types)){\n    first_mating_types$prop_matings[i] &lt;- female_frequencies$prop[female_frequencies$type == first_mating_types$mother[i]] * \n      male_frequencies$prop[male_frequencies$type == first_mating_types$father1[i]]\n  }\n  \n  # Now we incorporate female remating probabilities (SDSD males assumed to have same effect on females as WW males)\n  \n  first_mating_types$remating_probability &lt;- ifelse(str_detect(first_mating_types$father1, \"WSD\"), prob_remating_SD, prob_remating_W)\n  \n  # Now lets calculate the frequency of each double-mating combination, with the end product being the mating_type_frequency of each mating possibility\n  \n  second_mating_types &lt;- expand_grid(first_mating_types, father2 = c(\"none\", unique(first_mating_types$father1))) %&gt;%\n    mutate(mating_type_freq = 0)\n  \n  # scale the proportion of matings calculated above by the likelihood that these females will mate once\n  \n  for(i in 1:nrow(second_mating_types)){\n    if(second_mating_types$father2[i] == \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        (1 - second_mating_types$remating_probability[i])\n    }\n    \n    # now calculate the frequency of mating tryads for the females that mate twice\n    \n    if(second_mating_types$father2[i] != \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        second_mating_types$remating_probability[i] *\n        male_frequencies$prop[male_frequencies$type == second_mating_types$father2[i]] # pop. freq of the 2nd male type\n    }\n  }\n  \n  second_mating_types %&gt;% # output\n    select(mother, father1, father2, mating_type_freq) %&gt;%\n    # clean up the output by remving redundant info (makes it easier later)\n    mutate(mother = str_remove_all(mother, \"_female\"),\n           father1 = str_remove_all(father1, \"_male\"),\n           father2 = str_remove_all(father2, \"_male\"))\n}"
  },
  {
    "objectID": "Selfish_inbreeding.html#time-in-and-time-out",
    "href": "Selfish_inbreeding.html#time-in-and-time-out",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "\\(~\\)\nThis is hard, but everything should be in the Kokko and Ots paper\nWe can now directly follow Kokko and Ots (2006), altering the equations where required to reflect the fitness consequences of inbreeding for different chromosomes.\n\n\n\n\n\n\nParameter definitions\n\n\n\n\\(\\delta\\): fraction of offspring lost due to inbreeding (inbreeding depression)\n\\(v_I\\): ‘time in’ reproductive value of individuals of the choosing sex\n\\(w_I\\): ‘time in’ reproductive value of individuals of the opposite sex\n\\(v_O\\): ‘time out’ reproductive value of individuals of the choosing sex\n\\(w_O\\): ‘time out’ reproductive value of individuals of the opposite sex\n\\(M\\): the unrelated mate encounter rate during time in (when sex ratio is unbiased)\n\\(m_v = M \\sqrt{\\beta}\\): the mating rate for the choosy sex\n\\(m_w = \\frac{M}{\\sqrt{\\beta}}\\): the mating rate for the opposite sex\n\\(\\beta\\): the operational sex ratio (males:females)\n\\(a\\): average number of offspring produced from a mating (I think - needs to be found numerically)\n\\(T_v\\): time out duration for choosing sex\n\\(T_w\\): time out duration for opposite sex\n\\(\\mu_{Iv}\\): ‘time in’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Iw}\\): ‘time in’ mortality risk of individuals of the opposite sex\n\\(\\mu_{Ov}\\): ‘time out’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Ow}\\): ‘time out’ mortality risk of individuals of the opposite sex\n\n\nAfter mating, offspring are produced, with a direct fitness benefit of \\[a(v_I + w_I)\\]\n\n\nThe choosing sex can either mate with an unrelated individual or an individual related by \\(r\\).\nMate with unrelated individual: \\(v_O + ro_iw_I + a(v_I + w_1)\\)\nMate with kin: \\(v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1)\\)\nWe continue to frame our study around the value of \\(\\delta\\) that can be tolerated, or put another way, to what extent can inbreeding reduce offspring viability and still be the selected strategy?\nWe therefore rearrange the equation to find the threshold value of \\(\\delta\\) where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_O + ro_iw_I + a(v_I + w_1)\\]\nto\n\\[\\delta_{sim} = 1 - \\frac{a(v_I + w_I) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] which can be more neatly expressed as\n\\[\\delta_{sim} = \\frac{a ro_i(v_I + w_I) - ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\]\n\n\n\nIn this scenario, a choosy individual (note that our models are framed around the strategy adopted by the choosy individuals) encounters a single potential mate, related by \\(r\\). The choosing sex can either mate with this individual or elect not to mate and wait for a future opportunity.\nNot mating produces the inclusive fitness:\n\\[v_I + ro_iw_I\\] Now an inbreeding preference strategy is favoured where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_I + ro_iw_I\\]\nThus, the threshold \\(\\delta\\) value below which inbreeding is adaptive is\n\\[\\delta_{seq} = 1 - \\frac{(v_I - v_O) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] \\(~\\)\n\n\n\n\n\\(~\\)\n$$\n\\[\\begin{bmatrix}dv_I/dt\\\\\ndv_O/dt\\\\\ndw_I/dt\\\\\ndw_O/dt\n\\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix}-\\mu_{Iv} + m_v(a - 1)  & m_v & am_v &  0\\\\\n1/T_v & 1/T_v -\\mu_{Ov} & 0 & 0\\\\\nam_w & 0 & -\\mu_{Iw} + m_w(a - 1) & m_w\\\\\n0 & 0 & 1/Tw & 1/T_w -\\mu_{Ow}\n\\end{bmatrix}\\]\n\n\\[\\begin{bmatrix}v_I\\\\\nv_O\\\\\nw_I\\\\\nw_O\n\\end{bmatrix}\\]\n$$\n\n\n\nCode\nm1 &lt;- matrix(c(1:4), ncol = 1)\n\nm2 &lt;- matrix(c(1:16), nrow = 4, ncol = 4)\n\nm2 %*% m1\n\n\n     [,1]\n[1,]   90\n[2,]  100\n[3,]  110\n[4,]  120\n\n\nCreate a function to calculate reproductive value for each state\n\n\nCode\nchange_repro_values &lt;- \n  matrix(c(-1*death_rate_in_choosy_sex + mating_rate_choosy_sex *(a - 1),\n           mating_rate_choosy_sex,\n           a*mating_rate_choosy_sex,\n           0,\n           1/time_out_duration_choosy_sex,\n           -1/time_out_duration_choosy_sex - death_rate_out_choosy_sex,\n           0,\n           0,\n           a*mating_rate_opp_sex,\n           0,\n           -1*death_rate_in_opp_sex + mating_rate_opp_sex *(a - 1),\n           mating_rate_opp_sex,\n           0,\n           0,\n           1/time_out_duration_opp_sex,\n           -1/time_out_duration_opp_sex - death_rate_out_opp_sex),\n         nrow = 4, ncol = 4)\n\nstate_repro_values &lt;- c(vI, vO, wI, wO)\n\nparameters &lt;- \n  expand_grid(r = 0.5,\n              x = c(0, 0.5, 1),\n              death_rate_in_choosy_sex = 1,\n              mating_rate_choosy_sex = ,\n              time_out_duration_choosy_sex = c(0.1, 0.01),\n              death_rate_out_choosy_sex = 1,\n              mating_rate_opp_sex = ,\n              death_rate_in_opp_sex = 1,\n              time_out_duration_opp_sex = ,\n              death_rate_out_opp_sex = 1,\n              a = ((mating_rate_choosy_sex*(1/time_out_duration_choosy_sex + death_rate_in_choosy_sex)/\n                      (death_rate_out_choosy_sex/time_out_duration_choosy_sex + \n                         death_rate_in_choosy_sex*(mating_rate_choosy_sex + death_rate_out_choosy_sex)))^-1)/2\n  )"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Notes",
    "section": "",
    "text": "Premise outline\nThis project centres around the fate of alleles that encode inbreeding preference / avoidance depending on where they occur within the genome.\nBut the deeper idea is that inbreeding is a ‘selfish action’ where some alleles benefit from helping copies of themselves in other individuals, to the detriment of the broader organism. This detriment occurs because of inbreeding depression, which occurs because of homozygosity at other loci across the genome. Homozygosity causes the expression of recessive deleterious alleles which are otherwise rarely expressed, reducing the number of viable offspring produced by the organism.\nTo represent the broader genome, we can use alleles on hemizygous sex chromosomes, which have no opportunity to be homozygous and thus can gain no benefits of helping a relative gain a breeding opportunity. This broadly aligns with the ‘interests’ of the organism. For example, in an XY system alleles on the Y do not increase the propagation of alleles identical by descent through inbreeding, because females do not carry a Y. An autosomal allele, however, does have the potential to increase the proliferation of its copies by increasing the chance of breeding with a relative. This benefit is somewhat similar to that achieved by meiotic drive allele (clarify your thoughts here).\nA second potential angle is to explore the effect of the sex an allele encoding a preference for inbreeding is expressed in. This is important because the conditions often applicable to expression in a male present a greater parameter space for inbreeding preference (to put it too simply, because males invest less in each mating opportunity than females). Sex-specific effects also interact with hemizygous conditions, because in addition to XY systems, ZW systems exist and suddenly hemizygous chromosomes are present in females.\nSo in sum, there is a likely conflict between alleles on different chromosomes over the tendency to inbreed and there is a second non-mutually exclusive conflict between the sexes over inbreeding tendency. Wow, this is cool.\nThis idea might be deeper still. We point out that alleles on hemizygous sex chromosomes gain no indirect inclusive fitness benefits by mating with kin. The kicker is that inbreeding is just one example of this larger idea. There are no inclusive fitness benefits for alleles that encode any altruistic behaviour towards opposite sex individuals (where one sex possesses a hemizygous sex chromosome).\nSome specific notes from the meeting\n\nHanna’s 2006 paper shows when a preference for inbreeding should or should not be favoured for an autosomal allele, but does not consider other regions of the genome.\nStart with the Parker 1/3 thing, which Hanna and co re-derive. But they implicitly assume that the alleles in question here are on an autosome. We can make the change that they are on a sex chromosome, as stipulated above.\nThe X and Z can also be explored, because of their unusual inheritance dynamics. E.g. the X spends 2/3 of its time in females, but is always expressed in males and vice versa for the W.\nDoes it matter whether the loci that cause inbreeding depression are on the same/different chromosomes as those that encode inbreeding preferences…\nBirds versus mammals, flies versus butterflies etc - different hemizygous sex chromosomes\nUnity breaks down because of inheritance differences\nHamilton 1967 extraordinary sex chromosomes paper is a nice angle here\nHaplodiploidy - this is an extension opportunity.\nI will also try to simulate this question.\n\n\\(~\\)\n\n\n\n\nHanna suggests that the time in, time out continuous framework might not be the best option, as it is not the most intuitive for others.\nPerhaps keeping it simple may be the best way forward - females mate once, males mate multiple times. This produces differences in the opportunity cost of mating between the sexes.\nA discrete time model might work better\nScottish group models the inbreeding problem in helpful ways\nAnother way is to follow the Ekrem paper and simulate in an intelligent way (this method might be particularly fruitful)\nEssentially browse the different ways to approach the problem and follow one you like best.\nModels like our developing one do not consider purging dynamics that should occur if inbreeding becomes common.\n\n\n\n\nHamilton 1963 & 1964\n\nWright’s coefficient of relationship - a pedigree based measure\n\nHamilton 1971 & 1972\n\nRegression coefficient between genotype of actor and recipient\n\nMichod and Hamilton 1980 - Coefficients of relatedness in sociobiology\n\n\\(r = \\frac{Cov(A_P, R_F)}{Cov(A_P, A_F)}\\)\nwhere \\(A_P\\) is the genetically encoded altruistic phenotype of the actor (with values 0, 0.5, 1 corresponding to the three possible genotypes, AA, Aa and aa)\nA_F is the frequency of the altruistic genotype in the actor\nR indicates the recepient\nOrlove 1975 and Orlove and Wood 1978 should be cited here as well\n\nGrafen 1985 - A geometric view of relatedness\n\nCrozier’s relatedness (1970) = genetic similarity: the extent to which they possess the same alleles (think genomic relatedness matrices)\nCrozier’s relationship (1970) = a measure of common ancestry that can be estimated from a pedigree (think animal models)\nPrice’s theorem is helpful. One important point is to divide the individual by its ploidy. This really matters for the inbreeding question.\n\nGardner, West and Wild 2011 - The genetical theory of kin selection\n\nTend to agree with Orlove and Wood 1978: \\(\\frac{Cov(g', g)}{Cov(g, g)}\\)\nNote that these are all individual measures of relatedness - we need to edit slightly to get gene’s eye view measures."
  },
  {
    "objectID": "notes.html#project-background-notes",
    "href": "notes.html#project-background-notes",
    "title": "Notes",
    "section": "",
    "text": "Premise outline\nThis project centres around the fate of alleles that encode inbreeding preference / avoidance depending on where they occur within the genome.\nBut the deeper idea is that inbreeding is a ‘selfish action’ where some alleles benefit from helping copies of themselves in other individuals, to the detriment of the broader organism. This detriment occurs because of inbreeding depression, which occurs because of homozygosity at other loci across the genome. Homozygosity causes the expression of recessive deleterious alleles which are otherwise rarely expressed, reducing the number of viable offspring produced by the organism.\nTo represent the broader genome, we can use alleles on hemizygous sex chromosomes, which have no opportunity to be homozygous and thus can gain no benefits of helping a relative gain a breeding opportunity. This broadly aligns with the ‘interests’ of the organism. For example, in an XY system alleles on the Y do not increase the propagation of alleles identical by descent through inbreeding, because females do not carry a Y. An autosomal allele, however, does have the potential to increase the proliferation of its copies by increasing the chance of breeding with a relative. This benefit is somewhat similar to that achieved by meiotic drive allele (clarify your thoughts here).\nA second potential angle is to explore the effect of the sex an allele encoding a preference for inbreeding is expressed in. This is important because the conditions often applicable to expression in a male present a greater parameter space for inbreeding preference (to put it too simply, because males invest less in each mating opportunity than females). Sex-specific effects also interact with hemizygous conditions, because in addition to XY systems, ZW systems exist and suddenly hemizygous chromosomes are present in females.\nSo in sum, there is a likely conflict between alleles on different chromosomes over the tendency to inbreed and there is a second non-mutually exclusive conflict between the sexes over inbreeding tendency. Wow, this is cool.\nThis idea might be deeper still. We point out that alleles on hemizygous sex chromosomes gain no indirect inclusive fitness benefits by mating with kin. The kicker is that inbreeding is just one example of this larger idea. There are no inclusive fitness benefits for alleles that encode any altruistic behaviour towards opposite sex individuals (where one sex possesses a hemizygous sex chromosome).\nSome specific notes from the meeting\n\nHanna’s 2006 paper shows when a preference for inbreeding should or should not be favoured for an autosomal allele, but does not consider other regions of the genome.\nStart with the Parker 1/3 thing, which Hanna and co re-derive. But they implicitly assume that the alleles in question here are on an autosome. We can make the change that they are on a sex chromosome, as stipulated above.\nThe X and Z can also be explored, because of their unusual inheritance dynamics. E.g. the X spends 2/3 of its time in females, but is always expressed in males and vice versa for the W.\nDoes it matter whether the loci that cause inbreeding depression are on the same/different chromosomes as those that encode inbreeding preferences…\nBirds versus mammals, flies versus butterflies etc - different hemizygous sex chromosomes\nUnity breaks down because of inheritance differences\nHamilton 1967 extraordinary sex chromosomes paper is a nice angle here\nHaplodiploidy - this is an extension opportunity.\nI will also try to simulate this question.\n\n\\(~\\)\n\n\n\n\nHanna suggests that the time in, time out continuous framework might not be the best option, as it is not the most intuitive for others.\nPerhaps keeping it simple may be the best way forward - females mate once, males mate multiple times. This produces differences in the opportunity cost of mating between the sexes.\nA discrete time model might work better\nScottish group models the inbreeding problem in helpful ways\nAnother way is to follow the Ekrem paper and simulate in an intelligent way (this method might be particularly fruitful)\nEssentially browse the different ways to approach the problem and follow one you like best.\nModels like our developing one do not consider purging dynamics that should occur if inbreeding becomes common.\n\n\n\n\nHamilton 1963 & 1964\n\nWright’s coefficient of relationship - a pedigree based measure\n\nHamilton 1971 & 1972\n\nRegression coefficient between genotype of actor and recipient\n\nMichod and Hamilton 1980 - Coefficients of relatedness in sociobiology\n\n\\(r = \\frac{Cov(A_P, R_F)}{Cov(A_P, A_F)}\\)\nwhere \\(A_P\\) is the genetically encoded altruistic phenotype of the actor (with values 0, 0.5, 1 corresponding to the three possible genotypes, AA, Aa and aa)\nA_F is the frequency of the altruistic genotype in the actor\nR indicates the recepient\nOrlove 1975 and Orlove and Wood 1978 should be cited here as well\n\nGrafen 1985 - A geometric view of relatedness\n\nCrozier’s relatedness (1970) = genetic similarity: the extent to which they possess the same alleles (think genomic relatedness matrices)\nCrozier’s relationship (1970) = a measure of common ancestry that can be estimated from a pedigree (think animal models)\nPrice’s theorem is helpful. One important point is to divide the individual by its ploidy. This really matters for the inbreeding question.\n\nGardner, West and Wild 2011 - The genetical theory of kin selection\n\nTend to agree with Orlove and Wood 1978: \\(\\frac{Cov(g', g)}{Cov(g, g)}\\)\nNote that these are all individual measures of relatedness - we need to edit slightly to get gene’s eye view measures."
  },
  {
    "objectID": "notes.html#section-2",
    "href": "notes.html#section-2",
    "title": "Notes",
    "section": "07/11/23",
    "text": "07/11/23\n\nr should not be called r. It is the multiplication of two conditional probabilities.\nThe problem with current r for our purposes is that inclusive fitness is an individual level fitness metric.\nOne plot is individual level fitness loss (strategic reference gene equivalent) from inbreeding as a bar plot for optimal level of inbreeding at each chromosome\nInterlocus (or more accurately inter-chromosome) sexual conflict plot\nHaplodiploids not from the a sense but the delta sense - follow-up project?"
  },
  {
    "objectID": "notes.html#section-3",
    "href": "notes.html#section-3",
    "title": "Notes",
    "section": "26/03/24",
    "text": "26/03/24\nSomething to think about is how we set genetics to affect the expression of inbreeding tolerance/preference. Things that matter include:\n\ndo we consider inbreeding expression as the additive result of multiple loci on different chromosomes, or do we consider each case separately. Probably not this\nis inbreeding expression binary, a threshold trait or a quantitative, normally distributed trait. The latter would allow us to model evolution towards some maximum. The former cases are simpler to code (particularly the first case) but still allow us to answer a very similar question. I have this as an additive case - being heterozygous leads to expression of inbreeding preference half of the time.\n\nWhat about paternal leakage in the mtDNA case?\nFemales don’t get direct benefits from inbreeding as easily as males, because they need to mate AND secure a breeding site. Breeding earlier than otherwise expected doesn’t help as much."
  },
  {
    "objectID": "notes.html#extension-ideas",
    "href": "notes.html#extension-ideas",
    "title": "Notes",
    "section": "Extension ideas",
    "text": "Extension ideas\n\nExploring the genetic implications of inbreeding\n\n\nHow does ecology affect inbreeding?\n\ndispersal costs/discrimination costs i.e. going unmated (Waser 1986)"
  },
  {
    "objectID": "new_sim.html",
    "href": "new_sim.html",
    "title": "Untitled",
    "section": "",
    "text": "Code\n# for tidy style coding and plotting\n\nlibrary(tidyverse) \n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\nlibrary(vroom) # to read lots of csv files at once\n\n\n\nAttaching package: 'vroom'\n\nThe following objects are masked from 'package:readr':\n\n    as.col_spec, col_character, col_date, col_datetime, col_double,\n    col_factor, col_guess, col_integer, col_logical, col_number,\n    col_skip, col_time, cols, cols_condense, cols_only, date_names,\n    date_names_lang, date_names_langs, default_locale, fwf_cols,\n    fwf_empty, fwf_positions, fwf_widths, locale, output_column,\n    problems, spec\n\n\nCode\n# more table options\n\nlibrary(pander) # for tables\nlibrary(kableExtra) # for scrolling tables\n\n\n\nAttaching package: 'kableExtra'\n\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n\n\nCode\nlibrary(data.table) # for efficient handling of large dataframes\n\n\n\nAttaching package: 'data.table'\n\nThe following objects are masked from 'package:lubridate':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\nThe following object is masked from 'package:purrr':\n\n    transpose\n\n\nCode\n# making ggplot more powerful\n\nlibrary(MetBrewer) # for colour palettes based upon artwork housed at the MET\nlibrary(MoMAColors) # for colour palettes based upon artwork housed at MoMA\n\n\nRegistered S3 method overwritten by 'MoMAColors':\n  method        from     \n  print.palette MetBrewer\n\n\nCode\nlibrary(wesanderson) # for colour palettes based on wes anderson movies\n\n\nRegistered S3 method overwritten by 'wesanderson':\n  method        from      \n  print.palette MoMAColors\n\n\nCode\nlibrary(rcartocolor) # for nice sequential colour schemes\nlibrary(PNWColors) # for colour palettes \nlibrary(tidybayes) # for plotting distributions\nlibrary(stickylabeller) # labelling facets with strings in ggplot\nlibrary(geomtextpath) # for curved plot annotations\nlibrary(ggtext) # for markdown syntax in plot labels\nlibrary(patchwork) # for patching plots together\nlibrary(ggnewscale) # to reset scales in plots, allowing multiple fill arguments in ggplot"
  },
  {
    "objectID": "new_sim.html#load-packages",
    "href": "new_sim.html#load-packages",
    "title": "Untitled",
    "section": "",
    "text": "Code\n# for tidy style coding and plotting\n\nlibrary(tidyverse) \n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\nlibrary(vroom) # to read lots of csv files at once\n\n\n\nAttaching package: 'vroom'\n\nThe following objects are masked from 'package:readr':\n\n    as.col_spec, col_character, col_date, col_datetime, col_double,\n    col_factor, col_guess, col_integer, col_logical, col_number,\n    col_skip, col_time, cols, cols_condense, cols_only, date_names,\n    date_names_lang, date_names_langs, default_locale, fwf_cols,\n    fwf_empty, fwf_positions, fwf_widths, locale, output_column,\n    problems, spec\n\n\nCode\n# more table options\n\nlibrary(pander) # for tables\nlibrary(kableExtra) # for scrolling tables\n\n\n\nAttaching package: 'kableExtra'\n\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n\n\nCode\nlibrary(data.table) # for efficient handling of large dataframes\n\n\n\nAttaching package: 'data.table'\n\nThe following objects are masked from 'package:lubridate':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\nThe following object is masked from 'package:purrr':\n\n    transpose\n\n\nCode\n# making ggplot more powerful\n\nlibrary(MetBrewer) # for colour palettes based upon artwork housed at the MET\nlibrary(MoMAColors) # for colour palettes based upon artwork housed at MoMA\n\n\nRegistered S3 method overwritten by 'MoMAColors':\n  method        from     \n  print.palette MetBrewer\n\n\nCode\nlibrary(wesanderson) # for colour palettes based on wes anderson movies\n\n\nRegistered S3 method overwritten by 'wesanderson':\n  method        from      \n  print.palette MoMAColors\n\n\nCode\nlibrary(rcartocolor) # for nice sequential colour schemes\nlibrary(PNWColors) # for colour palettes \nlibrary(tidybayes) # for plotting distributions\nlibrary(stickylabeller) # labelling facets with strings in ggplot\nlibrary(geomtextpath) # for curved plot annotations\nlibrary(ggtext) # for markdown syntax in plot labels\nlibrary(patchwork) # for patching plots together\nlibrary(ggnewscale) # to reset scales in plots, allowing multiple fill arguments in ggplot"
  },
  {
    "objectID": "new_sim.html#build-convenience-functions",
    "href": "new_sim.html#build-convenience-functions",
    "title": "Untitled",
    "section": "Build convenience functions",
    "text": "Build convenience functions\n\nA sampling function that can handle vectors of length one\n\n\n\nCode\n# so we can sample from vectors with length 1 without this being interpreted as an integer\nsample_vec &lt;- function(x, ...) x[sample(length(x), ...)] \n\n\n\nA function that build the appropriate inheritance system.\n\n\n\nCode\nmake_mating_table &lt;- function(gene_location){\n  \n  make_offspring &lt;- function(X, Y, offspring_genotype, zygote_freq, sex){\n    data.frame(Female_genotype = X,\n           Male_genotype = Y,\n           offspring_genotype,\n           zygote_freq,\n           sex)\n  }\n  \n  # Specify the possible offspring genotypes for all the potential crosses; we use these for the offspring_genotype argument in the make_offspring function\n  \n  # offspring genotypes\n  \n  offspring_genotypes_1 &lt;- c(2,2)\n  offspring_genotypes_2 &lt;- c(1, 1, 2, 2)\n  offspring_genotypes_3 &lt;- c(1, 1)\n  offspring_genotypes_4 &lt;- c(0, 0, 1, 1, 2, 2)\n  offspring_genotypes_5 &lt;- c(0, 0, 1, 1)\n  offspring_genotypes_6 &lt;- c(0, 0)\n  \n  offspring_genotypes_7 &lt;- c(1, 2)\n  offspring_genotypes_8 &lt;- c(0, 1, 1, 2)\n  offspring_genotypes_9 &lt;- c(0, 1)\n  offspring_genotypes_10 &lt;- c(1, 0) # this is diff from above bc of the order with the sexes\n  offspring_genotypes_11 &lt;- c(2, 1)\n  offspring_genotypes_12 &lt;- c(2,1,1,0)\n  \n  # offspring sex\n  \n  offspring_sex_2 &lt;- c(0, 1)\n  offspring_sex_4 &lt;- c(0, 1, 0, 1)\n  offspring_sex_6 &lt;- c(0, 1, 0, 1, 0, 1)\n  \n  # even frequency of two offspring genotypes\n  \n  freq_2 &lt;- rep(0.5, 2)\n  \n  # even frequency between four offspring types\n  \n  freq_4 &lt;- rep(0.25, 4)\n  \n  # when there are 6 offspring genotypes\n  \n  freq_6 &lt;- c(0.125, 0.125,\n              0.25, 0.25,\n              0.125, 0.125)\n  \n  if(gene_location == \"A\"){\n    books &lt;- rbind(\n        make_offspring(2, 2, offspring_genotypes_1, freq_2, offspring_sex_2),\n        make_offspring(2, 1, offspring_genotypes_2, freq_4, offspring_sex_4),\n        make_offspring(2, 0, offspring_genotypes_3, freq_2, offspring_sex_2),\n        make_offspring(1, 2, offspring_genotypes_2, freq_4, offspring_sex_4),\n        make_offspring(1, 1, offspring_genotypes_4, freq_6, offspring_sex_6),\n        make_offspring(1, 0, offspring_genotypes_5, freq_4, offspring_sex_4),\n        make_offspring(0, 2, offspring_genotypes_3, freq_2, offspring_sex_2),\n        make_offspring(0, 1, offspring_genotypes_5, freq_4, offspring_sex_4),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"X\"){\n    books &lt;- rbind(\n        make_offspring(2, 1, offspring_genotypes_7, freq_2, offspring_sex_2),\n        make_offspring(2, 0, offspring_genotypes_3, freq_2, offspring_sex_2),\n        make_offspring(1, 1, offspring_genotypes_8, freq_4, offspring_sex_4),\n        make_offspring(1, 0, offspring_genotypes_5, freq_4, offspring_sex_4),\n        make_offspring(0, 1, offspring_genotypes_9, freq_2, offspring_sex_2),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"Y\"){\n    books &lt;- rbind(\n        make_offspring(0, 1, offspring_genotypes_10, freq_2, offspring_sex_2),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"Z\"){\n    books &lt;- rbind(\n        make_offspring(1, 2, offspring_genotypes_11, freq_2, offspring_sex_2),\n        make_offspring(0, 2, offspring_genotypes_3, freq_2, offspring_sex_2),\n        make_offspring(1, 1, offspring_genotypes_12, freq_4, offspring_sex_4),\n        make_offspring(0, 1, offspring_genotypes_5, freq_4, offspring_sex_4),\n        make_offspring(1, 0, offspring_genotypes_10, freq_2, offspring_sex_2),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"W\"){\n    books &lt;- rbind(\n        make_offspring(1, 0, offspring_genotypes_9, freq_2, offspring_sex_2),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"C\"){\n    books &lt;- rbind(\n      make_offspring(1, 0, offspring_genotypes_3, freq_2, offspring_sex_2),\n      make_offspring(1, 1, offspring_genotypes_3, freq_2, offspring_sex_2),\n      make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2),\n      make_offspring(0, 1, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"P\"){\n    books &lt;- rbind(\n      make_offspring(1, 0, offspring_genotypes_6, freq_2, offspring_sex_2),\n      make_offspring(1, 1, offspring_genotypes_3, freq_2, offspring_sex_2),\n      make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2),\n      make_offspring(0, 1, offspring_genotypes_3, freq_2, offspring_sex_2)\n    )\n  }\n    return(books)  \n}\n\n\noffspring_genotypes_autosome &lt;- make_mating_table(\"A\")\noffspring_genotypes_X &lt;- make_mating_table(\"X\")\noffspring_genotypes_Y &lt;- make_mating_table(\"Y\")\noffspring_genotypes_Z &lt;- make_mating_table(\"Z\")\noffspring_genotypes_W &lt;- make_mating_table(\"W\")\noffspring_genotypes_C &lt;- make_mating_table(\"C\")\noffspring_genotypes_P &lt;- make_mating_table(\"P\")\n\n\n\nA function that takes two parental genotypes and produces offspring\n\n\n\nCode\nsample_mating_table &lt;- function(inheritance_scheme, \n                                f,\n                                mother){\n  \n  # cut to possible genotypes\n  possibilities &lt;- \n    inheritance_scheme[inheritance_scheme$Female_genotype == mother[4] &\n                         inheritance_scheme$Male_genotype == mother[9], c(3,5)]\n  # get prob of producing each genotype\n  probs &lt;- \n    inheritance_scheme[inheritance_scheme$Female_genotype == mother[4] &\n                         inheritance_scheme$Male_genotype == mother[9], 4]\n  # sample\n  possibilities[sample(size = f,\n                       x = nrow(possibilities), \n                       prob = probs,\n                       replace = TRUE), ]\n}"
  },
  {
    "objectID": "new_sim.html#load-the-parameter-space",
    "href": "new_sim.html#load-the-parameter-space",
    "title": "Untitled",
    "section": "Load the parameter space",
    "text": "Load the parameter space\n\n\nCode\nresolution &lt;- 25\nstarting_pop_size_autosomes &lt;- 2000 # both sexes harbour two copies of each autosomal chromosome = 1000 autosomal haplotypes\n\nparameters &lt;-\n  expand_grid(\n    chromosome = c(\"A\", \"X\", \"Y\", \"Z\", \"W\", \"C\", \"P\"),\n    v = c(8, 80),\n    D = seq(0, -0.99, length = resolution), # inbreeding depression\n    refractory_period_prop_cohort_alive = seq(0.01, 1, length = resolution)\n  ) %&gt;% \n  full_join(tibble(chromosome = c(\"A\", \"A\", \"A\", \"A\", \"A\", \"A\",\n                                  \"X\", \"X\", \"X\", \"X\",\n                                  \"Y\",\n                                  \"Z\", \"Z\", \"Z\", \"Z\",\n                                  \"W\",\n                                  \"C\", \"C\",\n                                  \"P\", \"P\"),\n                   sex_expressed = c(0, 0, 0, 1, 1, 1,\n                                     0, 1, 1, 1,\n                                     0,\n                                     0, 0, 0, 1,\n                                     1,\n                                     0, 1,\n                                     0, 1),\n                   dominance = c(0, 0.5, 1, 0, 0.5, 1,\n                                 1, 0, 0.5, 1, \n                                 1, \n                                 0, 0.5, 1, 1,\n                                 1,\n                                 1, 1,\n                                 1, 1)) %&gt;% \n              mutate(Starting_pop_size = case_when(chromosome == \"A\" ~ starting_pop_size_autosomes,\n                                                   chromosome == \"X\" | chromosome == \"Z\" ~ \n                                                     starting_pop_size_autosomes / 0.75,\n                                                   chromosome == \"Y\" | chromosome == \"W\" ~ starting_pop_size_autosomes*4,\n                                                   chromosome == \"C\" | chromosome == \"P\" ~ starting_pop_size_autosomes*2)),\n            relationship = \"many-to-many\", by = \"chromosome\") %&gt;% \n  mutate(baseline_mean_lifespan = 1,\n         v = v / (Starting_pop_size / 2),\n         f = 5, \n         refractory_period = -log(refractory_period_prop_cohort_alive),\n         mutation_time = 5, # this is when the mutation can be introduced from\n         time_end = 1000, # with avg lifespan = 1, this is ~ roughly 1000 gens\n         parameter_space_ID = row_number(),\n         mutation_events = 5)\n\nparameters_autosome &lt;- parameters %&gt;% filter(chromosome == \"A\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_X &lt;- parameters %&gt;% filter(chromosome == \"X\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Y &lt;- parameters %&gt;% filter(chromosome == \"Y\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Z &lt;- parameters %&gt;% filter(chromosome == \"Z\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_W &lt;- parameters %&gt;% filter(chromosome == \"W\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_C &lt;- parameters %&gt;% filter(chromosome == \"C\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_P &lt;- parameters %&gt;% filter(chromosome == \"P\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\n\nif(!file.exists(\"parameters/parameters_autosome.txt\")){\n  parameters_autosome %&gt;% write.table(\"parameters/parameters_autosome.txt\")\n  parameters_X %&gt;% write.table(\"parameters/parameters_X.txt\")\n  parameters_Y %&gt;% write.table(\"parameters/parameters_Y.txt\")\n  parameters_Z %&gt;% write.table(\"parameters/parameters_Z.txt\")\n  parameters_W %&gt;% write.table(\"parameters/parameters_W.txt\")\n  parameters_C %&gt;% write.table(\"parameters/parameters_C.txt\")\n  parameters_P %&gt;% write.table(\"parameters/parameters_P.txt\")\n}"
  },
  {
    "objectID": "new_sim.html#the-simulation",
    "href": "new_sim.html#the-simulation",
    "title": "Untitled",
    "section": "The simulation",
    "text": "The simulation\n\n\nCode\ncontinuous_time_simulation &lt;- function(row,\n                                       parameters,\n                                       inheritance_scheme){\n  \n  #print(paste(\"Doing row\", row)) # this shows which row in the parameter space is being modelled\n  \n  Starting_pop_size &lt;- round(parameters$Starting_pop_size[row], 0)\n  f &lt;- parameters$f[row] # fecundity constant\n  mutation_time &lt;- parameters$mutation_time[row] # introduce an I allele after family structure is established\n  baseline_mean_lifespan &lt;- parameters$baseline_mean_lifespan[row] # constant at 1\n  time_end &lt;- parameters$time_end[row] # a cut-off point for each run \n  sex_expressed &lt;- parameters$sex_expressed[row]\n  chromosome &lt;- parameters$chromosome[row]\n  v &lt;- parameters$v[row]\n  refractory_period &lt;- parameters$refractory_period[row]\n  D &lt;- parameters$D[row]\n  dominance &lt;- parameters$dominance[row]\n  parameter_space_ID &lt;- parameters$parameter_space_ID[row]\n  mutation_events &lt;- parameters$mutation_events[row]\n  \n  # Set the number of breeding sites\n  \n  breeding_sites &lt;- round(0.2*Starting_pop_size, 0)\n  \n  # what inheritance system does this run follow\n  offspring_genotypes &lt;- inheritance_scheme\n  \n  # Set the maximum number of I alleles that can be found in each sex\n  if(chromosome == \"A\"){\n    female_max_I &lt;- 2\n    male_max_I &lt;- 2\n  }\n  \n  if(chromosome == \"X\"){\n    female_max_I &lt;- 2\n    male_max_I &lt;- 1\n  }\n  \n  if(chromosome == \"Z\"){\n    female_max_I &lt;- 1\n    male_max_I &lt;- 2\n  }\n  \n  if(chromosome == \"Y\"){\n    female_max_I &lt;- 0\n    male_max_I &lt;- 1\n  }\n  \n  if(chromosome == \"W\"){\n    female_max_I &lt;- 1\n    male_max_I &lt;- 0\n  }\n  \n  if(chromosome == \"C\" | chromosome == \"P\"){\n    female_max_I &lt;- 1\n    male_max_I &lt;- 1\n  }\n  \n  # make matrix to hold results; updated as sim progresses\n  # col1 = time, col2 = prop I, col3 = pop size, col4 = prop virgin female deaths\n  results_matrix &lt;- matrix(nrow = time_end*4+2, ncol = 4) # record each time point\n  \n  # make matrix to hold population; updated as sim progresses\n  \n  # col1 = ID \n  # col2 = Family ID\n  # col3 = Sex: females = 1 and males = 0\n  # col4 = Genotype: 0, 1 and 2 = copies of inbreeding allele\n  # col5 = mortality rate\n  # col6 = encountered relative: NA = NO, 1 = YES\n  # col7 = mating state: -Inf not in pop, NA = unmated, real = out, Inf = mated female\n  # col8 = inbred mating: NA = NO, 1 = YES (only matters for females)\n  # col9 = mated_genotype: NA = unmated, otherwise 0,1,2 (see mating table)\n  # col10 = breeding site:  NA = NO, 1 = YES \n  # col11 = no. matings (only matters for males)\n  # col12 = offspring produced: NA = NO, 1 = YES\n  \n  pop_matrix &lt;- matrix(nrow = Starting_pop_size*2, # pop expands with initial repro pulse\n                       ncol = 12)\n  # ID & Family ID\n  pop_matrix[1:Starting_pop_size, 1:2] &lt;- 1:Starting_pop_size\n  # assign sex\n  pop_matrix[1:Starting_pop_size, 3] &lt;- rbinom(n = Starting_pop_size, 1, prob = 0.5)\n  # female_starting_genotype\n  pop_matrix[pop_matrix[,3] &lt; 1 & !is.na(pop_matrix[,3]), 4] &lt;- 0\n  # male_starting_genotype\n  pop_matrix[pop_matrix[,3] &gt; 0 & !is.na(pop_matrix[,3]), 4] &lt;- 0\n  # assign mortality rates\n  pop_matrix[1:Starting_pop_size, 5] &lt;- 1/baseline_mean_lifespan\n  # set the unused rows to state -Inf \n  pop_matrix[(Starting_pop_size + 1):nrow(pop_matrix), 7] &lt;- -Inf\n  # mate count\n  pop_matrix[1:Starting_pop_size, 11] &lt;- 0\n  # offspring production status\n  pop_matrix[1:Starting_pop_size, 12] &lt;- NA\n  # populate breeding sites\n  # the starting no. of females generally exceeds the number of breeding sites, which is starting_pop_size/f. The code below selects the initial breeding site holders\n  \n  if(nrow(pop_matrix[pop_matrix[,3] &gt; 0 & !is.na(pop_matrix[,3]),]) &gt; breeding_sites){\n    \n    initial_breeders &lt;- head(pop_matrix[pop_matrix[,3] &gt; 0 & !is.na(pop_matrix[,3]),1], breeding_sites)\n    \n    pop_matrix[initial_breeders,10] &lt;- 1 # take advantage of ID = row number for initial pop\n    \n  } else{pop_matrix[pop_matrix[,3] &gt; 0 & !is.na(pop_matrix[,3]), 10] &lt;- 1}\n  \n  # Initialise counter for the results table\n  \n  next_update &lt;- 0 # keep track of when to update the results\n  next_row &lt;- 0 # keep track of which row to update\n  \n  # Initialise the Individual_ID and Family_ID counters\n  \n  Individual_ID_counter &lt;- Starting_pop_size\n  \n  Family_ID_counter &lt;- Starting_pop_size # each individual descends from a distinct family at onset\n  \n  # Initialise the timer t\n  \n  t &lt;- 0\n  \n  # Set initial pop size and freq of I allele for results table\n  \n  Prop_I &lt;- 0 \n  pop_size &lt;- Starting_pop_size\n  total_female_deaths &lt;- 0\n  mated_female_deaths &lt;- 0\n  \n  # Start population without the I allele to generate family structure\n  # Flips to 1 at mutant intro time point \n  \n  mutant_introduced &lt;- 0\n  \n  keep_going &lt;- TRUE # if the inbreeding allele fixes or goes extinct, this will change to false and the while loop will quit early\n  \n  # With the initial population ready to go, start the timer and let the simulation run.\n  \n  while(t &lt;= time_end & keep_going){\n    \n    print(paste0(\"Population size = \", pop_size, \n                 \", breeders = \", sum(pop_matrix[,10], na.rm = T), \n                 \", time = \", round(t, 3), \", Prop I =\", Prop_I, \", mutation events =\", mutant_introduced))\n    \n    # find next event \n    \n    # next death: this is the sum of the mortality rates for all individuals in the population\n    \n    next_death &lt;- t + rexp(n = 1, rate = sum(pop_matrix[, 5], na.rm = T))\n    \n    # next receptive mating encounter\n    \n    # find no. of females in mating pool & separate by encounter experience\n    \n    receptive_females_first_encounter &lt;- \n      pop_matrix[pop_matrix[,3] &gt; 0 &\n                   is.na(pop_matrix[,6]) &\n                   is.na(pop_matrix[,7]),, drop = FALSE]\n    \n    receptive_females_second_encounter &lt;- \n      pop_matrix[pop_matrix[,3] &gt; 0 &\n                   !is.na(pop_matrix[,6]) &\n                   is.na(pop_matrix[,7]),, drop = FALSE]\n    \n    # find no. of males in mating pool\n    receptive_males &lt;- pop_matrix[pop_matrix[,3] &lt; 1 & is.na(pop_matrix[,7]),, drop = FALSE]\n    \n    # Find the time the next encounter occurs: plug the sum of the rates into the exponential function. \n    # The population level encounter rate is the product of the rate at which a single male finds a single female, the number of receptive females in the population, and the number of receptive males in the population\n    \n    next_first_encounter &lt;- t + \n      rexp(n = 1, rate = v*nrow(receptive_females_first_encounter)*nrow(receptive_males))\n    \n    next_secondary_encounter &lt;- t + \n      rexp(n = 1, rate = v*nrow(receptive_females_second_encounter)*nrow(receptive_males))\n    \n    # time in - Inf, Inf and Na are possible options that the code can handle \n    next_time_in &lt;- min(pop_matrix[is.finite(pop_matrix[,7]),7])\n    \n    # find which event happens next and update t\n    t &lt;- pmin(next_death,\n              next_time_in, \n              next_first_encounter,\n              next_secondary_encounter,\n              next_update, # update the population\n              na.rm = TRUE) # ... if a rate is 0, NaN produced.\n    \n    \n    if(t == next_update & !is.na(next_update)){# record time, I prop and pop size\n      results_matrix[next_row+1,1] &lt;- t\n      results_matrix[next_row+1,2] &lt;- round(Prop_I, 4)\n      results_matrix[next_row+1,3] &lt;- pop_size # popsize\n      results_matrix[next_row+1,4] &lt;- round(mated_female_deaths / total_female_deaths, 3)\n      next_update &lt;- next_update + 0.25\n      next_row &lt;- next_row + 1\n      total_female_deaths &lt;- 0 # reset the count\n      mated_female_deaths &lt;- 0 # reset the count\n    }\n    \n    \n    if(t == next_death){# remove an individual from the pop\n      who_died &lt;- \n        sample_vec(size = 1, # choose one\n                   x = pop_matrix[!is.na(pop_matrix[,1]),1], # subset to current pop\n                   prob = pop_matrix[!is.na(pop_matrix[,5]),5]) # weight by mortality rate\n      # add a death if it was a female\n      if(nrow(pop_matrix[pop_matrix[,1] == who_died &\n                   !is.na(pop_matrix[,1]) &\n                   pop_matrix[,3] &gt; 0,, drop = FALSE]) &gt; 0){total_female_deaths &lt;- total_female_deaths + 1}\n      \n      # add virgin female deaths\n      if(nrow(pop_matrix[pop_matrix[,1] == who_died &\n                   !is.na(pop_matrix[,1]) &\n                   pop_matrix[,3] &gt; 0 &\n                   is.infinite(pop_matrix[,7]),, drop = FALSE]) &gt; 0){mated_female_deaths &lt;- mated_female_deaths + 1}\n      \n      # remove individual from pop matrix\n      pop_matrix[pop_matrix[,1] == who_died, 7] &lt;- -Inf # NA means time-in here, so special edit required\n      pop_matrix[pop_matrix[,1] == who_died, c(1:6, 8:12)] &lt;- NA \n      \n      # re-order to make steps like adding offspring easier later on\n      pop_matrix &lt;- pop_matrix[order(pop_matrix[,1]),]\n      \n    }\n    \n    # check if there are free breeding sites and whether females are available to fill them \n    \n    current_breeders &lt;- sum(pop_matrix[, 10], na.rm = T)\n    \n    # get list of IDs for floating females\n    floating_females &lt;- pop_matrix[!is.na(pop_matrix[,1]) & # alive\n                                     pop_matrix[,3] &gt; 0 & # female\n                                     is.na(pop_matrix[,10]), # non-breeding\n                                   1] # return the IDs only\n    \n    # If so, recruit a new breeder\n    # All prospective females have equal probability\n    \n    if(current_breeders &lt; breeding_sites & length(floating_females) &gt; 0){\n      \n      # assign the new breeder\n      \n      new_breeder &lt;- \n        sample_vec(size = 1, # choose one\n                   x = floating_females) # subset to floaters\n      \n      pop_matrix[pop_matrix[,1] == new_breeder, 10] &lt;- 1\n    }\n    \n    if(t == next_time_in & !is.na(next_time_in)){ # a male re-enters the mating pool\n      pop_matrix[pop_matrix[,7] == next_time_in, 7] &lt;- NA # change to receptive\n    }\n    \n    #### mating\n    \n    if(t == next_first_encounter &\n       !is.na(next_first_encounter)){# does first encounter lead to (inbred) mating?\n      \n      # Determine whether a heterozygote inbreeds on this occasion. \n      # Depends on genotype if this matters\n      heterozygote_inbreeds &lt;- rbinom(1, 1, prob = dominance)\n      \n      # which female\n      female_ID &lt;- sample_vec(receptive_females_first_encounter[,1], 1)\n      # get meta-data\n      female &lt;- subset(pop_matrix, pop_matrix[,1] == female_ID)\n      # how many inbreeding alleles does she carry?\n      alleles_female &lt;- female[,4]\n      \n      mates &lt;- NULL # reset this every time as a safeguard - MAYBE REMOVE?\n      \n      # find brothers that are in the mating pool\n      brothers &lt;-\n        pop_matrix[pop_matrix[,2] == female[, 2] & # find family members\n                     pop_matrix[,3] &lt; 1 & # that are male\n                     is.na(pop_matrix[,7]) & # and in the mating pool\n                     !is.na(pop_matrix[,1]), # remove NAs\n                   1] \n      # find the specific brother - if there aren't any, inbreeding does not happen\n      if(length(brothers) &gt; 0){# choose brother randomly\n        chosen_brother &lt;-\n          subset(pop_matrix, \n                 pop_matrix[,1] == sample_vec(size = 1, x = brothers))\n        # how many inbreeding alleles does he carry?\n        alleles_brother &lt;- chosen_brother[,4]\n        brother_ID &lt;- chosen_brother[,1]\n      }else{alleles_brother &lt;- 0} # we need this for the next if statement\n      \n      # now determine whether inbreeding occurs:\n      # which individual expresses the allele\n      # does that individual have the allele\n      # is it expressed (depends on genomic region, no. copies and dominance)\n      \n      if(# female expression determines outcome\n        # dominance doesn't matter\n        length(brothers) &gt; 0 & sex_expressed &gt; 0 & female_max_I == alleles_female |\n        # dominance matters\n        length(brothers) &gt; 0 & sex_expressed &gt; 0 & \n        0 &lt; alleles_female & alleles_female &lt; female_max_I & heterozygote_inbreeds &gt; 0 |\n        # male expression determines outcome\n        # dominance doesn't matter\n        length(brothers) &gt; 0 & sex_expressed &lt; 1 & male_max_I == alleles_brother |\n        # dominance matters\n        length(brothers) &gt; 0 & sex_expressed &lt; 1 & \n        0 &lt; alleles_brother & alleles_brother &lt; male_max_I & heterozygote_inbreeds &gt; 0){\n        \n        # do inbreeding\n        # update the pop matrix\n        # female\n        pop_matrix[pop_matrix[,1] == female_ID, 6] &lt;- 1 # relative has been encountered\n        pop_matrix[pop_matrix[,1] == female_ID, 7] &lt;- Inf # female leaves mating pool\n        pop_matrix[pop_matrix[,1] == female_ID, 8] &lt;- 1 # inbreeding occurs\n        pop_matrix[pop_matrix[,1] == female_ID, 9] &lt;- alleles_brother # mates genotype\n        \n        # male\n        pop_matrix[pop_matrix[,1] == brother_ID, 7] &lt;- t + refractory_period # male leaves mating pool\n        pop_matrix[pop_matrix[,1] == brother_ID, 8] &lt;- 1 # inbreeding occurs\n        pop_matrix[pop_matrix[,1] == brother_ID & !is.na(pop_matrix[,1]), 11] &lt;-\n          pop_matrix[pop_matrix[,1] == brother_ID & !is.na(pop_matrix[,1]), 11] + 1\n      } else{\n        # inbreeding is avoided\n        # females that had no receptive brother to encounter are recorded as having had their chance for inbreeding early in life. When the male refractory period != 0, this is possible but unlikely (because all siblings are produced at the same time). Most commonly, this will occur when a female produces an all-female brood (0.03125 probability when f=5)\n        \n        pop_matrix[pop_matrix[,1] == female_ID, 6] &lt;- 1 # relative has been encountered\n      }\n    }\n    \n    if(t == next_secondary_encounter &\n       !is.na(next_secondary_encounter)){ \n      # If the individual has already encountered a sibling, don't swap and let encounter proceed. \n      \n      # which female\n      female_ID &lt;- sample_vec(receptive_females_second_encounter[,1], 1)\n      # get meta-data\n      female &lt;- subset(pop_matrix, pop_matrix[,1] == female_ID)\n      # how many inbreeding alleles does she carry?\n      alleles_female &lt;- female[,4]  \n      \n      # which male\n      male_ID &lt;- sample_vec(receptive_males[,1], 1)\n      # get meta-data\n      male &lt;- subset(pop_matrix, pop_matrix[,1] == male_ID)\n      # how many inbreeding alleles does he carry?\n      alleles_male &lt;- male[,4] \n      \n      # If the pair happen to be siblings, check if they inbreed  \n      \n      # Determine whether a heterozygote inbreeds on this occasion. \n      # Depends on genotype if this matters\n      heterozygote_inbreeds &lt;- rbinom(1, 1, prob = dominance)\n      \n      if(\n        # female expression determines outcome\n        # dominance doesn't matter\n        female[,2] == male[,2] & sex_expressed &gt; 0 & female_max_I == alleles_female |\n        # dominance matters\n        female[,2] == male[,2] & sex_expressed &gt; 0 & \n        0 &lt; alleles_female & alleles_female &lt; female_max_I & heterozygote_inbreeds &gt; 0 |\n        # male expression determines outcome\n        # dominance doesn't matter\n        female[,2] == male[,2] & sex_expressed &lt; 1 & male_max_I == alleles_male |\n        # dominance matters\n        female[,2] == male[,2] & sex_expressed &lt; 1 & \n        0 &lt; alleles_male & alleles_male &lt; male_max_I & heterozygote_inbreeds &gt; 0){\n        \n        # do inbreeding\n        # update the pop matrix\n        # female\n        pop_matrix[pop_matrix[,1] == female_ID, 7] &lt;- Inf # female leaves mating pool\n        pop_matrix[pop_matrix[,1] == female_ID, 8] &lt;- 1 # inbreeding occurs\n        pop_matrix[pop_matrix[,1] == female_ID, 9] &lt;- alleles_male # mates genotype\n        \n        # male\n        pop_matrix[pop_matrix[,1] == male_ID, 7] &lt;- t + refractory_period # male leaves mating pool\n        pop_matrix[pop_matrix[,1] == male_ID & !is.na(pop_matrix[,1]), 11] &lt;-\n          pop_matrix[pop_matrix[,1] == male_ID & !is.na(pop_matrix[,1]), 11] + 1\n      } else{\n        # do outbreeding\n        # update the pop matrix\n        # female\n        pop_matrix[pop_matrix[,1] == female_ID, 7] &lt;- Inf # female leaves mating pool\n        pop_matrix[pop_matrix[,1] == female_ID, 9] &lt;- alleles_male # mates genotype\n        \n        # male\n        pop_matrix[pop_matrix[,1] == male_ID, 7] &lt;- t + refractory_period # male leaves mating pool\n        pop_matrix[pop_matrix[,1] == male_ID & !is.na(pop_matrix[,1]), 11] &lt;-\n          pop_matrix[pop_matrix[,1] == male_ID & !is.na(pop_matrix[,1]), 11] + 1\n      }\n    }\n    \n    # Consequences of death and mating: reproduction\n    \n    # check if a female can now produce offspring, either because they're previously mated and have secured a breeding site or because they already hold a breeding site and have now mated\n    # make sure that previous breeders are excluded\n    \n    new_mated_breeder &lt;- pop_matrix[is.infinite(pop_matrix[,7]) & # mated\n                                      !is.na(pop_matrix[,10]) & # holds breeding site\n                                      is.na(pop_matrix[,12]),, drop = FALSE] # hasn't reproduced\n    \n    if(nrow(new_mated_breeder) &gt; 0){\n      # add offspring to the population\n      # each mated female that holds a breeding site produces f offspring\n      \n      # first check whether the mutant I allele should be added\n      if(mutant_introduced &lt; mutation_events & t &gt; mutation_time){\n        which_sex &lt;- rbinom(1, 1, prob = 0.5)\n        \n        if(chromosome == \"A\" & which_sex == 1 |\n           chromosome == \"X\" & which_sex == 1 |\n           chromosome == \"Z\" & which_sex == 1){\n          new_mated_breeder[4] &lt;- 1\n        }\n        \n        if(chromosome == \"A\" & which_sex == 0 |\n           chromosome == \"X\" & which_sex == 0 |\n           chromosome == \"Z\" & which_sex == 0){\n          new_mated_breeder[9] &lt;- 1\n        }\n        \n        if(chromosome == \"W\"|\n           chromosome == \"C\"){\n          new_mated_breeder[4] &lt;- 1\n        }\n        \n        if(chromosome == \"Y\" |\n           chromosome == \"P\"){\n          new_mated_breeder[9] &lt;- 1\n        }\n        \n        mutant_introduced &lt;- mutant_introduced + 1\n      }\n      \n      next_row_to_fill &lt;- length(pop_matrix[!is.na(pop_matrix[,1]),1]) + 1\n      last_row_to_fill &lt;- next_row_to_fill + f - 1\n      next_ID &lt;- Individual_ID_counter + 1\n      last_ID &lt;- Individual_ID_counter + f\n      Family_ID_counter &lt;- Family_ID_counter + 1\n      \n      # assign IDs\n      pop_matrix[next_row_to_fill:last_row_to_fill, 1] &lt;- next_ID:last_ID\n      # assign all offspring to a single family\n      pop_matrix[next_row_to_fill:last_row_to_fill, 2] &lt;- Family_ID_counter\n      # assign sex and genotype using our mating table sampling function\n      offspring_genos &lt;- \n        sample_mating_table(inheritance_scheme,\n                            f, \n                            mother = new_mated_breeder)\n      pop_matrix[next_row_to_fill:last_row_to_fill, 3] &lt;- offspring_genos[,2]\n      pop_matrix[next_row_to_fill:last_row_to_fill, 4] &lt;- offspring_genos[,1]\n      # assign mortality rates\n      if(is.na(new_mated_breeder[8])){\n        pop_matrix[next_row_to_fill:last_row_to_fill, 5] &lt;- 1/baseline_mean_lifespan\n      } else{ # apply effect of inbreeding depression\n        pop_matrix[next_row_to_fill:last_row_to_fill, 5] &lt;- 1/(baseline_mean_lifespan + D)\n      }\n      # fill in the mating and breeding site details - everyone starts as a floating virgin\n      pop_matrix[next_row_to_fill:last_row_to_fill, 6:10] &lt;- NA\n      # mate count\n      pop_matrix[next_row_to_fill:last_row_to_fill, 11] &lt;- 0\n      \n      \n      # update the mothers offspring production status\n      \n      pop_matrix[pop_matrix[,1] == new_mated_breeder[1], 12] &lt;- 1\n      \n      # update the individual ID counter (redundant but more readable to do this here)\n      Individual_ID_counter &lt;- last_ID\n      \n    }      \n    \n    # Calculate the frequency of the I allele, quit early if I fixes or goes extinct\n    \n    pop_size &lt;- nrow(pop_matrix[!is.na(pop_matrix[,1]),, drop = FALSE]) # use this to update the results\n    n_females &lt;- nrow(pop_matrix[!is.na(pop_matrix[,1]) &\n                                   pop_matrix[,3] &gt; 0,, drop = FALSE])\n    n_males &lt;- pop_size - n_females\n    \n    # calc allele freq if autosomal locus   \n    if(chromosome == \"A\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/(pop_size*2) # x2 because diploid\n    }\n    \n    # calc allele freq if W locus   \n    if(chromosome == \"W\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/n_females\n    }\n    \n    # calc allele freq if Y locus   \n    if(chromosome == \"Y\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/n_males \n    }\n    \n    # calc allele freq if X locus   \n    if(chromosome == \"X\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/(n_females*2 + n_males)\n    }\n    \n    # calc allele freq if Z locus   \n    if(chromosome == \"Z\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/(n_females + n_males*2) \n    }\n    \n    # calc allele freq if C locus   \n    if(chromosome == \"C\" |\n       chromosome == \"P\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/pop_size \n    }\n    \n    # quit condition\n    if(mutant_introduced &gt; 0 & Prop_I &gt; 0.9 |\n       mutant_introduced &gt; 0 & Prop_I == 0 | \n       pop_size &lt; 2){keep_going &lt;- FALSE}\n    \n  }\n  \n  results_matrix[next_row+1,1] &lt;- t\n  results_matrix[next_row+1,2] &lt;- round(Prop_I, 4)\n  results_matrix[next_row+1,3] &lt;- pop_size\n  results_matrix[next_row+1,4] &lt;- round(mated_female_deaths / total_female_deaths, 3)\n  results_matrix &lt;- results_matrix[-(next_row+2:nrow(results_matrix)),]\n  # save results as a csv.  \n  \n  results_matrix\n  \n  write.csv(results_matrix,\n            paste(\"results/rowID_\", \n                  parameter_space_ID, \n                  chromosome, \".csv\", \n                  sep = \"\"))\n  #write.csv(results_matrix,\n    #        paste(\"sim_results/rowID_\", \n      #            parameter_space_ID, \n        #          chromosome, \".csv\", \n          #        sep = \"\"))\n}"
  },
  {
    "objectID": "new_sim.html#run-the-simulation",
    "href": "new_sim.html#run-the-simulation",
    "title": "Untitled",
    "section": "Run the simulation",
    "text": "Run the simulation\nIn practice, I ran the simulations on JGU’s Mogon computing cluster. See the HPC_inbreeding_script.R and the batch script run_inbreeding_sim. To run the simulation for a single parameter space, you could run continuous_time_simulation(1, parameters_P, offspring_genotypes_P)"
  },
  {
    "objectID": "new_sim.html#load-the-results",
    "href": "new_sim.html#load-the-results",
    "title": "Untitled",
    "section": "Load the results",
    "text": "Load the results\n\n\nCode\n# build a function to load the individual runs and join them into a single tibble\n\nfiles &lt;-\n    list.files(path = \"sim_results\") %&gt;% \n    str_subset(\"P\") # change this to load the desired files\n\nresults_reader &lt;- function(x){\n  read_csv(paste0(\"sim_results/\", x)) %&gt;% \n    mutate(parameter_space_ID = x)\n}\n\nif(!file.exists(\"results/autosome_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"A.csv\"))) %&gt;% \n    left_join(parameters_autosome, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/autosome_results.csv\")\n}else{\n  autosome_results &lt;- read_delim(\"results/autosome_results.csv\")\n}\n\n\nRows: 942739 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): chromosome\ndbl (17): time, I_prop, pop_size, prop_mated, parameter_space_ID, v, D, refr...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\nif(!file.exists(\"results/X_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"X.csv\"))) %&gt;% \n    left_join(parameters_X, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/X_results.csv\")\n}else{\n  X_results &lt;- read_delim(\"results/X_results.csv\")\n}\n\n\nRows: 558146 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): chromosome\ndbl (17): time, I_prop, pop_size, prop_mated, parameter_space_ID, v, D, refr...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\nif(!file.exists(\"results/Y_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"Y.csv\"))) %&gt;% \n    left_join(parameters_Y, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/Y_results.csv\")\n}else{\n  Y_results &lt;- read_delim(\"results/Y_results.csv\")\n}\n\n\nRows: 137860 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): chromosome\ndbl (17): time, I_prop, pop_size, prop_mated, parameter_space_ID, v, D, refr...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\nif(!file.exists(\"results/Z_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"Z.csv\"))) %&gt;% \n    left_join(parameters_Z, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/Z_results.csv\")\n}else{\n  Z_results &lt;- read_delim(\"results/Z_results.csv\")\n}\n\n\nRows: 667000 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): chromosome\ndbl (17): time, I_prop, pop_size, prop_mated, parameter_space_ID, v, D, refr...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\nif(!file.exists(\"results/W_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"W.csv\"))) %&gt;% \n    left_join(parameters_W, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/W_results.csv\")\n}else{\n  W_results &lt;- read_delim(\"results/W_results.csv\")\n}\n\n\nRows: 76272 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): chromosome\ndbl (17): time, I_prop, pop_size, prop_mated, parameter_space_ID, v, D, refr...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\nif(!file.exists(\"results/C_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"C.csv\"))) %&gt;% \n    left_join(parameters_C, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/C_results.csv\")\n}else{\n  C_results &lt;- read_delim(\"results/C_results.csv\")\n}\n\n\nRows: 167601 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): chromosome\ndbl (17): time, I_prop, pop_size, prop_mated, parameter_space_ID, v, D, refr...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\nif(!file.exists(\"results/P_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"P.csv\"))) %&gt;% \n    left_join(parameters_P, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/P_results.csv\")\n}else{\n  P_results &lt;- read_delim(\"results/P_results.csv\")\n}\n\n\nRows: 286093 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): chromosome\ndbl (17): time, I_prop, pop_size, prop_mated, parameter_space_ID, v, D, refr...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The evolutionary conflicts of inbreeding",
    "section": "",
    "text": "Code\n# for tidy style coding and plotting\n\nlibrary(tidyverse) \nlibrary(vroom) # to read lots of csv files at once\n\n# more table options\n\nlibrary(pander) # for tables\nlibrary(kableExtra) # for scrolling tables\nlibrary(data.table) # for efficient handling of large dataframes\n\n# making ggplot more powerful\n\nlibrary(MetBrewer) # for colour palettes based upon artwork housed at the MET\nlibrary(MoMAColors) # for colour palettes based upon artwork housed at MoMA\nlibrary(wesanderson) # for colour palettes based on wes anderson movies\nlibrary(rcartocolor) # for nice sequential colour schemes\nlibrary(PNWColors) # for colour palettes \nlibrary(tidybayes) # for plotting distributions\nlibrary(stickylabeller) # labelling facets with strings in ggplot\nlibrary(geomtextpath) # for curved plot annotations\nlibrary(ggtext) # for markdown syntax in plot labels\nlibrary(patchwork) # for patching plots together\nlibrary(ggnewscale) # to reset scales in plots, allowing multiple fill arguments in ggplot\n\n# for computation speed checks\n\nlibrary(profvis) # breakdown of complex functions\nlibrary(bench) # individual functions"
  },
  {
    "objectID": "index.html#build-convenience-functions",
    "href": "index.html#build-convenience-functions",
    "title": "The evolutionary conflicts of inbreeding",
    "section": "Build convenience functions",
    "text": "Build convenience functions\n\nA sampling function that can handle vectors of length one\n\n\n\nCode\n# so we can sample from vectors with length 1 without this being interpreted as an integer\nsample_vec &lt;- function(x, ...) x[sample(length(x), ...)] \n\n\n\nA function that builds the appropriate inheritance system.\n\n\n\nCode\nmake_mating_table &lt;- function(gene_location){\n  \n  make_offspring &lt;- function(X, Y, offspring_genotype, zygote_freq, sex){\n    data.frame(Female_genotype = X,\n           Male_genotype = Y,\n           offspring_genotype,\n           zygote_freq,\n           sex)\n  }\n  \n  # Specify the possible offspring genotypes for all the potential crosses; we use these for the offspring_genotype argument in the make_offspring function\n  \n  # offspring genotypes\n  \n  offspring_genotypes_1 &lt;- c(2,2)\n  offspring_genotypes_2 &lt;- c(1, 1, 2, 2)\n  offspring_genotypes_3 &lt;- c(1, 1)\n  offspring_genotypes_4 &lt;- c(0, 0, 1, 1, 2, 2)\n  offspring_genotypes_5 &lt;- c(0, 0, 1, 1)\n  offspring_genotypes_6 &lt;- c(0, 0)\n  \n  offspring_genotypes_7 &lt;- c(1, 2)\n  offspring_genotypes_8 &lt;- c(0, 1, 1, 2)\n  offspring_genotypes_9 &lt;- c(0, 1)\n  offspring_genotypes_10 &lt;- c(1, 0) # this is diff from above bc of the order with the sexes\n  offspring_genotypes_11 &lt;- c(2, 1)\n  offspring_genotypes_12 &lt;- c(2,1,1,0)\n  \n  # offspring sex\n  \n  offspring_sex_2 &lt;- c(0, 1)\n  offspring_sex_4 &lt;- c(0, 1, 0, 1)\n  offspring_sex_6 &lt;- c(0, 1, 0, 1, 0, 1)\n  \n  # even frequency of two offspring genotypes\n  \n  freq_2 &lt;- rep(0.5, 2)\n  \n  # even frequency between four offspring types\n  \n  freq_4 &lt;- rep(0.25, 4)\n  \n  # when there are 6 offspring genotypes\n  \n  freq_6 &lt;- c(0.125, 0.125,\n              0.25, 0.25,\n              0.125, 0.125)\n  \n  if(gene_location == \"A\"){\n    books &lt;- rbind(\n        make_offspring(2, 2, offspring_genotypes_1, freq_2, offspring_sex_2),\n        make_offspring(2, 1, offspring_genotypes_2, freq_4, offspring_sex_4),\n        make_offspring(2, 0, offspring_genotypes_3, freq_2, offspring_sex_2),\n        make_offspring(1, 2, offspring_genotypes_2, freq_4, offspring_sex_4),\n        make_offspring(1, 1, offspring_genotypes_4, freq_6, offspring_sex_6),\n        make_offspring(1, 0, offspring_genotypes_5, freq_4, offspring_sex_4),\n        make_offspring(0, 2, offspring_genotypes_3, freq_2, offspring_sex_2),\n        make_offspring(0, 1, offspring_genotypes_5, freq_4, offspring_sex_4),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"X\"){\n    books &lt;- rbind(\n        make_offspring(2, 1, offspring_genotypes_7, freq_2, offspring_sex_2),\n        make_offspring(2, 0, offspring_genotypes_3, freq_2, offspring_sex_2),\n        make_offspring(1, 1, offspring_genotypes_8, freq_4, offspring_sex_4),\n        make_offspring(1, 0, offspring_genotypes_5, freq_4, offspring_sex_4),\n        make_offspring(0, 1, offspring_genotypes_9, freq_2, offspring_sex_2),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"Y\"){\n    books &lt;- rbind(\n        make_offspring(0, 1, offspring_genotypes_10, freq_2, offspring_sex_2),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"Z\"){\n    books &lt;- rbind(\n        make_offspring(1, 2, offspring_genotypes_11, freq_2, offspring_sex_2),\n        make_offspring(0, 2, offspring_genotypes_3, freq_2, offspring_sex_2),\n        make_offspring(1, 1, offspring_genotypes_12, freq_4, offspring_sex_4),\n        make_offspring(0, 1, offspring_genotypes_5, freq_4, offspring_sex_4),\n        make_offspring(1, 0, offspring_genotypes_10, freq_2, offspring_sex_2),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"W\"){\n    books &lt;- rbind(\n        make_offspring(1, 0, offspring_genotypes_9, freq_2, offspring_sex_2),\n        make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"C\"){\n    books &lt;- rbind(\n      make_offspring(1, 0, offspring_genotypes_3, freq_2, offspring_sex_2),\n      make_offspring(1, 1, offspring_genotypes_3, freq_2, offspring_sex_2),\n      make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2),\n      make_offspring(0, 1, offspring_genotypes_6, freq_2, offspring_sex_2)\n    )\n  }\n  \n  if(gene_location == \"P\"){\n    books &lt;- rbind(\n      make_offspring(1, 0, offspring_genotypes_6, freq_2, offspring_sex_2),\n      make_offspring(1, 1, offspring_genotypes_3, freq_2, offspring_sex_2),\n      make_offspring(0, 0, offspring_genotypes_6, freq_2, offspring_sex_2),\n      make_offspring(0, 1, offspring_genotypes_3, freq_2, offspring_sex_2)\n    )\n  }\n    return(books)  \n}\n\n\noffspring_genotypes_autosome &lt;- make_mating_table(\"A\")\noffspring_genotypes_X &lt;- make_mating_table(\"X\")\noffspring_genotypes_Y &lt;- make_mating_table(\"Y\")\noffspring_genotypes_Z &lt;- make_mating_table(\"Z\")\noffspring_genotypes_W &lt;- make_mating_table(\"W\")\noffspring_genotypes_C &lt;- make_mating_table(\"C\")\noffspring_genotypes_P &lt;- make_mating_table(\"P\")\n\n\n\nA function that takes two parental genotypes and produces offspring\n\n\n\nCode\nsample_mating_table &lt;- function(inheritance_scheme, \n                                f,\n                                mother){\n  \n  # cut to possible genotypes\n  possibilities &lt;- \n    inheritance_scheme[inheritance_scheme$Female_genotype == mother[4] &\n                         inheritance_scheme$Male_genotype == mother[9], c(3,5)]\n  # get prob of producing each genotype\n  probs &lt;- \n    inheritance_scheme[inheritance_scheme$Female_genotype == mother[4] &\n                         inheritance_scheme$Male_genotype == mother[9], 4]\n  # sample\n  possibilities[sample(size = f,\n                       x = nrow(possibilities), \n                       prob = probs,\n                       replace = TRUE), ]\n}"
  },
  {
    "objectID": "index.html#load-the-parameter-space",
    "href": "index.html#load-the-parameter-space",
    "title": "The evolutionary conflicts of inbreeding",
    "section": "Load the parameter space",
    "text": "Load the parameter space\n\n\nCode\nresolution &lt;- 25\nstarting_pop_size_autosomes &lt;- 2000 # both sexes harbour two copies of each autosomal chromosome = 1000 autosomal haplotypes\n\nparameters &lt;-\n  expand_grid(\n    chromosome = c(\"A\", \"X\", \"Y\", \"Z\", \"W\", \"C\", \"P\"),\n    v = c(8, 80),\n    D = seq(0, -0.99, length = resolution), # inbreeding depression\n    refractory_period_prop_cohort_alive = seq(0.01, 1, length = resolution)\n  ) %&gt;% \n  full_join(tibble(chromosome = c(\"A\", \"A\", \"A\", \"A\", \"A\", \"A\",\n                                  \"X\", \"X\", \"X\", \"X\",\n                                  \"Y\",\n                                  \"Z\", \"Z\", \"Z\", \"Z\",\n                                  \"W\",\n                                  \"C\", \"C\",\n                                  \"P\", \"P\"),\n                   sex_expressed = c(0, 0, 0, 1, 1, 1,\n                                     0, 1, 1, 1,\n                                     0,\n                                     0, 0, 0, 1,\n                                     1,\n                                     0, 1,\n                                     0, 1),\n                   dominance = c(0, 0.5, 1, 0, 0.5, 1,\n                                 1, 0, 0.5, 1, \n                                 1, \n                                 0, 0.5, 1, 1,\n                                 1,\n                                 1, 1,\n                                 1, 1)) %&gt;% \n              mutate(Starting_pop_size = case_when(chromosome == \"A\" ~ starting_pop_size_autosomes,\n                                                   chromosome == \"X\" | chromosome == \"Z\" ~ \n                                                     starting_pop_size_autosomes / 0.75,\n                                                   chromosome == \"Y\" | chromosome == \"W\" ~ starting_pop_size_autosomes*4,\n                                                   chromosome == \"C\" | chromosome == \"P\" ~ starting_pop_size_autosomes*2)),\n            relationship = \"many-to-many\", by = \"chromosome\") %&gt;% \n  mutate(baseline_mean_lifespan = 1,\n         v = v / (Starting_pop_size / 2),\n         f = 5, \n         refractory_period = -log(refractory_period_prop_cohort_alive),\n         mutation_time = 5, # this is when the mutation can be introduced from\n         time_end = 1000, # with avg lifespan = 1, this is ~ roughly 1000 gens\n         parameter_space_ID = row_number(),\n         mutation_events = 5)\n\nparameters_autosome &lt;- parameters %&gt;% filter(chromosome == \"A\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_X &lt;- parameters %&gt;% filter(chromosome == \"X\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Y &lt;- parameters %&gt;% filter(chromosome == \"Y\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_Z &lt;- parameters %&gt;% filter(chromosome == \"Z\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_W &lt;- parameters %&gt;% filter(chromosome == \"W\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_C &lt;- parameters %&gt;% filter(chromosome == \"C\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\nparameters_P &lt;- parameters %&gt;% filter(chromosome == \"P\") %&gt;% slice_sample(prop = 1) # shuffle to equalise workload across jobs\n\nif(!file.exists(\"parameters/parameters_autosome.txt\")){\n  parameters_autosome %&gt;% write.table(\"parameters/parameters_autosome.txt\")\n  parameters_X %&gt;% write.table(\"parameters/parameters_X.txt\")\n  parameters_Y %&gt;% write.table(\"parameters/parameters_Y.txt\")\n  parameters_Z %&gt;% write.table(\"parameters/parameters_Z.txt\")\n  parameters_W %&gt;% write.table(\"parameters/parameters_W.txt\")\n  parameters_C %&gt;% write.table(\"parameters/parameters_C.txt\")\n  parameters_P %&gt;% write.table(\"parameters/parameters_P.txt\")\n}"
  },
  {
    "objectID": "index.html#the-simulation-function",
    "href": "index.html#the-simulation-function",
    "title": "The evolutionary conflicts of inbreeding",
    "section": "The simulation function",
    "text": "The simulation function\n\n\nCode\ncontinuous_time_simulation &lt;- function(row,\n                                       parameters,\n                                       inheritance_scheme){\n  \n  #print(paste(\"Doing row\", row)) # this shows which row in the parameter space is being modelled\n  \n  Starting_pop_size &lt;- round(parameters$Starting_pop_size[row], 0)\n  f &lt;- parameters$f[row] # fecundity constant\n  mutation_time &lt;- parameters$mutation_time[row] # introduce an I allele after family structure is established\n  baseline_mean_lifespan &lt;- parameters$baseline_mean_lifespan[row] # constant at 1\n  time_end &lt;- parameters$time_end[row] # a cut-off point for each run \n  sex_expressed &lt;- parameters$sex_expressed[row]\n  chromosome &lt;- parameters$chromosome[row]\n  v &lt;- parameters$v[row]\n  refractory_period &lt;- parameters$refractory_period[row]\n  D &lt;- parameters$D[row]\n  dominance &lt;- parameters$dominance[row]\n  parameter_space_ID &lt;- parameters$parameter_space_ID[row]\n  mutation_events &lt;- parameters$mutation_events[row]\n  \n  # Set the number of breeding sites\n  \n  breeding_sites &lt;- round(0.2*Starting_pop_size, 0)\n  \n  # what inheritance system does this run follow\n  offspring_genotypes &lt;- inheritance_scheme\n  \n  # Set the maximum number of I alleles that can be found in each sex\n  if(chromosome == \"A\"){\n    female_max_I &lt;- 2\n    male_max_I &lt;- 2\n  }\n  \n  if(chromosome == \"X\"){\n    female_max_I &lt;- 2\n    male_max_I &lt;- 1\n  }\n  \n  if(chromosome == \"Z\"){\n    female_max_I &lt;- 1\n    male_max_I &lt;- 2\n  }\n  \n  if(chromosome == \"Y\"){\n    female_max_I &lt;- 0\n    male_max_I &lt;- 1\n  }\n  \n  if(chromosome == \"W\"){\n    female_max_I &lt;- 1\n    male_max_I &lt;- 0\n  }\n  \n  if(chromosome == \"C\" | chromosome == \"P\"){\n    female_max_I &lt;- 1\n    male_max_I &lt;- 1\n  }\n  \n  # make matrix to hold results; updated as sim progresses\n  # col1 = time, col2 = prop I, col3 = pop size, col4 = prop virgin female deaths\n  results_matrix &lt;- matrix(nrow = time_end*4+2, ncol = 4) # record each time point\n  \n  # make matrix to hold population; updated as sim progresses\n  \n  # col1 = ID \n  # col2 = Family ID\n  # col3 = Sex: females = 1 and males = 0\n  # col4 = Genotype: 0, 1 and 2 = copies of inbreeding allele\n  # col5 = mortality rate\n  # col6 = encountered relative: NA = NO, 1 = YES\n  # col7 = mating state: -Inf not in pop, NA = unmated, real = out, Inf = mated female\n  # col8 = inbred mating: NA = NO, 1 = YES (only matters for females)\n  # col9 = mated_genotype: NA = unmated, otherwise 0,1,2 (see mating table)\n  # col10 = breeding site:  NA = NO, 1 = YES \n  # col11 = no. matings (only matters for males)\n  # col12 = offspring produced: NA = NO, 1 = YES\n  \n  pop_matrix &lt;- matrix(nrow = Starting_pop_size*2, # pop expands with initial repro pulse\n                       ncol = 12)\n  # ID & Family ID\n  pop_matrix[1:Starting_pop_size, 1:2] &lt;- 1:Starting_pop_size\n  # assign sex\n  pop_matrix[1:Starting_pop_size, 3] &lt;- rbinom(n = Starting_pop_size, 1, prob = 0.5)\n  # female_starting_genotype\n  pop_matrix[pop_matrix[,3] &lt; 1 & !is.na(pop_matrix[,3]), 4] &lt;- 0\n  # male_starting_genotype\n  pop_matrix[pop_matrix[,3] &gt; 0 & !is.na(pop_matrix[,3]), 4] &lt;- 0\n  # assign mortality rates\n  pop_matrix[1:Starting_pop_size, 5] &lt;- 1/baseline_mean_lifespan\n  # set the unused rows to state -Inf \n  pop_matrix[(Starting_pop_size + 1):nrow(pop_matrix), 7] &lt;- -Inf\n  # mate count\n  pop_matrix[1:Starting_pop_size, 11] &lt;- 0\n  # offspring production status\n  pop_matrix[1:Starting_pop_size, 12] &lt;- NA\n  # populate breeding sites\n  # the starting no. of females generally exceeds the number of breeding sites, which is starting_pop_size/f. The code below selects the initial breeding site holders\n  \n  if(nrow(pop_matrix[pop_matrix[,3] &gt; 0 & !is.na(pop_matrix[,3]),]) &gt; breeding_sites){\n    \n    initial_breeders &lt;- head(pop_matrix[pop_matrix[,3] &gt; 0 & !is.na(pop_matrix[,3]),1], breeding_sites)\n    \n    pop_matrix[initial_breeders,10] &lt;- 1 # take advantage of ID = row number for initial pop\n    \n  } else{pop_matrix[pop_matrix[,3] &gt; 0 & !is.na(pop_matrix[,3]), 10] &lt;- 1}\n  \n  # Initialise counter for the results table\n  \n  next_update &lt;- 0 # keep track of when to update the results\n  next_row &lt;- 0 # keep track of which row to update\n  \n  # Initialise the Individual_ID and Family_ID counters\n  \n  Individual_ID_counter &lt;- Starting_pop_size\n  \n  Family_ID_counter &lt;- Starting_pop_size # each individual descends from a distinct family at onset\n  \n  # Initialise the timer t\n  \n  t &lt;- 0\n  \n  # Set initial pop size and freq of I allele for results table\n  \n  Prop_I &lt;- 0 \n  pop_size &lt;- Starting_pop_size\n  total_female_deaths &lt;- 0\n  mated_female_deaths &lt;- 0\n  \n  # Start population without the I allele to generate family structure\n  # Flips to 1 at mutant intro time point \n  \n  mutant_introduced &lt;- 0\n  \n  keep_going &lt;- TRUE # if the inbreeding allele fixes or goes extinct, this will change to false and the while loop will quit early\n  \n  # With the initial population ready to go, start the timer and let the simulation run.\n  \n  while(t &lt;= time_end & keep_going){\n    \n    print(paste0(\"Population size = \", pop_size, \n                 \", breeders = \", sum(pop_matrix[,10], na.rm = T), \n                 \", time = \", round(t, 3), \", Prop I =\", Prop_I, \", mutation events =\", mutant_introduced))\n    \n    # find next event \n    \n    # next death: this is the sum of the mortality rates for all individuals in the population\n    \n    next_death &lt;- t + rexp(n = 1, rate = sum(pop_matrix[, 5], na.rm = T))\n    \n    # next receptive mating encounter\n    \n    # find no. of females in mating pool & separate by encounter experience\n    \n    receptive_females_first_encounter &lt;- \n      pop_matrix[pop_matrix[,3] &gt; 0 &\n                   is.na(pop_matrix[,6]) &\n                   is.na(pop_matrix[,7]),, drop = FALSE]\n    \n    receptive_females_second_encounter &lt;- \n      pop_matrix[pop_matrix[,3] &gt; 0 &\n                   !is.na(pop_matrix[,6]) &\n                   is.na(pop_matrix[,7]),, drop = FALSE]\n    \n    # find no. of males in mating pool\n    receptive_males &lt;- pop_matrix[pop_matrix[,3] &lt; 1 & is.na(pop_matrix[,7]),, drop = FALSE]\n    \n    # Find the time the next encounter occurs: plug the sum of the rates into the exponential function. \n    # The population level encounter rate is the product of the rate at which a single male finds a single female, the number of receptive females in the population, and the number of receptive males in the population\n    \n    next_first_encounter &lt;- t + \n      rexp(n = 1, rate = v*nrow(receptive_females_first_encounter)*nrow(receptive_males))\n    \n    next_secondary_encounter &lt;- t + \n      rexp(n = 1, rate = v*nrow(receptive_females_second_encounter)*nrow(receptive_males))\n    \n    # time in - Inf, Inf and Na are possible options that the code can handle \n    next_time_in &lt;- min(pop_matrix[is.finite(pop_matrix[,7]),7])\n    \n    # find which event happens next and update t\n    t &lt;- pmin(next_death,\n              next_time_in, \n              next_first_encounter,\n              next_secondary_encounter,\n              next_update, # update the population\n              na.rm = TRUE) # ... if a rate is 0, NaN produced.\n    \n    \n    if(t == next_update & !is.na(next_update)){# record time, I prop and pop size\n      results_matrix[next_row+1,1] &lt;- t\n      results_matrix[next_row+1,2] &lt;- round(Prop_I, 4)\n      results_matrix[next_row+1,3] &lt;- pop_size # popsize\n      results_matrix[next_row+1,4] &lt;- round(mated_female_deaths / total_female_deaths, 3)\n      next_update &lt;- next_update + 0.25\n      next_row &lt;- next_row + 1\n      total_female_deaths &lt;- 0 # reset the count\n      mated_female_deaths &lt;- 0 # reset the count\n    }\n    \n    \n    if(t == next_death){# remove an individual from the pop\n      who_died &lt;- \n        sample_vec(size = 1, # choose one\n                   x = pop_matrix[!is.na(pop_matrix[,1]),1], # subset to current pop\n                   prob = pop_matrix[!is.na(pop_matrix[,5]),5]) # weight by mortality rate\n      # add a death if it was a female\n      if(nrow(pop_matrix[pop_matrix[,1] == who_died &\n                   !is.na(pop_matrix[,1]) &\n                   pop_matrix[,3] &gt; 0,, drop = FALSE]) &gt; 0){total_female_deaths &lt;- total_female_deaths + 1}\n      \n      # add virgin female deaths\n      if(nrow(pop_matrix[pop_matrix[,1] == who_died &\n                   !is.na(pop_matrix[,1]) &\n                   pop_matrix[,3] &gt; 0 &\n                   is.infinite(pop_matrix[,7]),, drop = FALSE]) &gt; 0){mated_female_deaths &lt;- mated_female_deaths + 1}\n      \n      # remove individual from pop matrix\n      pop_matrix[pop_matrix[,1] == who_died, 7] &lt;- -Inf # NA means time-in here, so special edit required\n      pop_matrix[pop_matrix[,1] == who_died, c(1:6, 8:12)] &lt;- NA \n      \n      # re-order to make steps like adding offspring easier later on\n      pop_matrix &lt;- pop_matrix[order(pop_matrix[,1]),]\n      \n    }\n    \n    # check if there are free breeding sites and whether females are available to fill them \n    \n    current_breeders &lt;- sum(pop_matrix[, 10], na.rm = T)\n    \n    # get list of IDs for floating females\n    floating_females &lt;- pop_matrix[!is.na(pop_matrix[,1]) & # alive\n                                     pop_matrix[,3] &gt; 0 & # female\n                                     is.na(pop_matrix[,10]), # non-breeding\n                                   1] # return the IDs only\n    \n    # If so, recruit a new breeder\n    # All prospective females have equal probability\n    \n    if(current_breeders &lt; breeding_sites & length(floating_females) &gt; 0){\n      \n      # assign the new breeder\n      \n      new_breeder &lt;- \n        sample_vec(size = 1, # choose one\n                   x = floating_females) # subset to floaters\n      \n      pop_matrix[pop_matrix[,1] == new_breeder, 10] &lt;- 1\n    }\n    \n    if(t == next_time_in & !is.na(next_time_in)){ # a male re-enters the mating pool\n      pop_matrix[pop_matrix[,7] == next_time_in, 7] &lt;- NA # change to receptive\n    }\n    \n    #### mating\n    \n    if(t == next_first_encounter &\n       !is.na(next_first_encounter)){# does first encounter lead to (inbred) mating?\n      \n      # Determine whether a heterozygote inbreeds on this occasion. \n      # Depends on genotype if this matters\n      heterozygote_inbreeds &lt;- rbinom(1, 1, prob = dominance)\n      \n      # which female\n      female_ID &lt;- sample_vec(receptive_females_first_encounter[,1], 1)\n      # get meta-data\n      female &lt;- subset(pop_matrix, pop_matrix[,1] == female_ID)\n      # how many inbreeding alleles does she carry?\n      alleles_female &lt;- female[,4]\n      \n      mates &lt;- NULL # reset this every time as a safeguard - MAYBE REMOVE?\n      \n      # find brothers that are in the mating pool\n      brothers &lt;-\n        pop_matrix[pop_matrix[,2] == female[, 2] & # find family members\n                     pop_matrix[,3] &lt; 1 & # that are male\n                     is.na(pop_matrix[,7]) & # and in the mating pool\n                     !is.na(pop_matrix[,1]), # remove NAs\n                   1] \n      # find the specific brother - if there aren't any, inbreeding does not happen\n      if(length(brothers) &gt; 0){# choose brother randomly\n        chosen_brother &lt;-\n          subset(pop_matrix, \n                 pop_matrix[,1] == sample_vec(size = 1, x = brothers))\n        # how many inbreeding alleles does he carry?\n        alleles_brother &lt;- chosen_brother[,4]\n        brother_ID &lt;- chosen_brother[,1]\n      }else{alleles_brother &lt;- 0} # we need this for the next if statement\n      \n      # now determine whether inbreeding occurs:\n      # which individual expresses the allele\n      # does that individual have the allele\n      # is it expressed (depends on genomic region, no. copies and dominance)\n      \n      if(# female expression determines outcome\n        # dominance doesn't matter\n        length(brothers) &gt; 0 & sex_expressed &gt; 0 & female_max_I == alleles_female |\n        # dominance matters\n        length(brothers) &gt; 0 & sex_expressed &gt; 0 & \n        0 &lt; alleles_female & alleles_female &lt; female_max_I & heterozygote_inbreeds &gt; 0 |\n        # male expression determines outcome\n        # dominance doesn't matter\n        length(brothers) &gt; 0 & sex_expressed &lt; 1 & male_max_I == alleles_brother |\n        # dominance matters\n        length(brothers) &gt; 0 & sex_expressed &lt; 1 & \n        0 &lt; alleles_brother & alleles_brother &lt; male_max_I & heterozygote_inbreeds &gt; 0){\n        \n        # do inbreeding\n        # update the pop matrix\n        # female\n        pop_matrix[pop_matrix[,1] == female_ID, 6] &lt;- 1 # relative has been encountered\n        pop_matrix[pop_matrix[,1] == female_ID, 7] &lt;- Inf # female leaves mating pool\n        pop_matrix[pop_matrix[,1] == female_ID, 8] &lt;- 1 # inbreeding occurs\n        pop_matrix[pop_matrix[,1] == female_ID, 9] &lt;- alleles_brother # mates genotype\n        \n        # male\n        pop_matrix[pop_matrix[,1] == brother_ID, 7] &lt;- t + refractory_period # male leaves mating pool\n        pop_matrix[pop_matrix[,1] == brother_ID, 8] &lt;- 1 # inbreeding occurs\n        pop_matrix[pop_matrix[,1] == brother_ID & !is.na(pop_matrix[,1]), 11] &lt;-\n          pop_matrix[pop_matrix[,1] == brother_ID & !is.na(pop_matrix[,1]), 11] + 1\n      } else{\n        # inbreeding is avoided\n        # females that had no receptive brother to encounter are recorded as having had their chance for inbreeding early in life. When the male refractory period != 0, this is possible but unlikely (because all siblings are produced at the same time). Most commonly, this will occur when a female produces an all-female brood (0.03125 probability when f=5)\n        \n        pop_matrix[pop_matrix[,1] == female_ID, 6] &lt;- 1 # relative has been encountered\n      }\n    }\n    \n    if(t == next_secondary_encounter &\n       !is.na(next_secondary_encounter)){ \n      # If the individual has already encountered a sibling, don't swap and let encounter proceed. \n      \n      # which female\n      female_ID &lt;- sample_vec(receptive_females_second_encounter[,1], 1)\n      # get meta-data\n      female &lt;- subset(pop_matrix, pop_matrix[,1] == female_ID)\n      # how many inbreeding alleles does she carry?\n      alleles_female &lt;- female[,4]  \n      \n      # which male\n      male_ID &lt;- sample_vec(receptive_males[,1], 1)\n      # get meta-data\n      male &lt;- subset(pop_matrix, pop_matrix[,1] == male_ID)\n      # how many inbreeding alleles does he carry?\n      alleles_male &lt;- male[,4] \n      \n      # If the pair happen to be siblings, check if they inbreed  \n      \n      # Determine whether a heterozygote inbreeds on this occasion. \n      # Depends on genotype if this matters\n      heterozygote_inbreeds &lt;- rbinom(1, 1, prob = dominance)\n      \n      if(\n        # female expression determines outcome\n        # dominance doesn't matter\n        female[,2] == male[,2] & sex_expressed &gt; 0 & female_max_I == alleles_female |\n        # dominance matters\n        female[,2] == male[,2] & sex_expressed &gt; 0 & \n        0 &lt; alleles_female & alleles_female &lt; female_max_I & heterozygote_inbreeds &gt; 0 |\n        # male expression determines outcome\n        # dominance doesn't matter\n        female[,2] == male[,2] & sex_expressed &lt; 1 & male_max_I == alleles_male |\n        # dominance matters\n        female[,2] == male[,2] & sex_expressed &lt; 1 & \n        0 &lt; alleles_male & alleles_male &lt; male_max_I & heterozygote_inbreeds &gt; 0){\n        \n        # do inbreeding\n        # update the pop matrix\n        # female\n        pop_matrix[pop_matrix[,1] == female_ID, 7] &lt;- Inf # female leaves mating pool\n        pop_matrix[pop_matrix[,1] == female_ID, 8] &lt;- 1 # inbreeding occurs\n        pop_matrix[pop_matrix[,1] == female_ID, 9] &lt;- alleles_male # mates genotype\n        \n        # male\n        pop_matrix[pop_matrix[,1] == male_ID, 7] &lt;- t + refractory_period # male leaves mating pool\n        pop_matrix[pop_matrix[,1] == male_ID & !is.na(pop_matrix[,1]), 11] &lt;-\n          pop_matrix[pop_matrix[,1] == male_ID & !is.na(pop_matrix[,1]), 11] + 1\n      } else{\n        # do outbreeding\n        # update the pop matrix\n        # female\n        pop_matrix[pop_matrix[,1] == female_ID, 7] &lt;- Inf # female leaves mating pool\n        pop_matrix[pop_matrix[,1] == female_ID, 9] &lt;- alleles_male # mates genotype\n        \n        # male\n        pop_matrix[pop_matrix[,1] == male_ID, 7] &lt;- t + refractory_period # male leaves mating pool\n        pop_matrix[pop_matrix[,1] == male_ID & !is.na(pop_matrix[,1]), 11] &lt;-\n          pop_matrix[pop_matrix[,1] == male_ID & !is.na(pop_matrix[,1]), 11] + 1\n      }\n    }\n    \n    # Consequences of death and mating: reproduction\n    \n    # check if a female can now produce offspring, either because they're previously mated and have secured a breeding site or because they already hold a breeding site and have now mated\n    # make sure that previous breeders are excluded\n    \n    new_mated_breeder &lt;- pop_matrix[is.infinite(pop_matrix[,7]) & # mated\n                                      !is.na(pop_matrix[,10]) & # holds breeding site\n                                      is.na(pop_matrix[,12]),, drop = FALSE] # hasn't reproduced\n    \n    if(nrow(new_mated_breeder) &gt; 0){\n      # add offspring to the population\n      # each mated female that holds a breeding site produces f offspring\n      \n      # first check whether the mutant I allele should be added\n      if(mutant_introduced &lt; mutation_events & t &gt; mutation_time){\n        which_sex &lt;- rbinom(1, 1, prob = 0.5)\n        \n        if(chromosome == \"A\" & which_sex == 1 |\n           chromosome == \"X\" & which_sex == 1 |\n           chromosome == \"Z\" & which_sex == 1){\n          new_mated_breeder[4] &lt;- 1\n        }\n        \n        if(chromosome == \"A\" & which_sex == 0 |\n           chromosome == \"X\" & which_sex == 0 |\n           chromosome == \"Z\" & which_sex == 0){\n          new_mated_breeder[9] &lt;- 1\n        }\n        \n        if(chromosome == \"W\"|\n           chromosome == \"C\"){\n          new_mated_breeder[4] &lt;- 1\n        }\n        \n        if(chromosome == \"Y\" |\n           chromosome == \"P\"){\n          new_mated_breeder[9] &lt;- 1\n        }\n        \n        mutant_introduced &lt;- mutant_introduced + 1\n      }\n      \n      next_row_to_fill &lt;- length(pop_matrix[!is.na(pop_matrix[,1]),1]) + 1\n      last_row_to_fill &lt;- next_row_to_fill + f - 1\n      next_ID &lt;- Individual_ID_counter + 1\n      last_ID &lt;- Individual_ID_counter + f\n      Family_ID_counter &lt;- Family_ID_counter + 1\n      \n      # assign IDs\n      pop_matrix[next_row_to_fill:last_row_to_fill, 1] &lt;- next_ID:last_ID\n      # assign all offspring to a single family\n      pop_matrix[next_row_to_fill:last_row_to_fill, 2] &lt;- Family_ID_counter\n      # assign sex and genotype using our mating table sampling function\n      offspring_genos &lt;- \n        sample_mating_table(inheritance_scheme,\n                            f, \n                            mother = new_mated_breeder)\n      pop_matrix[next_row_to_fill:last_row_to_fill, 3] &lt;- offspring_genos[,2]\n      pop_matrix[next_row_to_fill:last_row_to_fill, 4] &lt;- offspring_genos[,1]\n      # assign mortality rates\n      if(is.na(new_mated_breeder[8])){\n        pop_matrix[next_row_to_fill:last_row_to_fill, 5] &lt;- 1/baseline_mean_lifespan\n      } else{ # apply effect of inbreeding depression\n        pop_matrix[next_row_to_fill:last_row_to_fill, 5] &lt;- 1/(baseline_mean_lifespan + D)\n      }\n      # fill in the mating and breeding site details - everyone starts as a floating virgin\n      pop_matrix[next_row_to_fill:last_row_to_fill, 6:10] &lt;- NA\n      # mate count\n      pop_matrix[next_row_to_fill:last_row_to_fill, 11] &lt;- 0\n      \n      \n      # update the mothers offspring production status\n      \n      pop_matrix[pop_matrix[,1] == new_mated_breeder[1], 12] &lt;- 1\n      \n      # update the individual ID counter (redundant but more readable to do this here)\n      Individual_ID_counter &lt;- last_ID\n      \n    }      \n    \n    # Calculate the frequency of the I allele, quit early if I fixes or goes extinct\n    \n    pop_size &lt;- nrow(pop_matrix[!is.na(pop_matrix[,1]),, drop = FALSE]) # use this to update the results\n    n_females &lt;- nrow(pop_matrix[!is.na(pop_matrix[,1]) &\n                                   pop_matrix[,3] &gt; 0,, drop = FALSE])\n    n_males &lt;- pop_size - n_females\n    \n    # calc allele freq if autosomal locus   \n    if(chromosome == \"A\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/(pop_size*2) # x2 because diploid\n    }\n    \n    # calc allele freq if W locus   \n    if(chromosome == \"W\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/n_females\n    }\n    \n    # calc allele freq if Y locus   \n    if(chromosome == \"Y\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/n_males \n    }\n    \n    # calc allele freq if X locus   \n    if(chromosome == \"X\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/(n_females*2 + n_males)\n    }\n    \n    # calc allele freq if Z locus   \n    if(chromosome == \"Z\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/(n_females + n_males*2) \n    }\n    \n    # calc allele freq if C locus   \n    if(chromosome == \"C\" |\n       chromosome == \"P\"){\n      Prop_I &lt;-\n        sum(pop_matrix[,4], na.rm = T)/pop_size \n    }\n    \n    # quit condition\n    if(mutant_introduced &gt; 0 & Prop_I &gt; 0.9 |\n       mutant_introduced &gt; 0 & Prop_I == 0 | \n       pop_size &lt; 2){keep_going &lt;- FALSE}\n    \n  }\n  \n  results_matrix[next_row+1,1] &lt;- t\n  results_matrix[next_row+1,2] &lt;- round(Prop_I, 4)\n  results_matrix[next_row+1,3] &lt;- pop_size\n  results_matrix[next_row+1,4] &lt;- round(mated_female_deaths / total_female_deaths, 3)\n  results_matrix &lt;- results_matrix[-(next_row+2:nrow(results_matrix)),]\n  # save results as a csv.  \n  \n  results_matrix\n  \n  write.csv(results_matrix,\n            paste(\"results/rowID_\", \n                  parameter_space_ID, \n                  chromosome, \".csv\", \n                  sep = \"\"))\n  #write.csv(results_matrix,\n    #        paste(\"sim_results/rowID_\", \n      #            parameter_space_ID, \n        #          chromosome, \".csv\", \n          #        sep = \"\"))\n}"
  },
  {
    "objectID": "index.html#run-the-simulation",
    "href": "index.html#run-the-simulation",
    "title": "The evolutionary conflicts of inbreeding",
    "section": "Run the simulation",
    "text": "Run the simulation\nIn practice, I ran the simulations on JGU’s Mogon computing cluster. See the HPC_inbreeding_script.R and the batch script run_inbreeding_sim. To run the simulation for a single parameter space, you could run continuous_time_simulation(1, parameters_P, offspring_genotypes_P)"
  },
  {
    "objectID": "index.html#load-the-results",
    "href": "index.html#load-the-results",
    "title": "The evolutionary conflicts of inbreeding",
    "section": "Load the results",
    "text": "Load the results\n\n\nCode\n# build a function to load the individual runs and join them into a single tibble\n\nfiles &lt;-\n    list.files(path = \"sim_results\") %&gt;% \n    str_subset(\"P\") # change this to load the desired files\n\nresults_reader &lt;- function(x){\n  read_csv(paste0(\"sim_results/\", x)) %&gt;% \n    mutate(parameter_space_ID = x)\n}\n\nif(!file.exists(\"results/autosome_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"A.csv\"))) %&gt;% \n    left_join(parameters_autosome, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/autosome_results.csv\")\n}else{\n  autosome_results &lt;- read_delim(\"results/autosome_results.csv\")\n}\n\nif(!file.exists(\"results/X_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"X.csv\"))) %&gt;% \n    left_join(parameters_X, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/X_results.csv\")\n}else{\n  X_results &lt;- read_delim(\"results/X_results.csv\")\n}\n\nif(!file.exists(\"results/Y_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"Y.csv\"))) %&gt;% \n    left_join(parameters_Y, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/Y_results.csv\")\n}else{\n  Y_results &lt;- read_delim(\"results/Y_results.csv\")\n}\n\nif(!file.exists(\"results/Z_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"Z.csv\"))) %&gt;% \n    left_join(parameters_Z, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/Z_results.csv\")\n}else{\n  Z_results &lt;- read_delim(\"results/Z_results.csv\")\n}\n\nif(!file.exists(\"results/W_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"W.csv\"))) %&gt;% \n    left_join(parameters_W, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/W_results.csv\")\n}else{\n  W_results &lt;- read_delim(\"results/W_results.csv\")\n}\n\nif(!file.exists(\"results/C_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"C.csv\"))) %&gt;% \n    left_join(parameters_C, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/C_results.csv\")\n}else{\n  C_results &lt;- read_delim(\"results/C_results.csv\")\n}\n\nif(!file.exists(\"results/P_results.csv\")){\n  results &lt;- \n    map_dfr(files, results_reader) %&gt;% \n    rename(time = V1,\n           I_prop = V2,\n           pop_size = V3,\n           prop_mated = V4) %&gt;% \n    select(-`...1`) %&gt;% \n    mutate(parameter_space_ID = str_remove(parameter_space_ID, \"rowID_\"),\n           parameter_space_ID = as.integer(str_remove(parameter_space_ID, \"P.csv\"))) %&gt;% \n    left_join(parameters_P, by = \"parameter_space_ID\")\n  \n  write_csv(results, \"results/P_results.csv\")\n}else{\n  P_results &lt;- read_delim(\"results/P_results.csv\")\n}"
  },
  {
    "objectID": "Cuts/useful_cuts.html",
    "href": "Cuts/useful_cuts.html",
    "title": "useful_cuts",
    "section": "",
    "text": "Code\nlibrary(tidyverse) # for tidy style coding and plotting\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\nlibrary(pander) # for tables\nlibrary(kableExtra) # for scrolling tables\n\n\n\nAttaching package: 'kableExtra'\n\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n\n\nCode\nlibrary(MetBrewer) # for colour palettes based upon artwork housed at the MET\nlibrary(MoMAColors) # for colour palettes based upon artwork housed at MoMA\n\n\nRegistered S3 method overwritten by 'MoMAColors':\n  method        from     \n  print.palette MetBrewer\n\n\nCode\nlibrary(wesanderson) # for colour palettes based on wes anderson movies\n\n\nRegistered S3 method overwritten by 'wesanderson':\n  method        from      \n  print.palette MoMAColors\n\n\nCode\nlibrary(tidybayes) # for plotting distributions\nlibrary(stickylabeller) # labelling facets with strings in ggplot\nlibrary(patchwork) # for combining plots \nlibrary(geomtextpath) # for curved plot annotations\nlibrary(ggtext) # for markdown syntax in plot labels\nlibrary(patchwork) # for patching plots together\nlibrary(ggnewscale) # to reset scales in plots, allowing multiple fill arguments in ggplot\nlibrary(data.table) # for efficient handling of large dataframes\n\n\n\nAttaching package: 'data.table'\n\nThe following objects are masked from 'package:lubridate':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\nThe following object is masked from 'package:purrr':\n\n    transpose\n\n\nCode\nlibrary(dtplyr) # for tidyverse functions that can be used on data tables\nTo quantify conflict in its various forms we use a version of the I index presented in Innocenti and Morrow (2010):\n\\[I = \\frac{s_\\mathrm{i} s_\\mathrm{j}}{\\sqrt{\\frac{{s_\\mathrm{i}}^2 + {s_\\mathrm{j}}^2}{2}}}\\] where \\(s_\\mathrm{i}\\) and \\(s_\\mathrm{j}\\) are the selection coefficients that we calculate for inbreeding alleles in the \\(i^{th}\\) and \\(j^{th}\\) context, respectively. \\(I\\) is most extreme when selection is strong in both contexts, positive when selection is context concordant and negative when selection is antagonistic.\nBuild a function to make this calculation easy\nCode\nI_calculator &lt;- function(s_i, s_j){\n  s_i * s_j / sqrt(((s_i)^2 + (s_j)^2)/2)\n}\nCode\n# create the starting population\n\nset.seed(123)\n\ninitial_population &lt;- \n  tibble(Individual_ID = 1:10,\n         entrance_time = rep(0, 10),\n         Lifespan = round(rexp(10, 1), 2),\n         alive = \"YES\") %&gt;% \n  mutate(Mortality_time = entrance_time + Lifespan)\n\n# build the main simulation function\n\ncontinuous_time_simulation &lt;- function(starting_population){\n  \n  # we need this so that t is correctly matched to Mortality_time\n  \n  tolerance &lt;- 0.001\n  \n  # Initialize the timer t to 0\n  t &lt;- 0\n  \n  # Initialize the Individual_ID counter\n  Individual_ID_counter &lt;- 11\n  \n  # Run the simulation until t reaches 10\n  while (t &lt;= 1) {\n    \n    starting_population &lt;- \n      starting_population %&gt;% \n      mutate(time = t,\n             alive = if_else(Mortality_time &lt;= time, \"NO\", alive))\n    \n    # Check if any Mortality_time value matches the current time t - we use the tolerance variable to allow the small amount of wiggle room required to produce a match\n    \n    matching_condition &lt;- which(abs(starting_population$Mortality_time - t) &lt; tolerance)\n    #matching_condition &lt;- 10 - length(which(starting_population$alive == \"YES\"))\n    \n    # we can also add the length of the mated female subset, if 0 don't add a new row\n    \n    if (length(matching_condition) &gt; 0) {\n      #if (matching_condition &gt; 0) {\n      # Add new rows to the starting_population\n      new_rows &lt;- \n        tibble(\n          Individual_ID = Individual_ID_counter:(Individual_ID_counter + length(matching_condition) - 1),\n          entrance_time = rep(t, length(matching_condition)),\n          Lifespan = round(rexp(length(matching_condition)), 2),\n          alive = rep(\"YES\", length(matching_condition))) %&gt;% \n        mutate(Mortality_time = entrance_time + Lifespan)\n      \n      starting_population &lt;- bind_rows(starting_population, new_rows)\n      \n      # Update the Individual_ID counter\n      Individual_ID_counter &lt;- Individual_ID_counter + length(matching_condition)\n    }\n    \n    # Increment 't' by a small time step (e.g. 0.01)\n    t &lt;- t + 0.01\n  }\n  \n  # Print the simulation results\n  print(n = 20, starting_population)\n}\n\ncontinuous_time_simulation(initial_population)\nA very important point is that we consider a population where the resident strategy is to accept mating with a relative. Our simulation therefore estimates the condition required for inbreeding avoidance to invade. One consequence of inbreeding avoidance is an increased risk of going unmated for both sexes when they forego mating with a relative, particularly when the cost of mating for males is large, or search efficiency is low."
  },
  {
    "objectID": "Cuts/useful_cuts.html#plot-the-results",
    "href": "Cuts/useful_cuts.html#plot-the-results",
    "title": "useful_cuts",
    "section": "Plot the results",
    "text": "Plot the results\n\nWhen is inbreeding favoured in each sex?\n\n\nCode\npal1 &lt;- met.brewer(\"OKeeffe1\", n=100, direction = -1)\npal2 &lt;- met.brewer(\"Hiroshige\", n=50, direction = -1)\n  \nFemale_plot &lt;-\n  results %&gt;%\n  filter(v == 100, C != 2 & C != 4) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = female_fitness_contrast)) + \n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-100, -75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  geom_line(data = female_inbreeding_equilibria, aes(x = r, y = D),\n            linetype = 3, alpha = 0.5) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(C ~ a, \n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('C = {`C`}, a = {`a`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Alleles present in females\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", linewidth = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\nMale_plot &lt;-\n  results %&gt;%\n  filter(v == 100, C != 2 & C != 4) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = male_fitness_contrast)) + \n  stat_contour(aes(z = male_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = male_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  geom_line(data = male_inbreeding_equilibria, aes(x = r, y = D),\n            linetype = 3, alpha = 0.5) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(C ~ a, \n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('C = {`C`}, a = {`a`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Alleles present in males\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\nFemale_plot\n\nMale_plot\n\n\n\n\nWhen is there intragenomic conflict over inbreeding?\n\n\nCode\nIntragenomic_conflict &lt;-\n  results %&gt;%\n  filter(v == 100, C != 4, C != 2, C != 1) %&gt;% \n  select(1:5, female_fitness_contrast, male_fitness_contrast) %&gt;%\n  pivot_wider(names_from = a, values_from = c(female_fitness_contrast, male_fitness_contrast)) %&gt;% \n  mutate(intragenomic_conflict_f_0_0.5 = female_fitness_contrast_0.5 - female_fitness_contrast_0,\n         #intragenomic_conflict_f_0.5_1 = female_fitness_contrast_1 - female_fitness_contrast_0.5,\n         intragenomic_conflict_f_0_1 = female_fitness_contrast_1 - female_fitness_contrast_0,\n         intragenomic_conflict_m_0_0.5 = male_fitness_contrast_0.5 - male_fitness_contrast_0,\n         #intragenomic_conflict_m_0.5_1 = male_fitness_contrast_1 - male_fitness_contrast_0.5,\n         intragenomic_conflict_m_0_1 = male_fitness_contrast_1 - male_fitness_contrast_0) %&gt;%\n  pivot_longer(cols = contains(\"intragenomic\"), names_to = \"contrast\", values_to = \"intragenomic_conflict\") %&gt;%\n  mutate(contrast = str_remove(contrast, \"intragenomic_conflict_\")) %&gt;% \n  separate_wider_delim(cols = contrast, delim = \"_\", names = c(\"Sex\", \"a_2\", \"a_1\")) %&gt;% \n  unite(\"contrast\", a_1:a_2) %&gt;% \n    mutate(contrast = case_when(\n    contrast == \"0.5_0\" ~ \"a = 0.5 - a = 0\",\n    contrast == \"1_0\" ~ \"a = 1 - a = 0\")) %&gt;%\n  mutate(intragenomic_conflict = case_when(\n    female_fitness_contrast_0 &lt; 0 & female_fitness_contrast_0.5 &gt; 0 & Sex == \"f\" & contrast == \"a = 0.5 - a = 0\" \n    ~ intragenomic_conflict,\n    female_fitness_contrast_0 &lt; 0 & female_fitness_contrast_1 &gt; 0 & Sex == \"f\" & contrast == \"a = 1 - a = 0\" \n    ~ intragenomic_conflict,\n    male_fitness_contrast_0 &gt; 0 & male_fitness_contrast_0.5 &lt; 0 & Sex == \"m\" & contrast == \"a = 0.5 - a = 0\" \n    ~ intragenomic_conflict,\n    male_fitness_contrast_0 &gt; 0 & male_fitness_contrast_1 &lt; 0 & Sex == \"m\" & contrast == \"a = 1 - a = 0\" \n    ~ intragenomic_conflict,\n    .default = NA)) %&gt;% \n  select(1:4, Sex, contrast, contains(\"intragenomic\")) \n    \n\nmake_genomic_conflict_plot &lt;- \n  function(sex, enter_subtitle){\n    Intragenomic_conflict %&gt;%\n      filter(Sex == sex) %&gt;% \n      #mutate(C = as.numeric(C)) %&gt;% \n      ggplot(aes(x = r, y = D)) +\n      geom_blank() +\n      geom_tile(aes(fill = intragenomic_conflict)) + \n      #stat_contour(aes(z = intragenomic_conflict), colour = \"black\",\n       #     breaks = c(-.10, -.20, -.30, -.40, -.50, -.60, -.70, -.80, -.90, -.100,\n        #               .10, .20, .30, .40, .50, .60, .70, .80, .90, .100),\n         #   upright = TRUE) +\n      #stat_contour(aes(z = intragenomic_conflict*100), colour = \"black\", breaks = 0,\n       #    linetype = 2) +\n      scale_fill_gradientn(colours = pal2, limits = c(-1.25, 1.1), na.value = \"white\",\n                           labels = c(\"Strong conflict\", -0.5, \"No conflict\", 0.5, \"Strong conflict\")) +\n      facet_wrap(C~contrast, nrow = 2,\n                 scales = \"free\", strip.position = c(\"top\"),\n                 labeller = label_glue('contrast: {`contrast`}, C = {`C`}')) +\n      labs(x = expression(~italic(r)~', the relatedness coefficient'),\n           y = ~delta~'(inbreeding depression)',\n           fill = \"Intragenomic conflict\",\n           subtitle = enter_subtitle) +\n      scale_x_continuous(expand = c(0, 0)) + \n      scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n      theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n            strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n  }\n\nmake_genomic_conflict_plot(sex = \"f\", \"Intragenomic conflict in females\")\nmake_genomic_conflict_plot(sex = \"m\", \"Intragenomic conflict in males\")\n\n\n\n\nWhen is there sexual conflict over inbreeding?\n\n\nCode\nautosomal_data &lt;-\n  results %&gt;%\n  filter(a == 1, v == 100,C != 4, C != 1) %&gt;% \n  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;%\n   mutate(sexual_conflict_updated = \n           if_else(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0, sexual_conflict, NA),\n          Location = \"Autosomal\") \n\nX_data &lt;- \n  results %&gt;% \n  filter(a == 0.5, C != 4, C != 1, v == 100) %&gt;%  \n  select(1:5, contains(\"female\")) %&gt;% \n  rename(a_female = a) %&gt;% # this step makes the join work as intended\n  left_join(\n    results %&gt;% \n      filter(a == 1, C != 4, C != 1, v == 100) %&gt;% \n      select(1:5, starts_with(\"male\")) %&gt;% \n      rename(a_male = a) # this step makes the join work as intended\n  ) %&gt;%\n  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;% \n  mutate(sexual_conflict_updated = \n           if_else(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0, sexual_conflict, NA),\n         Location = \"X-linked\")\n\nZ_data &lt;-\n  results %&gt;% \n  filter(a == 1, C != 4, C != 1, v == 100) %&gt;%  \n  select(1:5, contains(\"female\")) %&gt;% \n  rename(a_female = a) %&gt;% left_join(\n    \n    results %&gt;% \n      filter(a == 0.5, C != 4, C != 1, v == 100) %&gt;% \n      select(1:5, starts_with(\"male\")) %&gt;% \n      rename(a_male = a)\n  ) %&gt;% \n  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;%\n    mutate(sexual_conflict_updated = \n             if_else(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0, sexual_conflict, NA),\n           Location = \"Z-linked\")\n\n\n\nSexual_conflict_plot &lt;-\n  bind_rows(autosomal_data, X_data, Z_data) %&gt;%\n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_tile(aes(fill = sexual_conflict_updated)) + \n  # stat_contour(aes(z = sexual_conflict_updated), colour = \"black\",\n  #      breaks = c(-.10, -.20, -.30, -.40, -.50, -.60, -.70, -.80, -.90, -.100,\n  #                .10, .20, .30, .40, .50, .60, .70, .80, .90, .100),\n  #    upright = TRUE) +\n  #stat_contour(aes(z = sexual_conflict*100), colour = \"black\", breaks = 0,\n  #    linetype = 2) +\n  scale_fill_gradientn(colours = pal2, limits = c(-1.25, 1.1), na.value = \"white\",\n                       labels = c(\"Strong conflict, female (+)\", -0.5, \n                                  \"No conflict\", 0.5, \"Strong conflict, male (+)\")) +\n  facet_wrap(Location~C, \n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('{`Location`}, C = {`C`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Intensity of\\nsexual conflict\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n  \nSexual_conflict_plot\n\n\n\n\nThe cytoplasmic case\nThe results for cytoplasmic alleles are intuitive. Inbreeding can evolve through selection on either sex, but there is very little sexual antagonism over inbreeding, as selection optimises female fitness in both cases. The extent to which the inbreeding strategy is favoured can vary but the sign will never be opposing.\n\n\nCode\nFemale_cyto_plot &lt;-\n  results %&gt;%\n  filter(v != 10, C != 2 & C != 4, a == 0) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = female_fitness_contrast)) + \n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-100, -75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(v ~ C, \n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('v = {`v`}, C = {`C`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Alleles present in females\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", linewidth = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", size = .8))\n\n\nMale_cyto_plot &lt;-\n  results %&gt;%\n  filter(v != 10, C != 2 & C != 4, a == 1) %&gt;%  \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_tile(aes(fill = cyto_male_fitness_contrast)) + \n  stat_contour(aes(z = cyto_male_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = cyto_male_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(v ~ C,\n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('v = {`v`}, C = {`C`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Cytoplasmic alleles present in males\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", size = .8))\n\nFemale_cyto_plot\n\nMale_cyto_plot"
  },
  {
    "objectID": "Cuts/useful_cuts.html#sim-run-old-results---figures-will-be-handy",
    "href": "Cuts/useful_cuts.html#sim-run-old-results---figures-will-be-handy",
    "title": "useful_cuts",
    "section": "Sim run old results - figures will be handy",
    "text": "Sim run old results - figures will be handy"
  },
  {
    "objectID": "Cuts/useful_cuts.html#is-the-model-behaving",
    "href": "Cuts/useful_cuts.html#is-the-model-behaving",
    "title": "useful_cuts",
    "section": "Is the model behaving?",
    "text": "Is the model behaving?\nTo check whether the simulation is behaving as intended, we simulate two parameter spaces 200 times:\n\nan autosomal case and 2) a Y-linked case. In each parameter space \\(v\\) = 50, dominance = 1, there is no cost to mating for males, no inbreeding depression and the allele is only expressed in males. Our analytical results show that in both cases, inbreeding should be favoured by selection. With \\(v\\) = 50 (males are highly proficient at finding females) and no costs associated with inbreeding, the population size should oscillate around a carrying capacity of approximately 500 individuals in case 1 (given there are 100 breeding sites, within which each female can produce 5 offspring) and 2000 individuals in case 2 (given to match the number of autosomal chromosomes requires four times the individual population size for a Y-linked allele).\n\nWe plot the individual population size and frequency of the \\(I\\) allele through time.\n\n\nCode\ninvasion_case &lt;- read_csv(\"sim_results/invasion_case_check.csv\")\nneutral_case &lt;- read_csv(\"sim_results/neutral_case_check.csv\")\nfemale_W_case &lt;- read_csv(\"sim_results/female_W_case.csv\")\nfemale_C_case &lt;- read_csv(\"sim_results/female_C_case.csv\")\nfemale_C_v_small_case &lt;- read_csv(\"sim_results/female_C_v_small_case.csv\")\n\n\npop_size_plot &lt;-\n  invasion_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = run), alpha = 0.4) + \n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 3000)) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       title = \"Autosomal inbreeding allele (male)\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.text = element_text(size = 12))\n\nI_prop_plot &lt;-\n  invasion_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = run), alpha = 0.4) +\n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.8)) +\n  labs(x = \"Time\",\n       y = \"Frequency _I_ allele\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        axis.text = element_text(size = 12))\n\nneutral_pop_size_plot &lt;-\n  neutral_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = run), alpha = 0.4) + \n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 3000)) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       title = \"Y-linked inbreeding allele (male)\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.text = element_text(size = 12))\n\nneutral_I_prop_plot &lt;-\n  neutral_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = run), alpha = 0.4) +\n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.8)) +\n  labs(x = \"Time\",\n       y = \"Frequency _I_ allele\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        axis.text = element_text(size = 12))\n\nW_pop_size_plot &lt;-\n  female_W_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = run), alpha = 0.4) +\n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 3000)) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       title = \"W-linked inbreeding allele (female)\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.text = element_text(size = 12))\n\nW_I_prop_plot &lt;-\n  female_W_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = run), alpha = 0.4) +\n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.8)) +\n  labs(x = \"Time\",\n       y = \"Frequency _I_ allele\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        axis.text = element_text(size = 12))\n\nC_pop_size_plot &lt;-\n  female_C_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = run), alpha = 0.4) + \n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 3000)) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       title = \"Cytoplasmic inbreeding allele (male)\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.text = element_text(size = 12))\n\nC_I_prop_plot &lt;-\n  female_C_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = run), alpha = 0.4) +\n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.8)) +\n  labs(x = \"Time\",\n       y = \"Frequency _I_ allele\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        axis.text = element_text(size = 12))\n\nC_v_pop_size_plot &lt;-\n  female_C_v_small_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = population_size)) + \n  geom_line(aes(group = run), alpha = 0.4) + \n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 3000)) +\n  labs(x = \"Time\",\n       y = \"Population size\",\n       title = \"Cytoplasmic inbreeding allele (male)\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.text = element_text(size = 12))\n\nC_v_I_prop_plot &lt;-\n  female_C_v_small_case %&gt;% as_tibble() %&gt;% \n  mutate(time_diff = time - lag(time),\n         run = 1) %&gt;% \n  filter(!is.na(time_diff)) %&gt;% \n  mutate(run= as.factor(run + cumsum(time_diff &lt; 0))) %&gt;% \n  ggplot(aes(x = time, y = proportion_I)) + \n  geom_line(aes(group = run), alpha = 0.4) +\n  geom_smooth(linewidth = 2) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 80)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.8)) +\n  labs(x = \"Time\",\n       y = \"Frequency _I_ allele\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = 14),\n        axis.title.y = element_markdown(),\n        axis.text = element_text(size = 12))\n\n(pop_size_plot | neutral_pop_size_plot | W_pop_size_plot | C_pop_size_plot) / \n  (I_prop_plot | neutral_I_prop_plot | W_I_prop_plot | C_I_prop_plot)"
  },
  {
    "objectID": "Cuts/useful_cuts.html#autosomal-results",
    "href": "Cuts/useful_cuts.html#autosomal-results",
    "title": "useful_cuts",
    "section": "Autosomal results",
    "text": "Autosomal results\nPlot the frequency of the I allele\n\n\nCode\nErnst &lt;- moma.colors(\"Ernst\", n = 50, direction = -1)\n\nX %&gt;% \n  mutate(D_prop = D/-2) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = I_frequency)) + \n  scale_fill_gradientn(colours = Ernst, limits = c(0, 1), #na.value = \"white\",\n                       breaks = c(0, 1)) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\",\n       fill = \"I fequency\",\n       title = \"Autosomal allele expressed in males\") +\n  facet_wrap(v~dominance, nrow = 3,\n             labeller = label_glue('Male search efficiency: {`v`}\\nDominance coefficient: {`dominance`}')) +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14))\n\n\nPlot population size at the end of the simulation run\n\n\nCode\nExter &lt;- moma.colors(\"Exter\", n = 50, direction = -1)\n\nX %&gt;% \n  mutate(D_prop = D/-2) %&gt;% \n  ggplot(aes(x = D_prop, y = refractory_period)) +\n  geom_blank() +\n  geom_tile(aes(fill = final_pop_size)) + \n  scale_fill_gradientn(colours = Exter, limits = c(150, 750), #na.value = \"white\",\n                       breaks = c(150, 750)) +\n  labs(x = ~delta~'(inbreeding depression)',\n       y = \"Male refractory period\",\n       fill = \"I fequency\",\n       title = \"Autosomal allele expressed in males\") +\n  facet_wrap(v~dominance, nrow = 3,\n             labeller = label_glue('Male search efficiency: {`v`}\\nDominance coefficient: {`dominance`}')) +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 10),\n        plot.title = element_text(hjust = 0.5, size = 16),\n        axis.title.x = element_text(size = 14),\n        axis.title.y = element_text(size = 14))"
  },
  {
    "objectID": "Cuts/simulation_versions.html",
    "href": "Cuts/simulation_versions.html",
    "title": "Untitled",
    "section": "",
    "text": "Code\nbuild_starting_pop &lt;-\n  function(seed, pop_size, mean_lifespan, Male_geno, Female_geno){\n    #set.seed(seed)\n    \n    population &lt;-\n      data.table(mortality_rate = 1/mean_lifespan,\n                 Sex = rbinom(n = pop_size, 1, prob = 0.5),\n                 birth_time = 0,\n                 matings = 0,\n                 reproduced = 0,\n                 mated_with = \"NA\",\n                 inbred_mating = 0,\n                 refractory_period_end = 0)\n    \n    population[, `:=` (Genotype = ifelse(Sex &gt; 0, Male_geno, Female_geno),\n                       breeding = Sex,\n                       Individual_ID = .I,\n                       Family_ID = rep(1:(.N/N), each = N, length.out = .N))]\n  }\nCode\ncontinuous_time_simulation &lt;- function(row,\n                                       parameters){\n  \n  print(paste(\"Doing row\", row)) # this tells you which row in the parameter space is being modelled\n  \n  Starting_pop_size &lt;- parameters$Starting_pop_size[row] # constant at 200\n  N &lt;- parameters$N[row] # constant at 10\n  number_mutants &lt;- parameters$number_mutants[row] # constant at 1 \n  baseline_mean_lifespan &lt;- parameters$baseline_mean_lifespan[row] # constant at 2\n  time_end &lt;- parameters$time_end[row] # constant at XX\n  sex_expressed &lt;- parameters$sex_expressed[row]\n  chromosome &lt;- parameters$chromosome[row]\n  inheritance_scheme &lt;- get(parameters$inheritance_scheme[row])\n  allele_freq_finder &lt;- get(parameters$allele_freq_finder[row])\n  heterozygous_genotype &lt;- parameters$heterozygous_genotype[row]\n  homozygous_genotype &lt;- parameters$homozygous_genotype[row]\n  sex_homozygous &lt;- parameters$sex_homozygous[row]\n  #C &lt;- parameters$C[row]\n  v &lt;- parameters$v[row]\n  refractory_period &lt;- parameters$refractory_period[row]\n  D &lt;- parameters$D[row]\n  dominance &lt;- parameters$dominance[row]\n  \n  \n  # define the starting genotypes for each sex so the population table can be built\n  \n  Female_starting_genotype &lt;- inheritance_scheme[.N]$Female_genotype\n  \n  Male_starting_genotype &lt;- inheritance_scheme[.N]$Male_genotype\n  \n  # make sure random number generation is not replicated across simulation runs\n  \n  #set.seed(runif(1, 0, 1))\n  \n  # Initialize the timer t to 0\n  t &lt;- 0\n  \n  # Set the number of breeding sites\n  \n  breeding_sites &lt;- 0.5*Starting_pop_size\n  \n  # Initialize the Individual_ID  and Family_ID counters\n  \n  Individual_ID_counter &lt;- Starting_pop_size\n  \n  Family_ID_counter &lt;- Starting_pop_size/10 # the sim starts with 200 individuals from 200 different families...\n  \n  keep_going &lt;- TRUE # if the inbreeding allele fixes or goes extinct, this will change to false and the while loop will quit early\n  \n  # the simulation tracks the population via two dataframes. The first holds info about the individuals in the population, while the second (the candidate list) holds info on encounters between males and females in the population\n  \n  # create the starting population - note that females are sex = 1 and males are sex = 0\n  \n  population &lt;- \n    build_starting_pop(pop_size = Starting_pop_size, \n                       mean_lifespan = baseline_mean_lifespan)\n  \n  # seed population with the inbreeding allele using our custom mutate_sample() function\n\n  mutate_sample(population,\n                number_mutants = number_mutants) # with data.table, object don't always require names to be updated\n  \n  # create sex specific data tables that can be matched to the mating timestamps\n  \n  female_population &lt;-\n    population[Sex &gt; 0, \n               .(Female_ID = Individual_ID, \n                 Female_genotype = Genotype, \n                 Female_mortality_time = Mortality_time,\n                 #inbred_mating,\n                 #breeding,\n                 Female_family_ID = Family_ID)] \n  \n  \n  male_population &lt;-\n    population[Sex &lt; 1, \n               .(Male_ID = Individual_ID, \n                 Male_genotype = Genotype, \n                 Male_mortality_time = Mortality_time,\n                 Male_family_ID = Family_ID)] \n  \n  # Create the initial candidate list of mating interactions\n  \n  initial_females &lt;- female_population[, Female_ID]\n  \n  initial_males &lt;- male_population[, Male_ID]\n  \n  candidate_list &lt;- \n    candidate_timestamp_finder(Female_ID = initial_females,\n                               Male_ID = initial_males,\n                               v = v,\n                               Female_pop_size = length(initial_females)\n    )[female_population, on = 'Female_ID' # join the important genetic and life history info\n    ][male_population, on = \"Male_ID\"]\n  \n  # With the initial population and mating schedule ready to go, start the timer and let the simulation run. In short, time progresses and events with predetermined time stamps occur. These events trigger new actions which can lead to the production of new breeding individuals, which have their own timeline of predetermined events and interactions.\n  \n  while (t &lt;= time_end & keep_going) {\n    \n    # step 1. check whose still alive\n    \n    population &lt;-\n      population[Mortality_time &gt; t]\n    \n    # step 2. find new breeders if there's space and females to fill it\n    \n    # Get the current size of the breeding female population \n    \n    current_breeders &lt;- sum(population$breeding &gt; 0)\n    \n    # If there are available breeding sites, and females to fill them, recruit new breeders\n    \n    if(current_breeders &lt; breeding_sites && sum(population$Sex &gt; 0 & population$breeding &lt; 1) &gt; 0){\n      \n      # choose whether site or female availability limits recruitment\n      \n      size_input &lt;- min(breeding_sites - current_breeders, \n                        sum(population$Sex &gt; 0 & population$breeding &lt; 1))\n      \n      # assign the new breeders\n      \n      population &lt;- population[sample(which(breeding &lt; 1 & Sex &gt; 0),\n                                      size = size_input, \n                                      replace = FALSE), # note that all females have equal prob of becoming a breeder atm\n                               breeding := 1]\n      \n      # slot the newly updated population info into the candidate list\n      \n      #candidate_list &lt;- candidate_list[population[Sex &gt; 0, .(Female_ID = Individual_ID, breeding)], \n       #                                on = .(Female_ID),\n        #                               breeding := i.breeding]\n    }\n    \n    # step 3. mating\n    \n    # trim the candidate list by removing 1) removing all encounters for individuals that have died and 2) all encounters from the past, except those that led to mating but haven't yet led to reproduction (we need these later). t - 0.1 is used because time elapsed increases by 0.1 units every iteration.  \n    \n    candidate_list &lt;- candidate_list[Female_mortality_time &gt; t &\n                                       Male_mortality_time &gt; t & \n                                       Mate_encounter_time_stamp &gt; t - 0.1]\n    \n    # now use the list to check whether there are any female-male encounters at this moment that result in mating\n    # to do this, first create a table holding all encounters that occur at the current time\n    \n    encounters &lt;- candidate_list[Mate_encounter_time_stamp &lt;= t]\n    \n    # if an encounter occurs involving an individual carrying the A_I allele, provide an opportunity for inbreeding. Heterozygotes inbreed with 0.5 probability i.e. additive genetic expression. The hurdle requirement for an inbreeding opportunity is that an individual must stay alive long enough to meet any member of the opposite sex. We then code the simulation such that this opposite sex individual is swapped out for a full-sibling that can be mated with. This simulates a common situation in nature, where due to population viscosity, relatives live in close geographic proximity and are thus more likely to be encountered, or to be encountered early in life. \n    \n    inbreeders &lt;- data.table(Female_ID=numeric(), Male_ID=numeric()) # keeps the model running if no inbreeding occurs at t\n    \n    # find males that will inbreed when they are the sex that expresses inbreeding tolerance\n    \n    if(sex_expressed &lt; 1 & sum(str_detect(encounters$Male_genotype, \"I\") &gt; 0)){\n      \n      inbreeding_male_IDs &lt;- \n        unique(copy(encounters)\n               [str_detect(Male_genotype, \"A_IA_O\"), inbreeding := rbinom(.N, 1, dominance) # heterozygotes\n               ][str_detect(Male_genotype, \"A_IA_I\"), inbreeding := 1 # homozygotes\n               ][inbreeding &gt; 0, .(Male_ID) # select those that inbreed\n               ])\n      \n      # find new mates (sisters) for males\n      \n      inbreeders &lt;-\n        unique(\n          candidate_list[inbreeding_male_IDs, on = \"Male_ID\"\n          ][Female_family_ID == Male_family_ID & # this line produces full-sib mating, if a receptive sib exists\n              female_matings &lt; 1 & \n              t &gt; refractory_period_end,\n              #male_matings &lt; C,\n            .SD[sample(.N, 1, replace = F)], by = \"Male_ID\" # choose a sister to mate with \n          ][, `:=`(mated = 1, inbred_mating = 1) # change mating status and move encounter time forward\n          ], by = \"Female_ID\" # make sure no female is chosen twice\n        )[, .(Female_ID, Male_ID, mated, Mate_encounter_time_stamp, inbred_mating)] \n      \n      # update the candidate list by moving the chosen mating forward to the present time.\n      \n      candidate_list[inbreeders, `:=` (mated = i.mated, \n                                       Mate_encounter_time_stamp = t,\n                                       inbred_mating = i.inbred_mating),\n                     on = .(Female_ID, Male_ID)]\n    }\n    \n    # find females that will inbreed when they are the sex that expresses inbreeding tolerance\n    \n    if(sex_expressed &gt; 0 & sum(str_detect(encounters$Female_genotype, \"I\") &gt; 0)){\n      \n      # do females carrying the I allele inbreed or not. Depends on genotype and dominance \n      \n      inbreeding_female_IDs &lt;- \n        unique(copy(encounters)\n               [str_detect(Female_genotype, \"A_IA_O\"), inbreeding := rbinom(.N, 1, dominance) # heterozygotes\n               ][str_detect(Female_genotype, \"A_IA_I\"), inbreeding := 1 # homozygotes\n               ][inbreeding &gt; 0, .(Female_ID)\n               ])\n      \n      # find new mates for females, first those chosen to mate with a full sib, then those that mate at random in the pop\n      \n      inbreeders &lt;-\n        unique(\n            candidate_list[inbreeding_female_IDs, on = \"Female_ID\"\n            ][Female_family_ID == Male_family_ID & # this line produces full-sib mating\n                female_matings &lt; 1 & \n                #male_matings &lt; C,\n                t &gt; refractory_period_end,\n              .SD[sample(.N, 1)], by = \"Female_ID\" # choose brother to mate with\n            ][, `:=`(mated = 1, inbred_mating = 1) # change mating status and move encounter forward\n          ], by = \"Male_ID\" # make sure no male is chosen twice\n        )[, .(Female_ID, Male_ID, mated, Mate_encounter_time_stamp, inbred_mating)] \n      \n      # update the candidate list by moving the chosen mating forward to the present time. \n      \n      candidate_list[inbreeders, `:=` (mated = i.mated, \n                                       Mate_encounter_time_stamp = t,\n                                       inbred_mating = i.inbred_mating),\n                     on = .(Female_ID, Male_ID)]\n    }\n    \n    # conduct outbred matings\n    \n    receptive_encounters &lt;-\n      encounters[female_matings &lt; 1 & \n                    t &gt; refractory_period_end\n                   #male_matings &lt; C\n      ][, f_number := .N, by = Female_ID\n      ][, m_number := .N,  by = Male_ID\n      ][!inbreeders, on = .(Female_ID) # remove females involved in inbreeding at this time\n      ][!inbreeders, on = .(Male_ID)] # remove males involved in inbreeding at this time\n    \n    # if individuals encounter multiple individuals at once, make sure they just choose one to mate with. If two individuals choose the same individual of the opposite sex, one randomly succeeds and the other(s) miss out\n    \n    if(max(receptive_encounters$f_number) &gt; 1 | max(receptive_encounters$m_number) &gt; 1){\n      \n      likely_matings &lt;- receptive_encounters[, \n                                             .I[Mate_encounter_time_stamp == min(Mate_encounter_time_stamp)], \n                                             by = Female_ID]$V1\n      \n      chosen_matings &lt;- unique(receptive_encounters[likely_matings, \n                                                    .(Male_ID, Female_ID)], \n                               by = \"Male_ID\")[, mated := 1]\n      \n      # update the candidate list\n      \n      candidate_list &lt;- candidate_list[chosen_matings, \n                                       on = .(Male_ID = Male_ID, Female_ID = Female_ID), \n                                       mated := i.mated]\n      \n    } else{\n      candidate_list &lt;-\n        candidate_list[!inbreeders, on = .(Female_ID) # remove females involved in inbreeding at this time\n        ][!inbreeders, on = .(Male_ID)  # remove males involved in inbreeding at this time\n        ][Mate_encounter_time_stamp &lt;= t &\n            female_matings &lt; 1 &\n            #male_matings &lt; C\n            t &gt; refractory_period_end, \n          mated := 1]\n    }\n    \n    # update the mating tally in the population tibble\n    # the counted variable indicates that the successful mating has already been included in the female and males mating tally\n    # `new matings` combines the inbred matings and the 'normal matings' that occur at time t\n    \n    new_matings &lt;- \n      candidate_list[mated &gt; 0 & counted &lt; 1, .(Female_ID = Female_ID,\n                                                Male_ID = Male_ID,\n                                                matings = mated,\n                                                inbred_mating = inbred_mating, \n                                                mated_with = Male_genotype)] # this column only matters for females\n    \n    if(nrow(new_matings) &gt; 0){\n      # melt reshapes the table from wide to long, like pivot_longer in the tidyverse\n      population &lt;- population[melt(new_matings,\n                                    measure.vars = c(\"Female_ID\", \"Male_ID\"),\n                                    value.name = \"Individual_ID\"),#[,.(Individual_ID, matings, inbred_mating, mated_with)], \n                               `:=`(matings = matings + i.matings,\n                                    inbred_mating = ifelse(Sex == 1, i.inbred_mating, 0),\n                                    mated_with = ifelse(Sex == 1, i.mated_with, \"NA\"),\n                                    refractory_period_end = ifelse(i.matings &gt; 0 & Sex &lt; 1, \n                                                                   t + refractory_period*baseline_mean_lifespan, # cost of mating for males\n                                                                   refractory_period_end)), \n                                    on = \"Individual_ID\"]\n      \n      # update the mating tally in the candidate list and check specific matings off as counted\n      \n      new_mated_females &lt;- \n        new_matings[, .(Female_ID, female_matings = matings)]\n      \n      new_mated_males &lt;- \n        new_matings[, .(Male_ID, male_matings = matings)]\n      \n      candidate_list &lt;- \n        candidate_list[new_mated_females, \n                       female_matings := female_matings + i.female_matings, \n                       on = \"Female_ID\"\n        ][new_mated_males, `:=` (male_matings = male_matings + i.male_matings),\n          on = \"Male_ID\"\n        ][new_matings, counted := 1, on = c(\"Female_ID\", \"Male_ID\")] # this ticks the mating off as counted\n    }\n    \n    # step 4: reproduction\n    \n    # check how many females can now produce offspring, either because they're previously mated and have secured a breeding site or because they already held a breeding site and have now mated\n    \n    new_mated_breeders &lt;- population[matings &gt; 0 & breeding &gt; 0 & reproduced &lt; 1, \n                                     .(Individual_ID,\n                                       inbred_mating,\n                                       Female_genotype = Genotype,\n                                       Male_genotype = mated_with)]\n    \n    if(nrow(new_mated_breeders) &gt; 0) {\n      # add offspring to the population. Each mated female that holds a breeding site produces N offspring\n       offspring &lt;- \n        new_mated_breeders[inheritance_scheme, \n          on = .(Female_genotype = Female_genotype,\n                 Male_genotype = Male_genotype), \n          nomatch = NULL, allow.cartesian  = TRUE\n        ][, .SD[sample(.N, \n                       size = N, \n                       prob = zygote_freq, \n                       replace = T)],\n          by = .(Individual_ID)\n        ][, Family_ID := .GRP + Family_ID_counter,\n          by = .(Individual_ID)\n        ][, .(Genotype, \n              Sex, \n              inbred_mating,\n              Family_ID)\n        ][, `:=`(birth_time = t,\n                 Lifespan = ifelse(inbred_mating &gt; 0, rexp(.N, rate = 1/(baseline_mean_lifespan + D)), # the cost of inbreeding - note D &lt;= 0\n                                   rexp(.N, rate = 1/baseline_mean_lifespan)),\n                 breeding = 0,\n                 matings = 0,\n                 reproduced = 0,\n                 mated_with = \"NA\",\n                 refractory_period_end = 0)\n        ][, `:=` (Mortality_time = Lifespan + t, #birth_time,\n                  Individual_ID = .I + Individual_ID_counter,\n                  inbred_mating = 0)] # drops the inbred mating column that we don't need in the population table\n      \n      # bind the offspring table to the existing population table and update which females have reproduced \n      \n      population &lt;- rbindlist(list(population, offspring), use.names = TRUE\n                              )[new_mated_breeders, reproduced := 1, on = .(Individual_ID)]\n      \n      # Update the candidate list now that there are new members of the population. The potential for new encounters changes the system (i.e. the timing of future encounters), so all encounter times must be recalculated.  \n      \n      current_females &lt;- population[Sex &gt; 0, \n                                .(Female_ID = Individual_ID,\n                                  Female_mortality_time = Mortality_time,\n                                  Female_genotype = Genotype,\n                                  Female_family_ID = Family_ID,\n                                  female_matings = matings,\n                                  inbred_mating)]\n\n      \n      current_males &lt;- population[Sex &lt; 1, \n                              .(Male_ID = Individual_ID,\n                                Male_mortality_time = Mortality_time,\n                                Male_genotype = Genotype,\n                                Male_family_ID = Family_ID,\n                                male_matings = matings,\n                                refractory_period_end)]\n      \n    \n      \n  # get all individuals from the population table and generate a new encounter list \n      \n    candidate_list &lt;-\n      CJ(Female_ID = population[Sex &gt; 0]$Individual_ID, \n         Male_ID = population[Sex &lt; 1]$Individual_ID\n      )[, Mate_encounter_time_stamp := t + rexp(n = .N, rate = (v/sum(population$Sex &gt; 0)))\n      ][current_females, on = .(Female_ID)\n      ][current_males, on = .(Male_ID)][, `:=`(counted = 0,\n                                               mated = 0)]\n    \n    }\n    \n    # Update the Individual_ID counter\n    Individual_ID_counter &lt;- max(population$Individual_ID)\n    Family_ID_counter &lt;- max(population$Family_ID)\n    \n    print(paste0(\"Reproduction from \", nrow(new_mated_breeders), \" breeders, \", current_breeders,\n                 \" breeders alive, time = \", round(t, 2)))\n    \n    \n    # Calculate the frequency of the i allele, quit early if i fixes or goes extinct\n    #prop_i &lt;- calc_prop_inbreeding_allele(population, heterozygous_genotype, homozygous_genotype)\n    prop_i &lt;- allele_freq_finder(population, \n                                 homozygous_genotype = homozygous_genotype, \n                                 heterozygous_genotype = heterozygous_genotype,\n                                 hemizygous_genotype = hemizygous_genotype) \n    \n    \n    # for testing change the invasion success criteria from fixation to an intermediate freq. Change back for final sim\n    #if(prop_i &gt; 0.999 | prop_i &lt; 0.0001) keep_going &lt;- FALSE\n    if(prop_i &gt; 0.4 | prop_i &lt; 0.0001) keep_going &lt;- FALSE\n    \n    \n    # Increment t by a small time step\n    t &lt;- t + 0.1\n  }\n  \n  final_pop_size &lt;- nrow(population)\n  finish_time &lt;- t\n  \n  \n  # Print the simulation results\n  #list(population, candidate_list, prop_i)\n  parameters[row, ] %&gt;% mutate(I_frequency = prop_i,\n                               final_pop_size = final_pop_size,\n                               finish_time = finish_time) %&gt;% \n    select(-c(inheritance_scheme, allele_freq_finder, heterozygous_genotype, homozygous_genotype, sex_homozygous,\n              number_mutants, baseline_mean_lifespan, N, time_end))\n}"
  },
  {
    "objectID": "Cuts/simulation_versions.html#newest-but-slowest-version-dont-use",
    "href": "Cuts/simulation_versions.html#newest-but-slowest-version-dont-use",
    "title": "Untitled",
    "section": "Newest but slowest version (don’t use)",
    "text": "Newest but slowest version (don’t use)\n\n\nCode\ncontinuous_time_simulation &lt;- function(row,\n                                       parameters){\n  \n  print(paste(\"Doing row\", row)) # this tells you which row in the parameter space is being modelled\n  \n  keep_going &lt;- TRUE # if the inbreeding allele fixes or goes extinct, this will change to false and the while loop will quit early\n  \n  prop_i_table &lt;- data.table(time = 0, proportion_I = 0) # filled in as sim progresses\n  \n  Starting_pop_size &lt;- parameters$Starting_pop_size[row] # constant at 200\n  N &lt;- parameters$N[row] # constant\n  number_mutants &lt;- parameters$number_mutants[row] # constant at 1 \n  baseline_mean_lifespan &lt;- parameters$baseline_mean_lifespan[row] # constant at 2\n  time_end &lt;- parameters$time_end[row] # a cut-off point for each run \n  sex_expressed &lt;- parameters$sex_expressed[row]\n  chromosome &lt;- parameters$chromosome[row]\n  inheritance_scheme &lt;- get(parameters$inheritance_scheme[row])\n  allele_freq_finder &lt;- get(parameters$allele_freq_finder[row])\n  heterozygous_genotype &lt;- parameters$heterozygous_genotype[row]\n  homozygous_genotype &lt;- parameters$homozygous_genotype[row]\n  hemizygous_genotype &lt;- parameters$hemizygous_genotype[row]\n  #C &lt;- parameters$C[row]\n  v &lt;- parameters$v[row]\n  refractory_period &lt;- parameters$refractory_period[row]\n  D &lt;- parameters$D[row]\n  dominance &lt;- parameters$dominance[row]\n\n  # define the starting genotypes for each sex so the population table can be built\n  \n  Female_starting_genotype &lt;- inheritance_scheme[.N]$Female_genotype\n  \n  Male_starting_genotype &lt;- inheritance_scheme[.N]$Male_genotype\n  \n  # make sure random number generation is not replicated across simulation runs\n  \n  #set.seed(runif(1, 0, 1))\n  \n  # Set the number of breeding sites\n  \n  breeding_sites &lt;- 0.5*Starting_pop_size\n  \n  # Initialize the Individual_ID  and Family_ID counters\n  \n  Individual_ID_counter &lt;- Starting_pop_size\n  \n  Family_ID_counter &lt;- Starting_pop_size/N # family size equals the no. offspring produced by a single female\n  \n  # the simulation tracks the population via two dataframes. The first holds info about the individuals in the population, while the second (the candidate list) holds info on encounters between males and females in the population\n  \n  # create the starting population - note that females are sex = 1 and males are sex = 0\n  \n  population &lt;- \n    build_starting_pop(pop_size = Starting_pop_size, \n                       mean_lifespan = baseline_mean_lifespan)\n  \n  # seed population with the inbreeding allele using our custom mutate_sample() function\n\n  mutate_sample(population,\n                number_mutants = number_mutants) # how many I alleles should we add to the population?\n  \n  # create sex specific data tables that can be matched to the mating timestamps\n  \n  female_population &lt;- population[Sex &gt; 0, \n                                  .(Female_ID = Individual_ID,\n                                    Female_mortality_time = Mortality_time,\n                                    Female_genotype = Genotype,\n                                    Female_family_ID = Family_ID,\n                                    female_matings = matings)]\n  \n  male_population &lt;- population[Sex &lt; 1, \n                                .(Male_ID = Individual_ID,\n                                  Male_mortality_time = Mortality_time,\n                                  Male_genotype = Genotype,\n                                  Male_family_ID = Family_ID,\n                                  male_matings = matings,\n                                  refractory_period_end)]\n  \n  # Create the initial candidate list of mating interactions\n  \n  number_females &lt;- sum(population$Sex &gt; 0)\n  \n  candidate_list &lt;-\n        CJ(Female_ID = female_population$Female_ID, \n           Male_ID = male_population$Male_ID\n        )[, Mate_encounter_time_stamp := rexp(n = .N, rate = (v/number_females))\n        ]\n  \n    # Initialize the timer t to the first encounter\n  \n  # Find the earliest fate\nmin_female_mortality &lt;- min(female_population$Female_mortality_time)\nmin_male_mortality &lt;- min(male_population$Male_mortality_time)\nmin_mating_encounter &lt;- min(candidate_list$Mate_encounter_time_stamp)\n\nt &lt;- min(min_female_mortality, min_male_mortality, min_mating_encounter)\n  \n  # With the initial population and mating schedule ready to go, start the timer and let the simulation run. In short, time progresses and events with predetermined time stamps occur. These events trigger new actions which can lead to the production of new breeding individuals, which have their own timeline of predetermined events and interactions.\n  \n  while (t &lt;= time_end & keep_going) {\n    \n    # what type of encounter happens at time t\n    \n    fate &lt;- \n      switch(which.min(c(min_female_mortality, min_male_mortality, min_mating_encounter)),\n             \"Female_mortality\",\n             \"Male_mortality\",\n             \"Mate_encounter\")\n    \n    # Male mortality events\n    \n    if(str_detect(fate, \"Male\")){\n      \n      next_fate &lt;- \n        male_population[, .SD[which.min(Male_mortality_time)]]\n      \n      # remove male from population table and candidate list\n      \n      population &lt;- population[!Individual_ID %chin% next_fate$Male_ID]\n      candidate_list &lt;- candidate_list[!Male_ID %chin% next_fate$Male_ID]\n      \n    }\n    \n    # Female mortality events\n    \n    if(str_detect(fate, \"Female\")){\n      \n      next_fate &lt;- \n        female_population[, .SD[which.min(Female_mortality_time)]]\n      \n      # remove female from population table and candidate list\n      \n      population &lt;- population[!Individual_ID %chin% next_fate$Female_ID]\n      candidate_list &lt;- candidate_list[!Female_ID %chin% next_fate$Female_ID]\n      \n      # check if female mortality event frees up breeding site\n      \n      current_breeders &lt;- sum(population$breeding &gt; 0)\n      \n      # If there is an available breeding site, and at least one female to fill it, recruit a new breeder\n      \n      if(current_breeders &lt; breeding_sites && sum(population$Sex &gt; 0 & population$breeding &lt; 1) &gt; 0){\n        \n        # assign the new breeders\n        \n        population &lt;- population[sample(which(breeding &lt; 1 & Sex &gt; 0),\n                                        size = 1), # note that all living females have equal prob of becoming a breeder\n                                 breeding := 1]\n      }\n    }\n    \n    # Opposite sex encounters\n    \n    if(str_detect(fate, \"Mate\")){\n      \n      # join the life history data from the population table with the candidate list table\n      \n      candidate_list &lt;-\n        candidate_list[female_population[, Female_mortality_time := NULL], on = .(Female_ID)\n        ][male_population[, Male_mortality_time := NULL], on = .(Male_ID)]\n      \n      next_fate &lt;- \n        candidate_list[, .SD[which.min(Mate_encounter_time_stamp)]]\n      \n      mates &lt;- data.table() # allows cases where the encounter does not lead to mating\n      \n      # if the encounter occurs involving an individual expressing the A_I allele, provide an opportunity for inbreeding. The hurdle requirement for an inbreeding opportunity is that an individual must stay alive long enough to meet any member of the opposite sex. We then code the simulation such that this opposite sex individual is swapped out for a full-sibling that can be mated with. This simulates a common situation in nature, where due to population viscosity, relatives live in close geographic proximity and are thus more likely to be encountered, or to be encountered early in life. \n      \n      # First determine if a homogametic individual carrying one copy of the I allele will inbreed on this occasion.  \n      \n      heterozygote_inbreeds &lt;- rbinom(1, 1, dominance)\n      \n      # find males that will inbreed when they are the sex that expresses inbreeding tolerance\n      \n      # male heterozygotes (FALSE if there isn't a heterozygote male genotype)\n      \n      if(sex_expressed &lt; 1 & \n         str_detect(next_fate$Male_genotype, heterozygous_genotype) & \n         heterozygote_inbreeds &gt; 0 &\n         next_fate$refractory_period_end &lt; t){\n        \n        # find a new mate (sister) for the males\n        \n        inbred_mating &lt;-\n          candidate_list[next_fate[, .(Male_ID)], on = \"Male_ID\"][\n            Female_family_ID == Male_family_ID, # find full sibs\n            .SD[sample.int(1, 1)][female_matings &lt; 1, # assign a sibling and check if they're receptive\n                                   .(Female_ID, Male_ID, Male_genotype)]]\n        \n        # update the population\n        \n        mates &lt;- inbred_mating[, .(mated_with = Male_genotype, Individual_ID = c(Female_ID, Male_ID))]\n        \n        population[mates,\n                   `:=`(matings = matings + 1,\n                        inbred_mating = 1 * (Sex &gt; 0),\n                        mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                        refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n                   on = .(Individual_ID)]\n        \n      }\n      \n      # male homozygotes (also includes cases where males only ever have one copy of the chromosome e.g. X, Y, C)\n      \n      if(sex_expressed &lt; 1 & \n         str_detect(next_fate$Male_genotype, homozygous_genotype) &\n         next_fate$refractory_period_end &lt; t){\n        \n        # find a new mate (sister) for the males\n        \n        inbred_mating &lt;-\n          candidate_list[next_fate[, .(Male_ID)], on = \"Male_ID\"][\n            Female_family_ID == Male_family_ID, # find full sibs\n            .SD[sample.int(1, 1)][female_matings &lt; 1, # assign a sibling and check if they're receptive\n                                   .(Female_ID, Male_ID, Male_genotype)]]\n        \n        # update the population\n        \n        mates &lt;- inbred_mating[, .(mated_with = Male_genotype, Individual_ID = c(Female_ID, Male_ID))]\n        \n        population[mates,\n                   `:=`(matings = matings + 1,\n                        inbred_mating = 1 * (Sex &gt; 0),\n                        mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                        refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n                   on = .(Individual_ID)]\n      }  \n      \n      # find females that will inbreed when they are the sex that expresses inbreeding tolerance\n      \n      # female heterozygotes (FALSE if there isn't a heterozygote female genotype)\n      \n      if(sex_expressed &gt; 0 & \n         str_detect(next_fate$Female_genotype, heterozygous_genotype) & \n         heterozygote_inbreeds &gt; 0 &\n         next_fate$female_matings &lt; 1){\n        \n        # find a new mate (brother) for the female\n        \n        inbred_mating &lt;-\n          candidate_list[next_fate[, .(Female_ID)], on = \"Female_ID\"][\n            Female_family_ID == Male_family_ID, # find full sibs\n            .SD[sample.int(1, 1)][t &gt; refractory_period_end, # assign a sibling and check if they're receptive\n                                   .(Female_ID, Male_ID, Male_genotype)]]\n        \n        # update the population\n        \n        mates &lt;- inbred_mating[, .(mated_with = Male_genotype, Individual_ID = c(Female_ID, Male_ID))]\n        \n        population[mates,\n                   `:=`(matings = matings + 1,\n                        inbred_mating = 1 * (Sex &gt; 0),\n                        mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                        refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n                   on = .(Individual_ID)]\n        \n      }\n      \n      # female homozygotes (also includes cases where females only ever have one copy of the chromosome e.g. Z, W, C)\n      \n      if(sex_expressed &gt; 0 & \n         str_detect(next_fate$Female_genotype, homozygous_genotype) &\n         next_fate$female_matings &lt; 1){\n        \n        # find a new mate (brother) for the females\n        \n        inbred_mating &lt;-\n          candidate_list[next_fate[, .(Female_ID)], on = \"Female_ID\"][\n            Female_family_ID == Male_family_ID, # find full sibs\n            .SD[sample.int(1, 1)][t &gt; refractory_period_end, # assign a sibling and check if they're receptive\n                                   .(Female_ID, Male_ID, Male_genotype)]]\n        \n        # update the population\n        \n        mates &lt;- inbred_mating[, .(mated_with = Male_genotype, Individual_ID = c(Female_ID, Male_ID))]\n        \n        population[mates,\n                   `:=`(matings = matings + 1,\n                        inbred_mating = 1 * (Sex &gt; 0), \n                        mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                        refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n                   on = .(Individual_ID)]\n      } \n      \n      # standard outbred mating\n      \n      if((next_fate$female_matings &lt; 1 & t &gt; next_fate$refractory_period_end) |\n          (next_fate$female_matings &lt; 1 & t &gt; next_fate$refractory_period_end &\n         sex_expressed &lt; 1 & str_detect(next_fate$Male_genotype, heterozygous_genotype) & heterozygote_inbreeds &lt; 1) |\n         (next_fate$female_matings &lt; 1 & t &gt; next_fate$refractory_period_end &\n         sex_expressed &gt; 0 & str_detect(next_fate$Female_genotype, heterozygous_genotype) & heterozygote_inbreeds &lt; 1)){\n        \n        # update the population\n        \n        mates &lt;- next_fate[, .(mated_with = Male_genotype, Individual_ID = c(Female_ID, Male_ID))]\n        \n        population[mates,\n                   `:=`(matings = matings + 1,\n                        inbred_mating = 0,\n                        mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                        refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n                   on = .(Individual_ID)] \n      }\n      \n      # when mating has occurred but no reproduction, only some things have to be updated in the candidate list \n      \n      mated_nonbreeders &lt;- population[matings &gt; 0 & breeding &lt; 1 & Sex &gt; 0]\n      \n      if(nrow(mated_nonbreeders) &gt; 0 & nrow(mates) &gt; 0){\n        \n        # first remove the current encounter from the list so that time can progress \n        \n        candidate_list &lt;- candidate_list[!next_fate, on = .(Female_ID, Male_ID)]\n        \n        # now update the candidate list with the info we already input into the population table\n        \n        updates &lt;- \n          population[mates[, .(Individual_ID)], on = \"Individual_ID\"][\n            , .(Female_ID = ifelse(Sex &gt; 0, Individual_ID, NA),\n                Male_ID = ifelse(Sex &lt; 1, Individual_ID, NA),\n                female_matings = ifelse(Sex &gt; 0, matings, NA),\n                male_matings = ifelse(Sex &lt; 1, matings, NA),\n                refractory_period_end = ifelse(Sex &lt; 1, refractory_period_end, NA)\n            )\n          ]\n        \n        candidate_list[updates[, .(Female_ID, female_matings)], \n                       female_matings := i.female_matings, on = \"Female_ID\"][\n                         updates[, .(Male_ID, male_matings, refractory_period_end)],\n                         `:=`(male_matings = i.male_matings, refractory_period_end = i.refractory_period_end),\n                         on = \"Male_ID\"\n                       ] \n        \n      } \n      \n      # finally if the encounter does not lead to mating, just remove the encounter from the candidate list\n      \n      if(nrow(mates) &lt; 1){\n        candidate_list &lt;- candidate_list[!next_fate, on = .(Female_ID,\n                                                            Male_ID)]\n      }\n      \n    }\n    \n    # reproduction\n    \n    # check if a female can now produce offspring, either because they're previously mated and have secured a breeding site or because they already held a breeding site and have now mated\n  \n    new_mated_breeder &lt;- population[matings &gt; 0 & breeding &gt; 0 & reproduced &lt; 1, \n                                     .(Individual_ID,\n                                       inbred_mating,\n                                       Female_genotype = Genotype,\n                                       Male_genotype = mated_with)]\n    \n    if(nrow(new_mated_breeder) &gt; 0) {\n      # add offspring to the population. Each mated female that holds a breeding site produces N offspring\n      offspring &lt;- \n        new_mated_breeder[inheritance_scheme, \n                          on = .(Female_genotype = Female_genotype,\n                                 Male_genotype = Male_genotype), \n                          nomatch = NULL, allow.cartesian  = TRUE\n        ][, .SD[sample(.N, \n                       size = N, \n                       prob = zygote_freq, \n                       replace = T)]\n        ][, Family_ID := .GRP + Family_ID_counter # assign these offspring to a new family \n        ][, .(Genotype, \n              Sex, \n              inbred_mating,\n              Family_ID)\n        ][, `:=`(Mortality_time = ifelse(inbred_mating &gt; 0, \n                                         t + rexp(.N, rate = 1/(baseline_mean_lifespan + D)), # the cost of inbreeding: D &lt;= 0\n                                         t + rexp(.N, rate = 1/baseline_mean_lifespan)), # outbred offspring lifespans\n                 birth_time = t,\n                 breeding = 0,\n                 matings = 0,\n                 reproduced = 0,\n                 mated_with = \"NA\",\n                 refractory_period_end = t,\n                 Individual_ID = .I + Individual_ID_counter,\n                 inbred_mating = 0)]\n      \n      # bind the offspring table to the existing population table and update which females have reproduced \n      \n      population &lt;- rbindlist(list(population, offspring), use.names = TRUE\n                              )[new_mated_breeder, reproduced := 1, on = .(Individual_ID)]\n      \n      # update the Individual_ID counter\n      Individual_ID_counter &lt;- max(population$Individual_ID)\n      Family_ID_counter &lt;- max(population$Family_ID)  \n      \n      # update the candidate list now that there are new members of the population. The potential for new encounters changes the system (i.e. the timing of future encounters), so all encounter times must be recalculated.  \n      \n      female_population &lt;- population[Sex &gt; 0, \n                                .(Female_ID = Individual_ID,\n                                  Female_mortality_time = Mortality_time,\n                                  Female_genotype = Genotype,\n                                  Female_family_ID = Family_ID,\n                                  female_matings = matings)]\n\n      male_population &lt;- population[Sex &lt; 1, \n                              .(Male_ID = Individual_ID,\n                                Male_mortality_time = Mortality_time,\n                                Male_genotype = Genotype,\n                                Male_family_ID = Family_ID,\n                                male_matings = matings,\n                                refractory_period_end)]\n      \n      # get all individuals from the population table and generate a new encounter list \n      \n      number_females &lt;- sum(population$Sex &gt; 0)\n      \n      candidate_list &lt;-\n        CJ(Female_ID = female_population$Female_ID, \n           Male_ID = male_population$Male_ID\n        )[, Mate_encounter_time_stamp := t + rexp(n = .N, rate = (v/number_females))\n        ]\n  \n    } else{\n      female_population &lt;- population[Sex &gt; 0, \n                                .(Female_ID = Individual_ID,\n                                  Female_mortality_time = Mortality_time,\n                                  Female_genotype = Genotype,\n                                  Female_family_ID = Family_ID,\n                                  female_matings = matings)]\n\n      male_population &lt;- population[Sex &lt; 1, \n                              .(Male_ID = Individual_ID,\n                                Male_mortality_time = Mortality_time,\n                                Male_genotype = Genotype,\n                                Male_family_ID = Family_ID,\n                                male_matings = matings,\n                                refractory_period_end)]\n    }\n    \n    # Calculate the frequency of the i allele, quit early if i fixes or goes extinct\n    #prop_i &lt;- calc_prop_inbreeding_allele(population, heterozygous_genotype, homozygous_genotype)\n    prop_i &lt;- allele_freq_finder(population, \n                                 homozygous_genotype = homozygous_genotype, \n                                 heterozygous_genotype = heterozygous_genotype,\n                                 hemizygous_genotype = hemizygous_genotype) \n    \n    # this is a diagnostic to make sure the model is running well - it can be commented out when running the big simulation\n    prop_i_table &lt;- rbindlist(list(prop_i_table, list(t, prop_i)))\n    \n    print(paste0(\"Population size = \", nrow(population),\n                 \", time = \", round(t, 3)))\n    \n    # for testing change the invasion success criteria from fixation to an intermediate freq. Change back for final sim\n    #if(prop_i &gt; 0.999 | prop_i &lt; 0.0001) keep_going &lt;- FALSE\n    if(prop_i &gt; 0.9 | prop_i &lt; 0.0001) keep_going &lt;- FALSE\n    \n    # Move t to next fate\n    \n    # Find the earliest fate\n    min_female_mortality &lt;- min(female_population$Female_mortality_time)\n    min_male_mortality &lt;- min(male_population$Male_mortality_time)\n    min_mating_encounter &lt;- min(candidate_list$Mate_encounter_time_stamp)\n    \n    t &lt;- min(min_female_mortality, min_male_mortality, min_mating_encounter)  \n  }\n  \n  final_pop_size &lt;- nrow(population)\n  finish_time &lt;- t\n  \n  # Print the simulation results\n  list(population, candidate_list, prop_i_table)\n  #parameters[row, ] %&gt;% mutate(I_frequency = prop_i,\n   #                            final_pop_size = final_pop_size,\n    #                           finish_time = finish_time) %&gt;% \n    #select(-c(inheritance_scheme, allele_freq_finder, heterozygous_genotype, homozygous_genotype, sex_homozygous,\n     #         number_mutants, baseline_mean_lifespan, N, time_end))\n}"
  },
  {
    "objectID": "Cuts/simulation_versions.html#sim-version-3---replaced-because-outbreeders-never-meet-relatives",
    "href": "Cuts/simulation_versions.html#sim-version-3---replaced-because-outbreeders-never-meet-relatives",
    "title": "Untitled",
    "section": "Sim version 3 - replaced because outbreeders never meet relatives",
    "text": "Sim version 3 - replaced because outbreeders never meet relatives\ncontinuous_time_simulation &lt;- function(row, parameters, inheritance_scheme){ library(data.table) library(tidyverse)\nprint(paste(“Doing row”, row)) # this tells you which row in the parameter space is being modelled\n# prop_i_table &lt;- data.table(time = numeric(), # proportion_I = numeric(), # population_size = numeric()) # filled in as sim progresses\nkeep_going &lt;- TRUE # if the inbreeding allele fixes or goes extinct, this will change to false and the while loop will quit early\nStarting_pop_size &lt;- parameters\\(Starting_pop_size[row]\n  N &lt;- parameters\\)N[row] # constant number_mutants &lt;- parameters\\(number_mutants[row] # constant at 1\n  baseline_mean_lifespan &lt;- parameters\\)baseline_mean_lifespan[row] # constant at 2 time_end &lt;- parameters\\(time_end[row] # a cut-off point for each run\n  sex_expressed &lt;- parameters\\)sex_expressed[row] chromosome &lt;- parameters\\(chromosome[row]\n  heterozygous_genotype &lt;- parameters\\)heterozygous_genotype[row] homozygous_genotype &lt;- parameters\\(homozygous_genotype[row]\n  hemizygous_genotype &lt;- parameters\\)hemizygous_genotype[row] #C &lt;- parameters\\(C[row]\n  v &lt;- parameters\\)v[row] refractory_period &lt;- parameters\\(refractory_period[row]\n  D &lt;- parameters\\)D[row] dominance &lt;- parameters$dominance[row]\n# define the starting genotypes for each sex so the population table can be built\nFemale_starting_genotype &lt;- inheritance_scheme[.N]$Female_genotype\nMale_starting_genotype &lt;- inheritance_scheme[.N]$Male_genotype\n# Set the number of breeding sites\nbreeding_sites &lt;- 0.5*Starting_pop_size\n# Initialize the Individual_ID and Family_ID counters\nIndividual_ID_counter &lt;- Starting_pop_size\nFamily_ID_counter &lt;- Starting_pop_size/N # family size equals the no. offspring produced by a single female\n# the simulation tracks the population via a data.table\n# create the starting population - note that females are sex = 1 and males are sex = 0\npopulation &lt;- data.table(mortality_rate = 1/baseline_mean_lifespan, Sex = rbinom(n = Starting_pop_size, 1, prob = 0.5), birth_time = 0, matings = 0, reproduced = 0, mated_with = “NA”, inbred_mating = 0, refractory_period_end = 0 )[, := (Genotype = ifelse(Sex &gt; 0, Female_starting_genotype, Male_starting_genotype), breeding = Sex, Individual_ID = .I, Family_ID = rep(1:(.N/N), each = N, length.out = .N))]\n# seed population with the inbreeding allele\n# original - random alleles are mutated\n#population[sample(which(str_detect(Genotype, pattern = chromosome)), size = number_mutants, replace = F),\n# Genotype := str_replace(Genotype, pattern = paste0(chromosome, “_O”), replacement = paste0(chromosome, “_I”))]\n# current - entire family is mutated on one chromosome, unless the inbreeding allele is on a hemizygous chromosome, then the minimum number of families are mutated to make 5 mutations\nif(chromosome != “W” & chromosome != “Y”){ population[Family_ID %in% sample(unique(population[, Family_ID]), size = 1), Genotype := str_replace(Genotype, pattern = paste0(chromosome, “_O”), replacement = paste0(chromosome, “_I”))] } else{ # number_mutants is loaded from the parameter table mutations_made &lt;- 0\n# Iterate through unique families as needed\nFamilies &lt;- sample(unique(population$Family_ID), Starting_pop_size/N)\nFamily_index &lt;- 1\n\nwhile (mutations_made &lt; number_mutants && Family_index &lt;= length(Families)) {\n  current_family &lt;- Families[Family_index]\n  \n  # Identify mutate-able rows from the current family\n  Family_rows &lt;- population[Family_ID == current_family & str_detect(Genotype, pattern = chromosome)]\n  \n  # Calculate how many mutations we can make in this family\n  changes_needed &lt;- number_mutants - mutations_made\n  changes_to_make &lt;- min(nrow(Family_rows), changes_needed)\n  \n  # Select the individuals to mutate\n  rows_to_modify &lt;- Family_rows[1:changes_to_make]\n  \n  # Modify the genotype column in the selected rows\n  population[rows_to_modify, \n             Genotype := str_replace(Genotype, pattern = paste0(chromosome, \"_O\"), replacement = paste0(chromosome, \"_I\")),\n             on = \"Individual_ID\"]\n  \n  # Update the count of changes made\n  mutations_made &lt;- nrow(population[str_detect(Genotype, \"I\")])\n  \n  # Move to the next group\n  Family_index &lt;- family_index + 1\n} \n}\n# Determining the next event\n# check when the next death occurs\nnext_death &lt;- rexp(n = 1, rate = sum(population[, mortality_rate]))\nwho_died &lt;- population[sample(.N, 1, prob = mortality_rate)]$Individual_ID\n# check when the next female-male encounter occurs\nfemales &lt;- population[Sex &gt; 0]$Individual_ID\nmales &lt;- population[Sex &lt; 1 & refractory_period_end &lt; t]$Individual_ID\n\n# below is the slow way, which I still include to show it's equivalent to the fast way\n#encounter_possibilities &lt;- \n # CJ(Female_ID = population[Sex &gt; 0]$Individual_ID,\n  #   Male_ID = population[Sex &lt; 1]$Individual_ID)[, encounter_rate := v/number_females]\n\n# check the time\n\n# this is the sum of the rates, because each male finds each female at the same rate\n\nnext_mating &lt;- rexp(n = 1, rate = length(females)*length(males)*(v/number_females))\n\nwhich_encounter &lt;- \n  data.table(Female_ID = sample(females, 1),\n             Male_ID = sample(males, 1))\n# Initialize the timer t to the first encounter\nt &lt;- pmin(next_death, next_mating)\n# With the initial population ready to go and the first event found, start the timer and let the simulation run. In short, time progresses as events occur. Events can trigger state changes for the individuals in the population, leading to death, mating and offspring production.\nwhile (t &lt;= time_end & keep_going){\n# what type of encounter happens at time t\n\nif(next_death &lt; next_mating){\n  \n  # remove individual from population table\n  \n  population &lt;- population[Individual_ID != who_died]\n  \n  # check if mortality event frees up breeding site\n  \n  current_breeders &lt;- sum(population$breeding &gt; 0)\n  \n  # If there is an available breeding site, and at least one female to fill it, recruit a new breeder\n  \n  if(current_breeders &lt; breeding_sites && sum(population$Sex &gt; 0 & population$breeding &lt; 1) &gt; 0){\n    \n    # assign the new breeders\n    \n    population &lt;- population[sample(which(breeding &lt; 1 & Sex &gt; 0),\n                                    size = 1), # note that all living females have equal prob of becoming a breeder\n                             breeding := 1]\n  }\n} else{\n  \n  # Opposite sex encounters\n  \n  female &lt;- population[Individual_ID %chin% which_encounter$Female_ID]\n  male &lt;- population[Individual_ID %chin% which_encounter$Male_ID]\n  \n  # if the encounter occurs involving an individual expressing the A_I allele, provide an opportunity for inbreeding. The hurdle requirement for an inbreeding opportunity is that an individual must stay alive long enough to meet any member of the opposite sex. We then code the simulation such that this opposite sex individual is swapped out for a full-sibling that can be mated with. This simulates a common situation in nature, where due to population viscosity, relatives live in close geographic proximity and are thus more likely to be encountered early in life, prior to dispersing. \n  \n  # First determine if a homogametic individual carrying one copy of the I allele will inbreed on this occasion.  \n  \n  heterozygote_inbreeds &lt;- rbinom(1, 1, prob = dominance)\n  \n  # find males that will inbreed when they are the sex that expresses inbreeding tolerance\n  \n  # male heterozygotes (FALSE if there isn't a heterozygote male genotype)\n  \n  if(sex_expressed &lt; 1 & \n     str_detect(male$Genotype, heterozygous_genotype) & \n     heterozygote_inbreeds &gt; 0 &\n     male$refractory_period_end &lt; t){\n    \n    # find a new mate (sister) for the males\n    \n    sister_mating &lt;-\n      population[Family_ID %chin% male$Family_ID\n      ][Sex &gt; 0, .SD[sample(1, 1)] # assign a sibling, then check if they're receptive\n      ][matings &lt; 1][, mated_with := male[,Genotype]] \n    \n    # if mating occurred, update the population\n    \n    if(nrow(sister_mating)&gt;0){\n      \n      mates &lt;- rbindlist(list(male, sister_mating))\n      \n      population[mates,\n                 `:=`(matings = matings + 1,\n                      inbred_mating = 1 * (Sex &gt; 0),\n                      mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                      refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n                 on = .(Individual_ID)]\n    }\n  }\n  \n  # male homozygotes (also includes cases where males only ever have one copy of the chromosome e.g. X, Y, C)\n  \n  if(sex_expressed &lt; 1 & \n     str_detect(male$Genotype, homozygous_genotype) &\n     male$refractory_period_end &lt; t){\n    \n    # find a new mate (sister) for the males\n    \n    sister_mating &lt;-\n      population[Family_ID %chin% male$Family_ID\n      ][Sex &gt; 0, .SD[sample(1, 1)] # assign a sibling, then check if they're receptive\n      ][matings &lt; 1][, mated_with := male[,Genotype]] \n    \n    # if mating occurred, update the population\n    \n    if(nrow(sister_mating)&gt;0){\n      \n      mates &lt;- rbindlist(list(male, sister_mating))\n      \n      population[mates,\n                 `:=`(matings = matings + 1,\n                      inbred_mating = 1 * (Sex &gt; 0),\n                      mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                      refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n                 on = .(Individual_ID)]\n    }\n  }\n  \n  # find females that will inbreed when they are the sex that expresses inbreeding tolerance\n  \n  # female heterozygotes (FALSE if there isn't a heterozygote female genotype)\n  \n  if(sex_expressed &gt; 0 & \n     str_detect(female$Genotype, heterozygous_genotype) & \n     heterozygote_inbreeds &gt; 0 &\n     female$matings &lt; 1){\n    \n    # find a new mate (brother) for the female\n    \n    brother_mating &lt;-\n      population[Family_ID %chin% female$Family_ID\n      ][Sex &lt; 1, .SD[sample(1, 1)] # assign a sibling, then check if they're receptive\n      ][t &gt; refractory_period_end] \n    \n    # if mating occurred, update the population\n    \n    if(nrow(brother_mating)&gt;0){\n      \n      mates &lt;- rbindlist(list(female[, mated_with := brother_mating[,Genotype]], brother_mating))\n      \n      population[mates,\n                 `:=`(matings = matings + 1,\n                      inbred_mating = 1 * (Sex &gt; 0),\n                      mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                      refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n                 on = .(Individual_ID)]\n    }\n  }\n  \n  # female homozygotes (also includes cases where females only ever have one copy of the chromosome e.g. Z, W, C)\n  \n  if(sex_expressed &gt; 0 & \n     str_detect(female$Genotype, homozygous_genotype) &\n     female$matings &lt; 1){\n    \n    # find a new mate (brother) for the females\n    \n    brother_mating &lt;-\n      population[Family_ID %chin% female$Family_ID\n      ][Sex &lt; 1, .SD[sample(1, 1)] # assign a sibling, then check if they're receptive\n      ][t &gt; refractory_period_end] \n    \n    # if mating occurred, update the population\n    \n    if(nrow(brother_mating)&gt;0){\n      \n      mates &lt;- rbindlist(list(female[, mated_with := brother_mating[,Genotype]], brother_mating))\n      \n      population[mates,\n                 `:=`(matings = matings + 1,\n                      inbred_mating = 1 * (Sex &gt; 0),\n                      mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                      refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n                 on = .(Individual_ID)]\n    }\n  }\n  \n  # standard outbred mating\n  \n  if((female$matings &lt; 1 & t &gt; male$refractory_period_end) |\n     (female$matings &lt; 1 & t &gt; male$refractory_period_end &\n      sex_expressed &lt; 1 & str_detect(male$Genotype, heterozygous_genotype) & heterozygote_inbreeds &lt; 1) |\n     (female$matings &lt; 1 & t &gt; male$refractory_period_end &\n      sex_expressed &gt; 0 & str_detect(female$Genotype, heterozygous_genotype) & heterozygote_inbreeds &lt; 1)){\n    \n    # update the population\n    \n    mates &lt;- rbindlist(list(female[, mated_with := male[,Genotype]], male))\n    \n    population[mates,\n               `:=`(matings = matings + 1,\n                    inbred_mating = 0,\n                    mated_with = ifelse(Sex &gt; 0, i.mated_with, NA),\n                    refractory_period_end = (t + refractory_period * baseline_mean_lifespan) * (Sex &lt; 1)),\n               on = .(Individual_ID)] \n  }\n  \n}\n\n# reproduction\n\n# check if a female can now produce offspring, either because they're previously mated and have secured a breeding site or because they already held a breeding site and have now mated\n\nnew_mated_breeder &lt;- population[Sex &gt; 0 & matings &gt; 0 & breeding &gt; 0 & reproduced &lt; 1, \n                                .(Individual_ID,\n                                  inbred_mating,\n                                  Female_genotype = Genotype,\n                                  Male_genotype = mated_with)]\n\nif(nrow(new_mated_breeder) &gt; 0) {\n  # add offspring to the population. Each mated female that holds a breeding site produces N offspring\n  offspring &lt;- \n    new_mated_breeder[inheritance_scheme, \n                      on = .(Female_genotype = Female_genotype,\n                             Male_genotype = Male_genotype), \n                      nomatch = NULL, allow.cartesian  = TRUE\n    ][, .SD[sample(.N, # I think this value is very occasionally zero, causing the sim to break\n                   size = N, \n                   prob = zygote_freq, \n                   replace = T)]\n    ][, Family_ID := .GRP + Family_ID_counter # assign these offspring to a new family \n    ][, .(Genotype, \n          Sex, \n          inbred_mating,\n          Family_ID)\n    ][, `:=`(mortality_rate = ifelse(inbred_mating &gt; 0, \n                                     1/(baseline_mean_lifespan + D), # the cost of inbreeding: D &lt;= 0\n                                     1/baseline_mean_lifespan), # outbred offspring mortality risk\n             birth_time = t,\n             breeding = 0,\n             matings = 0,\n             reproduced = 0,\n             mated_with = \"NA\",\n             refractory_period_end = t,\n             Individual_ID = .I + Individual_ID_counter,\n             inbred_mating = 0)]\n  \n  # bind the offspring table to the existing population table and update which females have reproduced \n  \n  population &lt;- rbindlist(list(population, offspring), use.names = TRUE\n  )[new_mated_breeder, reproduced := 1, on = .(Individual_ID)]\n  \n  # update the Individual_ID counter\n  Individual_ID_counter &lt;- max(population$Individual_ID)\n  Family_ID_counter &lt;- max(population$Family_ID) \n}\n\n\n# Calculate the frequency of the I allele, quit early if I fixes or goes extinct\n\n# calc allele freq if autosomal locus   \nif(chromosome == \"A\"){\n  prop_i &lt;-\n    (length(population$Genotype[str_detect(population$Genotype, heterozygous_genotype)]) + \n       2*length(population$Genotype[str_detect(population$Genotype, homozygous_genotype)]))/ (nrow(population)*2)\n}\n\n# calc allele freq if hemizygous locus: W, Y or cytoplasmic\nif(chromosome == \"W\" | chromosome == \"Y\" | chromosome == \"C\"){\n  prop_i &lt;-\n    (length(population$Genotype[str_detect(population$Genotype, hemizygous_genotype)])/ \n       length(population$Genotype[str_detect(population$Genotype, chromosome)]))\n}\n\n# calc allele freq if diploid in one sex and haploid in the other: X and Z\nif(chromosome == \"X\" | chromosome == \"Z\"){\n  prop_i &lt;-\n    if(hemizygous_genotype == \"X_IY_O\"){\n      (length(population$Genotype[str_detect(population$Genotype, heterozygous_genotype)]) + \n         2*length(population$Genotype[str_detect(population$Genotype, homozygous_genotype)]) +\n         length(population$Genotype[str_detect(population$Genotype, hemizygous_genotype)]))/ \n        (nrow(population[Sex &gt; 0])*2 + nrow(population[Sex &lt; 1]))}\n  else{\n    (length(population$Genotype[str_detect(population$Genotype, heterozygous_genotype)]) + \n       2*length(population$Genotype[str_detect(population$Genotype, homozygous_genotype)]) +\n       length(population$Genotype[str_detect(population$Genotype, hemizygous_genotype)]))/ \n      (nrow(population[Sex &lt; 1])*2 + nrow(population[Sex &gt; 0]))}\n}\n\n# this is a diagnostic to make sure the model is running well - it can be commented out when running the big simulation\n#prop_i_table &lt;- rbindlist(list(prop_i_table, list(t, prop_i, nrow(population))))\n\nprint(paste0(\"Population size = \", nrow(population),\n             \", time = \", round(t, 3)))\n\nif(prop_i &gt; 0.9 | prop_i &lt; 0.0001 | nrow(population) &lt; 1) keep_going &lt;- FALSE\n\n# Move t to next encounter\n\n# determining the next event\n\n# check when the next death occurs\n\nnext_death &lt;- rexp(n = 1, rate = sum(population[, mortality_rate]))\n\nwho_died &lt;- population[sample(.N, 1, prob = mortality_rate)]$Individual_ID \n\n# check when the next female-male encounter occurs\n\n# create the possible encounter list\n\nnumber_females &lt;- sum(population$Sex &gt; 0)\n\nencounter_possibilities &lt;- \n  CJ(Female_ID = population[Sex &gt; 0]$Individual_ID,\n     Male_ID = population[Sex &lt; 1]$Individual_ID)[, encounter_rate := v/number_females]\n\n# check the time\n\nnext_mating &lt;- rexp(n = 1, rate = sum(encounter_possibilities[, encounter_rate]))\n\nwhich_encounter &lt;- encounter_possibilities[sample(.N, 1, prob = encounter_rate)]\n\n# Initialize the timer t to the next encounter\n\nt &lt;- t + pmin(next_death, next_mating)  \n} finish_time &lt;- t final_pop_size = nrow(population)\n#prop_i_table\n# Print the simulation results #list( parameters[row, ] %&gt;% mutate(I_frequency = prop_i, finish_time = finish_time, final_pop_size = final_pop_size) %&gt;% select(-c(heterozygous_genotype, homozygous_genotype, hemizygous_genotype, number_mutants, baseline_mean_lifespan, N, time_end)) # population, #prop_i_table)\nparameters[row, ] %&gt;% mutate(I_frequency = prop_i, finish_time = finish_time, final_pop_size = final_pop_size) %&gt;% select(-c(heterozygous_genotype, homozygous_genotype, hemizygous_genotype, number_mutants, baseline_mean_lifespan, N, time_end)) #%&gt;% #write_csv(paste(“sim_results/row_”, row, chromosome, “.csv”, sep = ““)) }"
  }
]