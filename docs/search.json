[
  {
    "objectID": "flintham_logic_test.html",
    "href": "flintham_logic_test.html",
    "title": "Untitled",
    "section": "",
    "text": "Code\nK_m &lt;- 100\nK_f &lt;- 100\n\ns_m &lt;- 0.5\ns_f &lt;- 0.5\n\ntheta &lt;- 1\n\nz &lt;- -1\n\nb_m &lt;- 1\nb_f &lt;- 1\n\n\n\n\nCode\nK_m * (1 - s_m*(1 - (theta - z / (2*theta))^b_m))\n\n\n[1] 125\n\n\nCode\nK_f * (1 - s_f*(1 - (theta + z / (2*theta))^b_f))\n\n\n[1] 75\n\n\n\n\nCode\nmake_mating_table &lt;- function(gene_location){\n  \n  make_offspring &lt;- function(X, Y, type, zygote_freq, gene_location){\n    tibble(Female_genotype = X,\n           Male_genotype = Y,\n           type,\n           zygote_freq,\n           locus_type = gene_location)\n  }\n  \n  \n  # Set up the  possible mating duo types\n  \n  mating_types &lt;- \n      expand_grid(\n        mother = c(\"A1A1_A2A2.Female\",\n                   \"A1a1_A2A2.Female\",\n                   \"a1a1_A2A2.Female\",\n                   \"A1A1_A2a2.Female\",\n                   \"A1a1_A2a2.Female\",\n                   \"a1a1_A2a2.Female\",\n                   \"A1A1_a2a2.Female\",\n                   \"A1a1_a2a2.Female\",\n                   \"a1a1_a2a2.Female\"),\n        father = c(\"A1A1_A2A2.Male\",\n                   \"A1a1_A2A2.Male\",\n                   \"a1a1_A2A2.Male\",\n                   \"A1A1_A2a2.Male\",\n                   \"A1a1_A2a2.Male\",\n                   \"a1a1_A2a2.Male\",\n                   \"A1A1_a2a2.Male\",\n                   \"A1a1_a2a2.Male\",\n                   \"a1a1_a2a2.Male\"))\n     \n  \n  # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function\n  \n  # A1A1_A2A2 x A1A1_A2A2\n  \n  a_genotype_1 &lt;- c(\"A1A1_A2A2.Female\", \"A1A1_A2A2.Male\")\n  \n  # A1A1_A2A2 x A1a1_A2A2\n  \n  a_genotype_2 &lt;- c(\"A1A1_A2A2.Female\", \"A1A1_A2A2.Male\", \n                    \"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\")\n  \n  # A1A1_A2A2 x a1a1_A2A2\n  \n  a_genotype_3 &lt;- c(\"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\")\n  \n    # A1A1_A2A2 x A1A1_A2a2\n  \n  a_genotype_4 &lt;- c(\"A1A1_A2A2.Female\", \"A1A1_A2A2.Male\",\n                    \"A1A1_A2a2.Female\", \"A1A1_A2a2.Male\")\n  \n  # A1A1_A2A2 x A1a1_A2a2\n  \n  a_genotype_5 &lt;- c(\"A1A1_A2A2.Female\", \"A1A1_A2A2.Male\", \n                    \"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\",\n                    \"A1A1_A2a2.Female\", \"A1A1_A2a2.Male\", \n                    \"A1a1_A2a2.Female\", \"A1a1_A2a2.Male\")\n  \n  # A1A1_A2A2 x a1a1_A2a2\n  \n  a_genotype_6 &lt;- c(\"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\",\n                    \"A1a1_A2a2.Female\", \"A1a1_A2a2.Male\")\n  \n      # A1A1_A2A2 x A1A1_a2a2\n  \n  a_genotype_7 &lt;- c(\"A1A1_A2a2.Female\", \"A1A1_A2a2.Male\")\n  \n  # A1A1_A2A2 x A1a1_a2a2\n  \n  a_genotype_8 &lt;- c(\"A1A1_A2a2.Female\", \"A1A1_A2a2.Male\", \n                    \"A1a1_A2a2.Female\", \"A1a1_A2a2.Male\")\n  \n  # A1A1_A2A2 x a1a1_a2a2\n  \n  a_genotype_9 &lt;- c(\"A1a1_A2a2.Female\", \"A1a1_A2a2.Male\")\n  \n  \n    # A1a1_A2A2 x A1A1_A2A2\n  \n  a_genotype_10 &lt;- c(\"A1A1_A2A2.Female\", \"A1A1_A2A2.Male\",\n                    \"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\")\n  \n  # A1a1_A2A2 x A1a1_A2A2\n  \n  a_genotype_11 &lt;- c(\"A1A1_A2A2.Female\", \"A1A1_A2A2.Male\", \n                    \"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\",\n                    \"a1a1_A2A2.Female\", \"a1a1_A2A2.Male\")\n  \n  # A1a1_A2A2 x a1a1_A2A2\n  \n  a_genotype_12 &lt;- c(\"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\",\n                     \"a1a1_A2A2.Female\", \"a1a1_A2A2.Male\")\n  \n    # A1a1_A2A2 x A1A1_A2a2\n  \n  a_genotype_13 &lt;- c(\"A1A1_A2A2.Female\", \"A1A1_A2A2.Male\",\n                    \"A1A1_A2a2.Female\", \"A1A1_A2a2.Male\",\n                    \"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\",\n                    \"A1a1_A2a2.Female\", \"A1a1_A2a2.Male\")\n  \n  # A1a1_A2A2 x A1a1_A2a2\n  \n  a_genotype_5 &lt;- c(\"A1A1_A2A2.Female\", \"A1A1_A2A2.Male\", \n                    \"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\",\n                    \"A1A1_A2a2.Female\", \"A1A1_A2a2.Male\", \n                    \"A1a1_A2a2.Female\", \"A1a1_A2a2.Male\",\n                    \"a1a1_A2A2.Female\", \"a1a1_A2A2.Male\", \n                    \"a1a1_A2a2.Female\", \"a1a1_A2a2.Male\")\n  \n  # A1A1_A2A2 x a1a1_A2a2\n  \n  a_genotype_6 &lt;- c(\"A1a1_A2A2.Female\", \"A1a1_A2A2.Male\",\n                    \"A1a1_A2a2.Female\", \"A1a1_A2a2.Male\")\n  \n      # A1A1_A2A2 x A1A1_a2a2\n  \n  a_genotype_7 &lt;- c(\"A1A1_A2a2.Female\", \"A1A1_A2a2.Male\")\n  \n  # A1A1_A2A2 x A1a1_a2a2\n  \n  a_genotype_8 &lt;- c(\"A1A1_A2a2.Female\", \"A1A1_A2a2.Male\", \n                    \"A1a1_A2a2.Female\", \"A1a1_A2a2.Male\")\n  \n  # A1A1_A2A2 x a1a1_a2a2\n  \n  a_genotype_9 &lt;- c(\"A1a1_A2a2.Female\", \"A1a1_A2a2.Male\")\n  \n  \n  \n  \n  \n  \n  \n  # IO x IO\n  \n  a_genotype_4 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\", \n                    \"A_IA_O.Female\", \"A_IA_O.Male\", \n                    \"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  # IO x OO\n  \n  a_genotype_5 &lt;- c(\"A_IA_O.Female\", \"A_IA_O.Male\",\n                    \"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  # OO x OO\n  \n  a_genotype_6 &lt;- c(\"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n\n  # Now calculate the zygote frequencies for each cross\n  \n  # autosomal\n  \n  # even frequency of two offspring genotypes\n  \n  freq_2 &lt;- rep(0.5, 2)\n  \n  # even frequency between four offspring types\n  \n  freq_4 &lt;- rep(0.25, 4)\n  \n  # when there are 6 offspring genotypes\n  \n  freq_6 &lt;- c(0.125, 0.125,\n              0.25, 0.25,\n              0.125, 0.125)\n  \n  bind_rows(\n    list(\n      make_offspring(\"A_IA_I\", \"A_IA_I\", a_genotype_1, freq_2, \"autosomal\"),\n      make_offspring(\"A_IA_I\", \"A_IA_O\", a_genotype_2, freq_4, \"autosomal\"),\n      make_offspring(\"A_IA_I\", \"A_OA_O\", a_genotype_3, freq_2, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_IA_I\", a_genotype_2, freq_4, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_IA_O\", a_genotype_4, freq_6, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_OA_O\", a_genotype_5, freq_4, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_IA_I\", a_genotype_3, freq_2, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_IA_O\", a_genotype_5, freq_4, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_OA_O\", a_genotype_6, freq_2, \"autosomal\"),\n      \n      make_offspring(\"X_IX_I\", \"X_IY_I\", xy_genotype_1, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_IY_O\", xy_genotype_2, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_OY_I\", xy_genotype_3, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_OY_O\", xy_genotype_4, freq_2, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_IY_I\", xy_genotype_5, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_IY_O\", xy_genotype_6, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_OY_I\", xy_genotype_7, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_OY_O\", xy_genotype_8, freq_4, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_IY_I\", xy_genotype_9, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_IY_O\", xy_genotype_10, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_OY_I\", xy_genotype_11, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_OY_O\", xy_genotype_12, freq_2, \"XY\"),\n      \n      make_offspring(\"Z_IW_I\", \"Z_IZ_I\", zw_genotype_1, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_I\", \"Z_IZ_O\", zw_genotype_2, freq_4, \"ZW\"),\n      make_offspring(\"Z_IW_I\", \"Z_OZ_O\", zw_genotype_3, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_IZ_I\", zw_genotype_4, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_IZ_O\", zw_genotype_5, freq_4, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_OZ_O\", zw_genotype_6, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_IZ_I\", zw_genotype_7, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_IZ_O\", zw_genotype_8, freq_4, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_OZ_O\", zw_genotype_9, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_OZ_O\", zw_genotype_10, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_OZ_O\", zw_genotype_11, freq_4, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_OZ_O\", zw_genotype_12, freq_2, \"ZW\"),\n      \n      make_offspring(\"C_I\", \"CI\", c_genotype_1, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_I\", \"CO\", c_genotype_1, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_O\", \"CI\", c_genotype_2, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_O\", \"CO\", c_genotype_2, freq_2, \"cytoplasmic\")\n    )) %&gt;% \n    filter(locus_type == gene_location)\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "",
    "text": "Code\nlibrary(tidyverse) # for tidy style coding and plotting\nlibrary(pander) # for tables\nlibrary(kableExtra) # for scrolling tables\nlibrary(MetBrewer) # for colour palettes based upon artwork housed at the MET\nlibrary(MoMAColors) # for colour palettes based upon artwork housed at MoMA\nlibrary(wesanderson) # for colour palettes based on wes anderson movies\nlibrary(tidybayes) # for plotting distributions\nlibrary(stickylabeller) # labelling facets with strings in ggplot\nlibrary(patchwork) # for combining plots \nlibrary(geomtextpath) # for curved plot annotations\nlibrary(ggtext) # for markdown syntax in plot labels\nlibrary(patchwork) # for patching plots together\nlibrary(ggnewscale) # to reset scales in plots, allowing multiple fill arguments in ggplot\nlibrary(data.table) # for efficient handling of large dataframes\nlibrary(dtplyr) # for tidyverse functions that can be used on data tables"
  },
  {
    "objectID": "index.html#the-seminal-equation",
    "href": "index.html#the-seminal-equation",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "The seminal equation",
    "text": "The seminal equation\nTo model the inclusive fitness gained from an inbred mating, three components that contribute to fitness are required:\n\nThe number of offspring produced directly: \\(n\\)\nThe reduction in fitness (number of offspring) due to inbreeding: \\(-\\delta n\\)\nThe indirect fitness gain (number of offspring) due to inbreeding: \\(rn\\), where \\(r\\) is the relatedness coefficient\n\nPut together, the inclusive fitness from a single inbred mating is:\n\\[(1 + r)(1 - \\delta)n\\]\nwhile fitness from a single outbred mating is simply \\(n\\).\nWhen \\((1 + r)(1 - \\delta)n \\gt n\\) selection should favour a preference for inbreeding.\nSolving the inequality for \\(\\delta\\):\n\\[\\delta \\lt \\frac{r}{1 + r}\\] which for varying values of \\(r\\) looks like this:\n\n\nCode\ninbreeding_maximum_function &lt;- function(r){\n  r / (1 + r)}\n\n\nparameters &lt;- expand_grid(r = seq(from = 0, to = 1, by = 0.05),\n                          delta = seq(from = 0, to = 1, by = 0.05))\n\nr &lt;- parameters %&gt;% distinct(r)\n\ninbreeding_equilibria &lt;- \n  map_dfr(r, inbreeding_maximum_function) %&gt;% \n  rename(inbreeding_depression = r) %&gt;% \n  bind_cols(r)\n\ninbreeding_equilibria %&gt;% \n  ggplot(aes(x = r, y = inbreeding_depression)) +\n  geom_line(linewidth = 0.8) + \n  coord_cartesian(ylim = c(0, 1)) +\n  labs(x = '_r_, the relatedness coefficient',\n       y = ~delta~'(inbreeding depression)') +\n  scale_x_continuous(expand = c(0, 0.009)) + \n  scale_y_continuous(expand = c(0, 0)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        axis.title.x = element_markdown())\n\n\n\n\n\nCode\n# (prop fitness lost)\\n that can be tolerated\"\n\n\nThe parameter space above the curve shows where inbreeding avoidance should evolve, while the parameter space below the curve shows where inbreeding preference should evolve."
  },
  {
    "objectID": "index.html#accounting-for-sex-differences-in-genetic-architecture",
    "href": "index.html#accounting-for-sex-differences-in-genetic-architecture",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Accounting for sex differences in genetic architecture",
    "text": "Accounting for sex differences in genetic architecture\nAs stated above, inclusive fitness in the absence of inbreeding depression is \\((1 + r)n\\). Here \\(r\\) represents the correlation between genotypes carried by interacting females and males, under the implicit assumption that loci appear equally in both sexes. However, given that there is sexual dimorphism in genetic architecture for many taxa, \\(r\\) does not sufficiently represent the correlation between genotypes for all loci.\nTo delineate differences in the effect of \\(r\\) for different regions of the genome, we multiply \\(r\\) with a new variable \\(a\\), the probability that a locus present in one sex is also present in the gametes produced by the other. Unlike \\(r\\) which is relative to the population mean relatedness, \\(a\\) is expressed as an absolute value ranging from 0 to 1.\nThe indirect component of fitness accrued by from an inbred mating becomes\n\\[ran\\]\nand inclusive fitness from an inbreeding event becomes\n\\[(1 + ra)(1 - \\delta )n\\]\nTaking an allele found at a diploid autosomal locus as an example, all of the gametes produced by a relative possess this locus, where they could potentially carry alleles identical by descent. In this case \\(a = 1\\) and the indirect component of inclusive fitness is dictated solely by \\(r\\). The results for this autosomal scenario are presented in Parker (1979), Kokko and Ots (2006) and others who have explored this topic. In contrast, an inbreeding preference allele present at a locus on a Y or W chromosome has no opportunity to propagate any alleles identical by descent through inbreeding, as these chromosomes are not carried by the gametes of the opposite sex mating partner. In this case \\(a = 0\\). However, as inbreeding depression is a result of homozygosity for deleterious recessive alleles throughout the genome, the costs of inbreeding depression are born by all alleles carried by the individual. Conflict over the expression of inbreeding preference between alleles present on autosomes and those present on hemizygous sex chromosomes is immediately clear.\nX- or Z-linked loci present an interesting intermediate case, with sex-specific values for \\(a\\). When the inbreeding locus is carried by the sex with homozygous sex chromosomes, \\(a\\) is half that of autosomal loci, whereas it does not depart from the autosomal case when the locus is found within the hemizygous sex. Using loci on the X as an example, those present in a XX female are only found in ~50% of a interacting males gametes, as the remaining 50% carry Y chromosomes (assuming an even primary sex ratio). When an X-linked locus is found in a male, an interacting female’s gametes all carry X chromosomes and \\(a = 1\\).\nThe X/Z situation is made additionally complex because there is an element of frequency dependence to the kin selected benefits. When an inbreeding allele on an autosome is rare, then the chance of a relative carrying two copies is low, whereas when the allele is common, this chance is much higher. Rarity therefore leads to similar fitness outcomes for autosomal and X/Z linked alleles (when present in the hemizygous sex), while commonality of the allele likely roughly equates to the conflicting situation outlined in the above paragraph. However, frequency dependence might not as relevant as I initially expected, because the inbreeding allele becomes very common quickly within families, even whilst rare across the population (first proposed in Fisher, 1930).\nTable 1. Values of the parameter \\(a\\) for different regions of the genome. \\(a\\) is the one-way probability that a locus carried by one individual is found within the gametes of an opposite sex individual. Note that cytoplasmic chromosomes are assumed to have exclusive maternal inheritance.\n\n\nCode\nx &lt;- \n  c(1, # autosomes, X chromosome males or Z chromosome females, haplodiploid both sexes when producing females \n    0, # Y or W chromosome\n    0.5 # X chromosome females or Z chromosome males\n  )\n\ntibble(`Prob. that opposite sex gametes carry focal locus` = c(1, 0.5, 0),\n       `Relevant cases` = c(\"Autosomes in either sex, X chromosomes in males, Z chromosomes in females, chromosomes in haplodiploids of either sex when reproducing sexually, cytoplasmic chromosomes in males\",\n                            \"X chromosomes in females, Z chromosomes in males\",\n                            \"Y chromosomes in males, W chromosomes in females, cytoplasmic chromosomes in females\")) %&gt;% \n  pander(split.cell = 20, split.table = Inf)\n\n\n\n\n\n\n\n\n\nProb. that opposite sex gametes carry focal locus\nRelevant cases\n\n\n\n\n1\nAutosomes in either sex, X chromosomes in males, Z chromosomes in females, chromosomes in haplodiploids of either sex when reproducing sexually, cytoplasmic chromosomes in males\n\n\n0.5\nX chromosomes in females, Z chromosomes in males\n\n\n0\nY chromosomes in males, W chromosomes in females, cytoplasmic chromosomes in females\n\n\n\n\n\nOnce again we can find the condition where breeding with a relative returns greater fitness than an inbreeding avoidance strategy, this time accounting for genetic architecture\n\\[\\delta \\lt \\frac{ra}{1 + ra}\\]\nIgnoring frequency dependence for now, we can plot the new slopes produced by varying \\(r\\) and \\(a\\):\n\n\nCode\ninbreeding_maximum_function_2 &lt;- function(r, a){\n  (r*a / (r*a + 1))}\n\n\nparameters_2 &lt;- expand_grid(r = seq(from = 0, to = 1, by = 0.01),\n                          a = c(0, 0.5, 1))\n\ninbreeding_equilibria_2 &lt;- \n  map2_dfr(parameters_2 %&gt;% select(r), \n           parameters_2 %&gt;% select(a), \n           inbreeding_maximum_function_2) %&gt;% \n  rename(inbreeding_depression = r) %&gt;% \n  bind_cols(parameters_2)\n\ninbreeding_equilibria_2 %&gt;% \n  mutate(a = case_when(a == 0 ~ \"a = 0\",\n                       a == 0.5 ~ \"a = 0.5\",\n                       a == 1 ~ \"a = 1\")) %&gt;% \n  mutate(a = as.factor(a)) %&gt;% \n  ggplot(aes(x = r, y = inbreeding_depression, linetype = a, label = a)) +\n  geom_textline(linewidth = 0.8, size = 5) + \n # scale_colour_manual(values = c(\"0\" = met.brewer(\"Kandinsky\", 4)[1], \"0.5\" =  met.brewer(\"Kandinsky\", 4)[2], \"1\" = met.brewer(\"Kandinsky\", 4)[3])) +\n  coord_cartesian(ylim = c(0, 1)) +\n  labs(x = '_r_, the relatedness coefficient',\n       y = ~delta~'(inbreeding depression)',\n       linetype = expression(~italic(a)~', the intersex correlation between loci')) +\n  scale_x_continuous(expand = c(0.009, 0)) + \n  scale_y_continuous(expand = c(0.025, 0)) +\n  theme_bw() +\n  theme(text = element_text(size = 18),\n        legend.position = \"none\",\n        axis.title.x = element_markdown())\n\n\n\n\n\n\\(~\\)"
  },
  {
    "objectID": "index.html#differences-between-the-sexes-beyond-genetic-architecture",
    "href": "index.html#differences-between-the-sexes-beyond-genetic-architecture",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Differences between the sexes beyond genetic architecture",
    "text": "Differences between the sexes beyond genetic architecture\nParker’s seminal equations:\nIn his 1979 book chapter, Parker considered the inclusive fitness results of breeding with a relative and identified that females and males should have different tolerances for inbreeding depression. The key departure from the unlimited polygyny case presented in the above equations is that a cost to future reproductive success is included for males, i.e. due to finite sperm production, parental care, or harmful mating behaviour such as sexual cannibalism.\nFor males, Parker found that selection would favour inbreeding with a sister (full-sib) who could otherwise outcross when:\n\\[n(1 - \\delta) + rn(1- \\delta) - cn \\gt rn\\]\nthe first term is the direct number of alleles propagated, the second term is the indirect number of alleles propagated (note that this is weighted by relatedness), the third term is the direct number of alleles that were not directly propagated by the male through outcrossing, and the final opposing term is the number of alleles that would’ve been transmitted had his sister outcrossed (and he forgone mating).\n\\(c\\) is the cost of the present mating, relative to what is lost for a female. This can be considered a ratio of parental investment. When \\(c = 1\\) parental investment in the current bout of reproduction is even between the sexes. Alternatively, if males only contribute cheaply produced sperm to an incestuous mating, the cost of mating is likely very small relative to females i.e. \\(c ~ 0\\).\nWe add the \\(a\\) variable to the equation and letting \\(n = 1\\), simplify to\n\\[(1-\\delta) + ra(1-\\delta) - c \\gt ra\\]\nWe can again find the condition where breeding with a relative returns greater fitness than an inbreeding avoidance strategy:\n\\[\\delta_{male} = \\frac{1 - c}{1 + ra}\\]\nParker then modelled the condition for monandrous females to prefer incestuous matings when also presented with an outcrossing opportunity.\n\\[n(1 - \\delta) + rn(1-\\delta) - crn \\gt n\\]\nwhich we can write as\n\\[(1-\\delta) + ra(1-\\delta) - rac \\gt 1\\]\nthe inbreeding depression threshold is\n\\[\\delta_{female} = \\frac{ra - rac}{1 + ra}\\]\nNote that when \\(c = 0\\), this is equivalent to the \\(\\delta\\) threshold found in the single mating case.\nPlot the relationship between \\(r\\) and \\(\\delta\\) for several values of \\(c\\) and \\(a\\)\n\n\nCode\nParker_cost_data &lt;- \n  expand_grid(r = seq(from = 0, to = 1, by = 0.01),\n              a = c(0, 0.5, 1),\n              c = c(0, 0.5, 0.9),\n              Sex = c(\"Female\", \"Male\")) %&gt;% \n  mutate(inbreeding_depression = case_when(Sex == \"Female\" ~ (r*a - r*a*c) / (r*a + 1),\n                                           Sex == \"Male\" ~ (1 - c) / (r*a + 1)))\n\n  Parker_cost_data %&gt;% \n  mutate(a = as.factor(a)) %&gt;% \n  ggplot(aes(x = r, y = inbreeding_depression, linetype = a, colour = Sex)) +\n  geom_line(linewidth = 0.9) + \n  scale_colour_manual(values = c(\"Female\" = met.brewer(\"Peru1\", 6)[2], \"Male\" =  met.brewer(\"Peru1\", 6)[3])) +\n  coord_cartesian(ylim = c(0, 1)) +\n  labs(y = expression(delta), \n       x = expression(italic(\"r\")),\n       linetype = expression(italic(\"a\"))) +\n  scale_x_continuous(expand = c(0.009, 0)) + \n  scale_y_continuous(expand = c(0.01, 0)) +\n  facet_wrap(~c, nrow = 3, labeller = label_glue('Male mating investment (c): {c}')) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        strip.background = element_rect(fill = \"Aliceblue\", linewidth = .5))"
  },
  {
    "objectID": "index.html#plotting-sexual-and-intragenomic-conflicts",
    "href": "index.html#plotting-sexual-and-intragenomic-conflicts",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Plotting sexual and intragenomic conflicts",
    "text": "Plotting sexual and intragenomic conflicts\n\n\nCode\nresolution &lt;- 200\n\nparameters &lt;- \n  expand_grid(\n    r = seq(0, 1, length = resolution),\n    a = c(0, 0.5, 1),\n    c = c(0, 0.25, 0.5, 0.75, 1),\n    D = seq(0, 1, length = resolution)) # D represents inbreeding depression)\n\nresults &lt;-\n  parameters %&gt;% \n  mutate(female_inbreeding_fitness = (1-D) + (r*a*(1-D)) - (r*a*c),\n         male_inbreeding_fitness = (1-D) + r*a*(1-D) - c,\n         female_outbreeding_fitness = 1,\n         male_outbreeding_fitness = r*a,\n         female_fitness_contrast = female_inbreeding_fitness - female_outbreeding_fitness, # this is close to a selection differential\n         male_fitness_contrast = male_inbreeding_fitness - male_outbreeding_fitness)\n\n\n\nWhen is inbreeding favoured in each sex?\nIn the figure below, the dashed lines indicate the level of inbreeding depression that can be tolerated for a given value of \\(r\\). The plot is split into panels by \\(c\\), the cost of mating for males relative to females and \\(a\\), the probability that a locus present in one sex is also present in the gametes produced by the other.\n\n\nCode\npal1 &lt;- met.brewer(\"OKeeffe1\", n=100, direction = -1)\npal2 &lt;- met.brewer(\"Hiroshige\", n=50, direction = -1)\n#pal2 &lt;- moma.colors(\"Avedon\", n = 50, direction = 1)\n\noranges &lt;- c(\"#ffe6b7\", \"#ffd06f\", \"#f7aa58\", \"#ef8a47\", \"#e76254\") \n\nblues &lt;- c(\"#aadce0\", \"#72bcd5\", \"#528fad\", \"#376795\", \"#1e466e\")\n\n# Lowest colour for all gradients\ngradient_base &lt;- oranges[1]\n\ngradient_max &lt;- oranges[5]\n\n# Create a list of gradients for each colour 2 to 10 over five steps from \n# gradient_base grey (low) to colour (high)\nmy_gradient &lt;- colorRampPalette(c(gradient_base, gradient_max))(50)\n  \nFemale_plot &lt;-\n  results %&gt;%\n  filter(c != 0.25, c != 0.75, c != 1) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = female_fitness_contrast)) + \n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-125, -100, -75, -50, -25, 25, 50, 75, 100, 125)) +\n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  #geom_line(data = female_inbreeding_equilibria, aes(x = r, y = D),\n   #         linetype = 3, alpha = 0.5) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1.5, -0.75, 0, 0.75, 1.5), limits = c(-2, 2)) +\n  facet_wrap(c ~ a, \n             scales = \"free\", nrow = 2, strip.position = c(\"top\"),\n             labeller = label_glue('c = {`c`}, a = {`a`}')) +\n  labs(x = '_r_, the relatedness coefficient',\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       title = \"A. Alleles present in females\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", linewidth = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        axis.title.x = element_markdown(),\n        plot.title = element_text(hjust = 0.5))\n\n\nMale_plot &lt;-\n  results %&gt;%\n  filter(c != 0.25, c != 0.75, c != 1) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = male_fitness_contrast)) + \n  stat_contour(aes(z = male_fitness_contrast*100), colour = \"black\", binwidth = 25,\n              breaks = c(-125, -100, -75, -50, -25, 25, 50, 75, 100, 125)) +\n  stat_contour(aes(z = male_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  #geom_line(data = female_inbreeding_equilibria, aes(x = r, y = D),\n   #         linetype = 3, alpha = 0.5) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1.5, -0.75, 0, 0.75, 1.5), limits = c(-2, 2)) +\n  facet_wrap(c ~ a, \n             scales = \"free\", nrow = 2, strip.position = c(\"top\"),\n             labeller = label_glue('c = {`c`}, a = {`a`}')) +\n  labs(x = '_r_, the relatedness coefficient',\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       title = \"B. Alleles present in males\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", linewidth = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        axis.title.x = element_markdown(),\n        plot.title = element_text(hjust = 0.5))\n\nFemale_plot\n\n\n\n\n\nCode\nMale_plot\n\n\n\n\n\n\n\nWhen is there evolutionary conflict over inbreeding?\nTo quantify conflict in its various forms we use a version of the I index presented in Innocenti and Morrow (2010).\nPanels in columns A and B show the parameter space where conflict is expected between alleles on different chromosomes - so called inter-chromosomal conflict.\n\n\nCode\nIntragenomic_conflict_females &lt;-\n  results %&gt;%\n  select(1:4, female_fitness_contrast) %&gt;%\n  pivot_wider(names_from = a, values_from = female_fitness_contrast) %&gt;% \n  #mutate(`Autosome - X` = `1` - `0.5`,\n   #      `Autosome - Z` = 0,\n    #     `Autosome - W & Z - W` = `1` - `0`) %&gt;% \n  mutate(`Autosome vs X` = `1` * `0.5` / sqrt(((`1`)^2 + (`0.5`)^2)/2),\n         `Autosome vs Z` = `1` * `1` / sqrt(((`1`)^2 + (`1`)^2)/2),\n         `Autosome & Z vs W` = `1` * `0` / sqrt(((`1`)^2 + (`0`)^2)/2)) %&gt;% \n  pivot_longer(cols = 7:9, names_to = \"contrast\", values_to = \"Evolutionary_conflict\") %&gt;% \n  mutate(relationship = case_when(\n    contrast == \"Autosome vs X\" & `1` &gt; 0 & `0.5` &gt; 0 ~\n      \"Inbreeding favoured in both contexts\",\n    contrast == \"Autosome vs X\" & `1` &lt; 0 & `0.5` &lt; 0 ~\n       \"Inbreeding deleterious in both contexts\",\n    \n    contrast == \"Autosome vs Z\" & `1` &gt; 0 ~\n      \"Inbreeding favoured in both contexts\",\n    contrast == \"Autosome vs Z\" & `1` &lt; 0 ~\n       \"Inbreeding deleterious in both contexts\",\n    \n    contrast == \"Autosome & Z vs W\" & `1` &gt; 0 & `0` &gt; 0 ~\n      \"Inbreeding favoured in both contexts\",\n    contrast == \"Autosome & Z vs W\" & `1` &lt; 0 & `0` &lt; 0 ~\n       \"Inbreeding deleterious in both contexts\",\n    `0` == 0 & `0.5` == 0 & `1` == 0 ~ \"Inbreeding deleterious in both contexts\",  \n    .default = \"Intragenomic conflict\")) %&gt;% \n  mutate(contrast = fct_relevel(contrast, \"Autosome vs X\", \"Autosome vs Z\",\n                                \"Autosome & Z vs W\")) %&gt;% \n  filter(c == 0)  # remove if we want more c values\n\nIntragenomic_conflict_males &lt;-\n  results %&gt;%\n  select(1:4, male_fitness_contrast) %&gt;%\n  pivot_wider(names_from = a, values_from = male_fitness_contrast) %&gt;% \n  #mutate(`Autosome - X` = 0,\n   #      `Autosome - Z` = `1` - `0.5`,\n    #     `Autosome - Y & X - Y` = `1` - `0`) %&gt;%\n  mutate(`X vs Autosome` = `1` * `1` / sqrt(((`1`)^2 + (`1`)^2)/2),\n         `Z vs Autosome` = `1` * `0.5` / sqrt(((`1`)^2 + (`0.5`)^2)/2),\n         `Y vs Autosome & X` = `1` * `0` / sqrt(((`1`)^2 + (`0`)^2)/2)) %&gt;% \n  pivot_longer(cols = 7:9, names_to = \"contrast\", values_to = \"Evolutionary_conflict\") %&gt;% \n  mutate(relationship = case_when(\n    contrast == \"X vs Autosome\" & `1` &gt; 0 ~\n      \"Inbreeding favoured in both contexts\",\n    contrast == \"X vs Autosome\" & `1` &lt; 0 ~\n      \"Inbreeding deleterious in both contexts\",\n    \n    contrast == \"Z vs Autosome\" & `1` &gt; 0 & `0.5` &gt; 0 ~\n      \"Inbreeding favoured in both contexts\",\n    contrast == \"Z vs Autosome\" & `1` &lt; 0 & `0.5` &lt; 0 ~\n      \"Inbreeding deleterious in both contexts\",\n    \n    contrast == \"Y vs Autosome & X\" & `1` &gt; 0 & `0` &gt; 0 ~\n      \"Inbreeding favoured in both contexts\",\n    contrast == \"Y vs Autosome & X\" & `1` &lt; 0 & `0` &lt; 0 ~\n      \"Inbreeding deleterious in both contexts\",\n    `0` == 0 & `0.5` == 0 & `1` == 0 ~ \"Inbreeding deleterious in both contexts\",  \n    .default = \"Intragenomic conflict\")) %&gt;% \n  mutate(contrast = fct_relevel(contrast, \"X vs Autosome\", \"Z vs Autosome\",\n                                \"Y vs Autosome & X\")) %&gt;% \n  filter(c == 0) # remove if we want more c values\n    \n\nmake_genomic_conflict_plot &lt;- \n  function(data, enter_title, colour_pal){\n    data %&gt;% \n      ggplot(aes(x = r, y = D)) +\n      geom_blank() +\n      geom_tile(data = data %&gt;% filter(relationship == \"Intragenomic conflict\"),\n                aes(fill = Evolutionary_conflict*-1)) + \n      #geom_tile(data = data,\n      #         aes(fill = Evolutionary_conflict)) + \n      scale_fill_gradientn(colours = colour_pal, limits = c(0, 0.6), #na.value = \"white\",\n                           breaks = c(0, 0.6),\n                           labels = c(\"Weak conflict\", \"Strong conflict\")) +\n      labs(fill = \"Evolutionary conflict\") +\n      new_scale_fill() +\n      geom_tile(data = data %&gt;% filter(relationship != \"Intragenomic conflict\"),\n                aes(fill = relationship), alpha = 0.75) +\n      scale_fill_manual(values = c(\"#fbe6c5\", \"#d2fbd4\"), \n                        labels = c(\"Inbreeding deleterious\\nin both contexts\", \n                               \"Inbreeding favoured\\nin both contexts\")) +\n      stat_contour(aes(z = Evolutionary_conflict*-1), colour = \"black\", binwidth = 25,\n                   breaks = c(0, 0.2, 0.4, 0.6)) +\n      facet_wrap(~contrast, nrow = 3,\n                 scales = \"free\", strip.position = c(\"top\"),\n                 labeller = label_glue('{`contrast`}')) +\n      labs(x = '_r_ (relatedness coefficient)',\n           y = ~delta~'(inbreeding depression)',\n           fill = \"Evolutionary concordance\",\n           title = enter_title) +\n      scale_x_continuous(expand = c(0, 0)) + \n      scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n      theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n            panel.grid.minor = element_blank(),\n            strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n            axis.title.x = element_markdown(),\n            plot.title = element_text(hjust = 0.5, size = 10))\n  }\n\nicf &lt;- make_genomic_conflict_plot(Intragenomic_conflict_females, \"A. Inter-chromosomal conflict in females\", oranges)\nicm &lt;- make_genomic_conflict_plot(Intragenomic_conflict_males, \"B. Inter-chromosomal conflict in males\", oranges)\n\n\nPanels in column C show where loci are expected to be under intra-chromosomal sexual conflict over inbreeding preference. In regions of sexual conflict, inbreeding preference is always favoured in males, but has negative fitness consequences if expressed by females (assuming that males invest less into mating than females). Note that intra-chromosomal conflict encompasses both the intra- and inter-locus forms of sexual conflict.\n\n\nCode\nautosomal_data &lt;-\n  results %&gt;%\n  filter(a == 1, c != 1, c != 0.25) %&gt;% \n  #mutate(Evolutionary_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;%\n  mutate(Evolutionary_conflict = female_fitness_contrast * male_fitness_contrast / \n           sqrt(((female_fitness_contrast)^2 + (male_fitness_contrast)^2)/2)) %&gt;% \n  mutate(relationship = \n           case_when(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0 \n                     ~ \"Sexual conflict\",\n                     female_fitness_contrast &lt; 0 & male_fitness_contrast &lt; 0 \n                     ~ \"Inbreeding deleterious in both contexts\",\n                     female_fitness_contrast &gt; 0 & male_fitness_contrast &gt; 0 \n                     ~ \"Inbreeding favoured in both contexts\"),\n         Location = \"Autosome\") \n  \n\n\nX_data &lt;- \n  results %&gt;% \n  filter(a == 0.5, c != 1, c != 0.25) %&gt;%  \n  select(1:4, contains(\"female\")) %&gt;% \n  rename(a_female = a) %&gt;% # this step makes the join work as intended\n  left_join(\n    results %&gt;% \n      filter(a == 1, c != 1, c != 0.25) %&gt;% \n      select(1:4, starts_with(\"male\")) %&gt;% \n      rename(a_male = a) # this step makes the join work as intended\n  ) %&gt;%\n  #mutate(Evolutionary_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;% \n  mutate(Evolutionary_conflict = female_fitness_contrast * male_fitness_contrast / \n           sqrt(((female_fitness_contrast)^2 + (male_fitness_contrast)^2)/2)) %&gt;% \n  mutate(relationship = \n           case_when(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0 \n                     ~ \"Sexual conflict\",\n                     female_fitness_contrast &lt; 0 & male_fitness_contrast &lt; 0 \n                     ~ \"Inbreeding deleterious in both contexts\",\n                     female_fitness_contrast &gt; 0 & male_fitness_contrast &gt; 0 \n                     ~ \"Inbreeding favoured in both contexts\"),\n         Location = \"X\")\n\nZ_data &lt;-\n  results %&gt;% \n  filter(a == 1, c != 1, c != 0.25) %&gt;%  \n  select(1:4, contains(\"female\")) %&gt;% \n  rename(a_female = a) %&gt;% \n  left_join(\n    results %&gt;% \n      filter(a == 0.5, c != 1, c != 0.25) %&gt;% \n      select(1:4, starts_with(\"male\")) %&gt;% \n      rename(a_male = a)\n  ) %&gt;% \n  #mutate(Evolutionary_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;%\n  mutate(Evolutionary_conflict = female_fitness_contrast * male_fitness_contrast / \n           sqrt(((female_fitness_contrast)^2 + (male_fitness_contrast)^2)/2)) %&gt;% \n  mutate(relationship = \n           case_when(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0 \n                     ~ \"Sexual conflict\",\n                     female_fitness_contrast &lt; 0 & male_fitness_contrast &lt; 0 \n                     ~ \"Inbreeding deleterious in both contexts\",\n                     female_fitness_contrast &gt; 0 & male_fitness_contrast &gt; 0 \n                     ~ \"Inbreeding favoured in both contexts\"),\n         Location = \"Z\")\n\nplotting_data &lt;- bind_rows(autosomal_data, X_data, Z_data) %&gt;% filter(c == 0)\n\nSexual_conflict_plot &lt;-\n  plotting_data %&gt;%\n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_tile(data = plotting_data %&gt;% filter(relationship == \"Sexual conflict\"),\n            aes(fill = Evolutionary_conflict*-1)) + \n  #scale_fill_gradientn(colours = pal2, limits = c(-1.2, 1.1), #na.value = \"white\",\n   #                    labels = c(\"Strong conflict, female (+)\", -0.5, \n    #                              \"No conflict\", 0.5, \"Strong conflict, male (+)\")) +\n  scale_fill_gradientn(colours = oranges, limits = c(0, 0.6), #na.value = \"white\",\n                       breaks = c(0, 0.6),\n                       labels = c(\"Weak conflict\", \"Strong conflict\")) +\n  labs(fill = \"Evolutionary conflict\") +\n  new_scale_fill() +\n  geom_tile(data = plotting_data %&gt;% filter(relationship != \"Sexual conflict\"),\n            aes(fill = relationship), alpha = 0.75) +\n  scale_fill_manual(values = c(\"#fbe6c5\", \"#d2fbd4\"), \n                    labels = c(\"Inbreeding deleterious\\nin both contexts\", \n                               \"Inbreeding favoured\\nin both contexts\")) +\n  stat_contour(aes(z = Evolutionary_conflict*-1), colour = \"black\", binwidth = 25,\n                   breaks = c(0, 0.2, 0.4, 0.6)) +\n  facet_wrap(~Location, nrow = 3,\n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('{`Location`}')) +\n  labs(x = '_r_ (relatedness coefficient)',\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Evolutionary concordance\",\n       title = \"C. Intra-chromosomal sexual conflict\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        axis.title.x = element_markdown(),\n        plot.title = element_text(hjust = 0.5, size = 10))"
  },
  {
    "objectID": "index.html#make-figure-1",
    "href": "index.html#make-figure-1",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Make Figure 1",
    "text": "Make Figure 1\n\n\nCode\nicf + icm + Sexual_conflict_plot + plot_layout(guides = \"collect\")"
  },
  {
    "objectID": "index.html#build-a-mating-table",
    "href": "index.html#build-a-mating-table",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Build a mating table",
    "text": "Build a mating table\nSomething to think about is how we set genetics to affect the expression of inbreeding tolerance/preference. Things that matter include:\n\ndo we consider inbreeding expression as the additive result of multiple loci on different chromosomes, or do we consider each case separately. Probably not this\nis inbreeding expression binary, a threshold trait or a quantitative, normally distributed trait. The latter would allow us to model evolution towards some maximum. The former cases are simpler to code (particularly the first case) but still allow us to answer a very similar question. I have this as an additive case - being heterozygous leads to expression of inbreeding preference half of the time.\n\n\n\nCode\nmake_mating_table &lt;- function(gene_location){\n  \n  make_offspring &lt;- function(X, Y, type, zygote_freq, gene_location){\n    tibble(Female_genotype = X,\n           Male_genotype = Y,\n           type,\n           zygote_freq,\n           locus_type = gene_location)\n  }\n  \n  \n  # Set up the  possible mating duo types\n  \n  #mating_types &lt;- \n   # bind_rows(\n      # autosomal\n    #  expand_grid(\n     #   mother = c(\"A_IA_I.Female\",\n      #             \"A_IA_O.Female\",\n       #            \"A_OA_O.Female\"),\n        #father = c(\"A_IA_I.Male\",\n         #          \"A_IA_O.Male\",\n          #         \"A_OA_O.Male\")) %&gt;% \n        #mutate(locus_type = \"autosomal\"),\n      # XY (both can encode inbreeding but they're expressed independently)\n      #expand_grid(\n       # mother = c(\"X_IX_I.Female\",\n        #           \"X_IX_O.Female\",\n         #          \"X_OX_O.Female\"),\n        #father = c(\"X_IY_I.Male\",\n         #          \"X_IY_O.Male\",\n          #         \"X_OY_I.Male\",\n           #        \"X_OY_O.Male\")) %&gt;% \n        #mutate(locus_type = \"XY\"),\n      # ZW (as per the XY case)\n     # expand_grid(\n      #  mother = c(\"Z_IW_I.Female\",\n       #            \"Z_IW_O.Female\",\n        #           \"Z_OW_I.Female\",\n         #          \"Z_OW_O.Female\"),\n        #father = c(\"Z_IZ_I.Male\",\n         #          \"Z_IZ_O.Male\",\n          #         \"Z_OZ_O.Male\")) %&gt;% \n        #mutate(locus_type = \"ZW\"),\n      # cytoplasmic\n      #expand_grid(\n       # mother = c(\"C_I.Female\",\n        #           \"C_O.Female\"),\n        #father = c(\"C_I.Male\",\n         #          \"C_O.Male\")) %&gt;% \n        #mutate(locus_type = \"cytoplasmic\")\n    #) %&gt;% \n    #mutate(locus_type = gene_location)\n  \n  # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function\n  \n  # autosomal\n  \n  # II x II\n  \n  a_genotype_1 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\")\n  \n  # II x IO\n  \n  a_genotype_2 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\", \n                    \"A_IA_O.Female\", \"A_IA_O.Male\")\n  \n  # II x OO\n  \n  a_genotype_3 &lt;- c(\"A_IA_O.Female\", \"A_IA_O.Male\")\n  \n  # IO x IO\n  \n  a_genotype_4 &lt;- c(\"A_IA_I.Female\", \"A_IA_I.Male\", \n                    \"A_IA_O.Female\", \"A_IA_O.Male\", \n                    \"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  # IO x OO\n  \n  a_genotype_5 &lt;- c(\"A_IA_O.Female\", \"A_IA_O.Male\",\n                    \"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  # OO x OO\n  \n  a_genotype_6 &lt;- c(\"A_OA_O.Female\", \"A_OA_O.Male\")\n  \n  # XY\n  \n  \n  # II x IY_I\n  \n  xy_genotype_1 &lt;- c(\"X_IX_I.Female\", \"X_IY_I.Male\")\n  \n  # II x IY_O\n  \n  xy_genotype_2 &lt;- c(\"X_IX_I.Female\", \"X_IY_O.Male\")\n  \n  # II x OY_I\n  \n  xy_genotype_3 &lt;- c(\"X_IX_O.Female\", \"X_IY_I.Male\")\n  \n  # II x OY_O\n  \n  xy_genotype_4 &lt;- c(\"X_IX_O.Female\", \"X_IY_O.Male\")\n  \n  # IO x IY_I\n  \n  xy_genotype_5 &lt;- c(\"X_IX_I.Female\", \"X_IY_I.Male\",\n                     \"X_IX_O.Female\", \"X_OY_I.Male\")\n  \n  # IO x IY_O\n  \n  xy_genotype_6 &lt;- c(\"X_IX_I.Female\", \"X_IY_O.Male\", \n                     \"X_IX_O.Female\", \"X_OY_O.Male\")\n  \n  # IO x OY_I\n  \n  xy_genotype_7 &lt;- c(\"X_IX_O.Female\", \"X_IY_I.Male\",\n                     \"X_OX_O.Female\", \"X_OY_I.Male\")\n  \n  # IO x OY_O\n  \n  xy_genotype_8 &lt;- c(\"X_IX_O.Female\", \"X_IY_O.Male\",\n                     \"X_OX_O.Female\", \"X_OY_O.Male\")\n  \n  # OO x IY_I\n  \n  xy_genotype_9 &lt;- c(\"X_IX_O.Female\", \"X_OY_I.Male\")\n  \n  # OO x IY_O\n  \n  xy_genotype_10 &lt;- c(\"X_IX_O.Female\", \"X_OY_O.Male\")\n  \n  # OO x OY_I\n  \n  xy_genotype_11 &lt;- c(\"X_OX_O.Female\", \"X_OY_I.Male\")\n  \n  # OO x OY_O\n  \n  xy_genotype_12 &lt;- c(\"X_OX_O.Female\", \"X_OY_O.Male\")\n  \n  # ZW\n  \n  # IW_I x II\n  \n  zw_genotype_1 &lt;- c(\"Z_IZ_I.Male\", \"Z_IW_I.Female\")\n  \n  # IW_I x IO\n  \n  zw_genotype_2 &lt;- c(\"Z_IZ_I.Male\", \"Z_IZ_O.Male\", \n                     \"Z_IW_I.Female\", \"Z_OW_I.Male\")\n  \n  # IW_I x OO\n  \n  zw_genotype_3 &lt;- c(\"Z_IZ_O.Male\", \"Z_OW_I.Female\")\n  \n  # IW_O x II\n  \n  zw_genotype_4 &lt;- c(\"Z_IZ_I.Male\", \"Z_IW_O.Female\")\n  \n  # IW_O x IO\n  \n  zw_genotype_5 &lt;- c(\"Z_IZ_I.Male\", \"Z_IZ_O.Male\",\n                     \"Z_IW_O.Female\", \"Z_OW_O.Female\")\n  \n  # IW_O x OO\n  \n  zw_genotype_6 &lt;- c(\"Z_IZ_O.Male\", \"Z_OW_O.Female\")\n  \n  # OW_I X II\n  \n  zw_genotype_7 &lt;- c(\"Z_IZ_O.Male\", \"Z_IW_I.Female\")\n  \n  # OW_I x IO\n  \n  zw_genotype_8 &lt;- c(\"Z_IZ_O.Male\", \"Z_OZ_O.Male\",\n                     \"Z_IW_I.Female\", \"Z_OW_I.Female\")\n  \n  # OW_I x OO\n  \n  zw_genotype_9 &lt;- c(\"Z_OZ_O.Male\", \"Z_OW_I.Female\")\n  \n  # OW_O X II\n  \n  zw_genotype_10 &lt;- c(\"Z_IZ_O.Male\", \"Z_IW_O.Female\")\n  \n  # OW_O x IO\n  \n  zw_genotype_11 &lt;- c(\"Z_IZ_O.Male\", \"Z_OZ_O.Male\",\n                      \"Z_IW_O.Female\", \"Z_OW_O.Female\")\n  \n  # OW_O x OO\n  \n  zw_genotype_12 &lt;- c(\"Z_OZ_O.Male\", \"Z_OW_O.Female\")\n  \n  # cytoplasmic\n  \n  # I x I\n  # I x O\n  \n  c_genotype_1 &lt;- c(\"C_I.Female\", \"C_I.Male\")\n  \n  # O x O\n  # O x I\n  \n  c_genotype_2 &lt;- c(\"C_O.Female\", \"C_O.Male\")\n  \n  \n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # autosomal\n  \n  # even frequency of two offspring genotypes\n  \n  freq_2 &lt;- rep(0.5, 2)\n  \n  # even frequency between four offspring types\n  \n  freq_4 &lt;- rep(0.25, 4)\n  \n  # when there are 6 offspring genotypes\n  \n  freq_6 &lt;- c(0.125, 0.125,\n              0.25, 0.25,\n              0.125, 0.125)\n  \n  bind_rows(\n    list(\n      make_offspring(\"A_IA_I\", \"A_IA_I\", a_genotype_1, freq_2, \"autosomal\"),\n      make_offspring(\"A_IA_I\", \"A_IA_O\", a_genotype_2, freq_4, \"autosomal\"),\n      make_offspring(\"A_IA_I\", \"A_OA_O\", a_genotype_3, freq_2, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_IA_I\", a_genotype_2, freq_4, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_IA_O\", a_genotype_4, freq_6, \"autosomal\"),\n      make_offspring(\"A_IA_O\", \"A_OA_O\", a_genotype_5, freq_4, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_IA_I\", a_genotype_3, freq_2, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_IA_O\", a_genotype_5, freq_4, \"autosomal\"),\n      make_offspring(\"A_OA_O\", \"A_OA_O\", a_genotype_6, freq_2, \"autosomal\"),\n      \n      make_offspring(\"X_IX_I\", \"X_IY_I\", xy_genotype_1, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_IY_O\", xy_genotype_2, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_OY_I\", xy_genotype_3, freq_2, \"XY\"),\n      make_offspring(\"X_IX_I\", \"X_OY_O\", xy_genotype_4, freq_2, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_IY_I\", xy_genotype_5, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_IY_O\", xy_genotype_6, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_OY_I\", xy_genotype_7, freq_4, \"XY\"),\n      make_offspring(\"X_IX_O\", \"X_OY_O\", xy_genotype_8, freq_4, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_IY_I\", xy_genotype_9, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_IY_O\", xy_genotype_10, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_OY_I\", xy_genotype_11, freq_2, \"XY\"),\n      make_offspring(\"X_OX_O\", \"X_OY_O\", xy_genotype_12, freq_2, \"XY\"),\n      \n      make_offspring(\"Z_IW_I\", \"Z_IZ_I\", zw_genotype_1, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_I\", \"Z_IZ_O\", zw_genotype_2, freq_4, \"ZW\"),\n      make_offspring(\"Z_IW_I\", \"Z_OZ_O\", zw_genotype_3, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_IZ_I\", zw_genotype_4, freq_2, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_IZ_O\", zw_genotype_5, freq_4, \"ZW\"),\n      make_offspring(\"Z_IW_O\", \"Z_OZ_O\", zw_genotype_6, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_I\", \"Z_IZ_I\", zw_genotype_7, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_I\", \"Z_IZ_O\", zw_genotype_8, freq_4, \"ZW\"),\n      make_offspring(\"Z_OW_I\", \"Z_OZ_O\", zw_genotype_9, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_IZ_I\", zw_genotype_10, freq_2, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_IZ_O\", zw_genotype_11, freq_4, \"ZW\"),\n      make_offspring(\"Z_OW_O\", \"Z_OZ_O\", zw_genotype_12, freq_2, \"ZW\"),\n      \n      make_offspring(\"C_I\", \"C_I\", c_genotype_1, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_I\", \"C_O\", c_genotype_1, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_O\", \"C_I\", c_genotype_2, freq_2, \"cytoplasmic\"),\n      make_offspring(\"C_O\", \"C_O\", c_genotype_2, freq_2, \"cytoplasmic\")\n    )) %&gt;% \n    filter(locus_type == gene_location)\n}\n\n\nLoad the inheritance schemes, to speed up the simulation\n\n\nCode\n# load the possible inheritance schemes\n\noffspring_genotypes_autosome &lt;- \n  make_mating_table(gene_location = \"autosomal\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = type) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  as.data.table()\n\noffspring_genotypes_X &lt;- \n  make_mating_table(gene_location = \"XY\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = type) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Male_genotype, \"Y_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_Y &lt;- \n  make_mating_table(gene_location = \"XY\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = type) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Female_genotype, \"X_I\"),\n         !str_detect(Male_genotype, \"X_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_Z &lt;- \n  make_mating_table(gene_location = \"ZW\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = type) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Female_genotype, \"W_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_W &lt;- \n  make_mating_table(gene_location = \"ZW\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = type) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  filter(!str_detect(Female_genotype, \"Z_I\"),\n         !str_detect(Male_genotype, \"Z_I\")) %&gt;% \n  as.data.table()\n\noffspring_genotypes_cytoplasmic &lt;- \n  make_mating_table(gene_location = \"cytoplasmic\") %&gt;% \n  select(1:4) %&gt;% \n  rename(zygote_type = type) %&gt;% \n  separate_wider_delim(zygote_type, names = c(\"Genotype\", \"Sex\"), delim = \".\") %&gt;% \n  mutate(Sex = if_else(Sex == \"Female\", 1, 0)) %&gt;% \n  as.data.table()\n\n\nAn example of the mating table, for an autosomal locus\n\n\nCode\nmake_mating_table(gene_location = \"autosomal\") %&gt;% \n  rename(zygote_type = type) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\n\nFemale_genotype\nMale_genotype\nzygote_type\nzygote_freq\nlocus_type\n\n\n\n\nA_IA_I\nA_IA_I\nA_IA_I.Female\n0.500\nautosomal\n\n\nA_IA_I\nA_IA_I\nA_IA_I.Male\n0.500\nautosomal\n\n\nA_IA_I\nA_IA_O\nA_IA_I.Female\n0.250\nautosomal\n\n\nA_IA_I\nA_IA_O\nA_IA_I.Male\n0.250\nautosomal\n\n\nA_IA_I\nA_IA_O\nA_IA_O.Female\n0.250\nautosomal\n\n\nA_IA_I\nA_IA_O\nA_IA_O.Male\n0.250\nautosomal\n\n\nA_IA_I\nA_OA_O\nA_IA_O.Female\n0.500\nautosomal\n\n\nA_IA_I\nA_OA_O\nA_IA_O.Male\n0.500\nautosomal\n\n\nA_IA_O\nA_IA_I\nA_IA_I.Female\n0.250\nautosomal\n\n\nA_IA_O\nA_IA_I\nA_IA_I.Male\n0.250\nautosomal\n\n\nA_IA_O\nA_IA_I\nA_IA_O.Female\n0.250\nautosomal\n\n\nA_IA_O\nA_IA_I\nA_IA_O.Male\n0.250\nautosomal\n\n\nA_IA_O\nA_IA_O\nA_IA_I.Female\n0.125\nautosomal\n\n\nA_IA_O\nA_IA_O\nA_IA_I.Male\n0.125\nautosomal\n\n\nA_IA_O\nA_IA_O\nA_IA_O.Female\n0.250\nautosomal\n\n\nA_IA_O\nA_IA_O\nA_IA_O.Male\n0.250\nautosomal\n\n\nA_IA_O\nA_IA_O\nA_OA_O.Female\n0.125\nautosomal\n\n\nA_IA_O\nA_IA_O\nA_OA_O.Male\n0.125\nautosomal\n\n\nA_IA_O\nA_OA_O\nA_IA_O.Female\n0.250\nautosomal\n\n\nA_IA_O\nA_OA_O\nA_IA_O.Male\n0.250\nautosomal\n\n\nA_IA_O\nA_OA_O\nA_OA_O.Female\n0.250\nautosomal\n\n\nA_IA_O\nA_OA_O\nA_OA_O.Male\n0.250\nautosomal\n\n\nA_OA_O\nA_IA_I\nA_IA_O.Female\n0.500\nautosomal\n\n\nA_OA_O\nA_IA_I\nA_IA_O.Male\n0.500\nautosomal\n\n\nA_OA_O\nA_IA_O\nA_IA_O.Female\n0.250\nautosomal\n\n\nA_OA_O\nA_IA_O\nA_IA_O.Male\n0.250\nautosomal\n\n\nA_OA_O\nA_IA_O\nA_OA_O.Female\n0.250\nautosomal\n\n\nA_OA_O\nA_IA_O\nA_OA_O.Male\n0.250\nautosomal\n\n\nA_OA_O\nA_OA_O\nA_OA_O.Female\n0.500\nautosomal\n\n\nA_OA_O\nA_OA_O\nA_OA_O.Male\n0.500\nautosomal"
  },
  {
    "objectID": "index.html#build-a-function-to-create-the-starting-population",
    "href": "index.html#build-a-function-to-create-the-starting-population",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Build a function to create the starting population",
    "text": "Build a function to create the starting population\nFollowing Ekrem and Kokko (2023), we find the reproductive lifespans of N diploid individuals in a sexually reproducing population to initialise the simulation. Mortality events are drawn from an exponential distribution with rate \\(\\lambda = 1/\\mu\\). The probability of mortality is therefore constant across the reproductive lifespan for each sex.\nLets have a look at the mean lifespan drawn from the exponential distribution parameterised with different mortality rates.\n\n\nCode\n#exponential_draws &lt;-\n  tibble(`Mean lifespan` = seq(from = 0.01, to = 2.01, by = 0.1)) %&gt;% \n  mutate(`Corresponding mortality rate` = 1/`Mean lifespan`) %&gt;% \n  arrange(-`Mean lifespan`) %&gt;% \n  pander()\n\n\n\n\n\n\n\n\n\nMean lifespan\nCorresponding mortality rate\n\n\n\n\n2.01\n0.4975\n\n\n1.91\n0.5236\n\n\n1.81\n0.5525\n\n\n1.71\n0.5848\n\n\n1.61\n0.6211\n\n\n1.51\n0.6623\n\n\n1.41\n0.7092\n\n\n1.31\n0.7634\n\n\n1.21\n0.8264\n\n\n1.11\n0.9009\n\n\n1.01\n0.9901\n\n\n0.91\n1.099\n\n\n0.81\n1.235\n\n\n0.71\n1.408\n\n\n0.61\n1.639\n\n\n0.51\n1.961\n\n\n0.41\n2.439\n\n\n0.31\n3.226\n\n\n0.21\n4.762\n\n\n0.11\n9.091\n\n\n0.01\n100\n\n\n\n\n\nWe use these values to inform our parameterisation of inbreeding depression (\\(\\delta\\)). Individuals that don’t inbreed produce offspring with a mean lifespan of 2 time units. We then increase the rate of mortality to increase the severity of inbreeding depression, lowering the mean lifespan of inbred offspring.\n\n\nCode\n# build the function to find individual lifespans\n \nbuild_starting_pop &lt;-\n  function(seed, pop_size, mean_lifespan){\n    #set.seed(seed)\n    \n    population &lt;-\n      data.table(Lifespan = rexp(n = pop_size, rate = 1/mean_lifespan),\n                 Sex = rbinom(n = pop_size, 1, prob = 0.5),\n                 birth_time = 0,\n                 matings = 0)\n    \n    population[, `:=` (Genotype = ifelse(Sex &gt; 0, Female_starting_genotype, Male_starting_genotype),\n                      Mortality_time = Lifespan,\n                      breeding = Sex,\n                      Individual_ID = .I,\n                      Family_ID = rep(1:(.N/10), each = 10, length.out = .N))]\n  }"
  },
  {
    "objectID": "index.html#create-a-function-to-add-the-inbreeding-allele-to-the-population",
    "href": "index.html#create-a-function-to-add-the-inbreeding-allele-to-the-population",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Create a function to add the inbreeding allele to the population",
    "text": "Create a function to add the inbreeding allele to the population\nEach individual possesses an inbreeding locus with two possible alleles. The A_O allele encodes inbreeding avoidance, whereas the A_I allele encodes inbreeding tolerance. We assume that dominance is additive, such that any individuals carrying one copy of the A_I allele express inbreeding tolerance in 50% of cases, whereas homozygous individuals always express a tolerance of inbreeding (we can review this assumption once I have it coded and working).\n\n\nCode\nmutate_sample &lt;- \n  function(df, number_mutants) {\n     df[sample(which(str_detect(Genotype, pattern = chromosome)), size = number_mutants, replace = F),\n             Genotype := str_replace(Genotype, pattern = paste0(chromosome, \"_O\"), replacement = paste0(chromosome, \"_I\"))]\n  }"
  },
  {
    "objectID": "index.html#create-a-function-to-produce-a-candidate-list-of-mating-events",
    "href": "index.html#create-a-function-to-produce-a-candidate-list-of-mating-events",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Create a function to produce a candidate list of mating events",
    "text": "Create a function to produce a candidate list of mating events\nWith individual reproductive lifespans known, we can then calculate time stamps for every possible female-male encounter for this set of individuals. For each focal male, the time to finding each specific female is drawn from a negative exponential distribution, with rate \\(\\frac{v}{N_F}\\). \\(v\\) represents the search efficiency of males in the population, where higher values indicate more efficient mate finding. The end result is a complete schedule of female-male interactions across the generation’s reproductive lifespan.\n\n\nCode\ncandidate_timestamp_finder &lt;- \n  function(Female_ID, Male_ID, v, Female_pop_size){\n    CJ(Female_ID, Male_ID)[, Mate_encounter_time_stamp := rexp(n = .N, rate = (v/(Female_pop_size)))\n    ][, `:=`( mated = 0,\n             inbred_mating = 0,\n             female_matings = 0,\n             male_matings = 0,\n             reproduced = 0,\n             counted = 0)]\n  }"
  },
  {
    "objectID": "index.html#create-a-function-to-calculate-the-population-wide-frequency-of-the-inbreeding-allele",
    "href": "index.html#create-a-function-to-calculate-the-population-wide-frequency-of-the-inbreeding-allele",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Create a function to calculate the population-wide frequency of the inbreeding allele",
    "text": "Create a function to calculate the population-wide frequency of the inbreeding allele\n\n\nCode\n# function for autosomal alleles\ncalc_prop_autosomal_inbreeding_allele &lt;- function(pop, heterozygous_genotype, homozygous_genotype, sex_homozygous){\n  (0.5 * length(pop$Genotype[str_detect(pop$Genotype, heterozygous_genotype)])/ nrow(pop)) + \n    (length(pop$Genotype[str_detect(pop$Genotype, homozygous_genotype)])/ nrow(pop)) \n}\n\n# function for hemizygous alleles: W, Y or cytoplasmic\n\ncalc_prop_hemizygous_inbreeding_allele &lt;- function(pop, heterozygous_genotype, homozygous_genotype, sex_homozygous){\n  (length(pop$Genotype[str_detect(pop$Genotype, homozygous_genotype)])/ \n     length(pop$Genotype[str_detect(pop$Genotype, chromosome)]))\n}\n\n# function for alleles diploid in one sex and haploid in the other: X and Z\n\ncalc_prop_XZ_inbreeding_allele &lt;- function(pop, heterozygous_genotype, homozygous_genotype, sex_homozygous){\n  if(sex_homozygous == 1){\n    (0.5 * length(pop$Genotype[str_detect(pop$Genotype, heterozygous_genotype)] & pop$Sex == sex_homozygous)/ nrow(pop)) + \n      (length(pop$Genotype[str_detect(pop$Genotype, homozygous_genotype)] & pop$Sex == sex_homozygous)/ nrow(pop)) +\n      (length(pop$Genotype[str_detect(pop$Genotype, \"I\")] & pop$Sex != sex_homozygous)/ nrow(pop))}\n  else{\n    (0.5 * length(pop$Genotype[str_detect(pop$Genotype, heterozygous_genotype)] & pop$Sex == sex_homozygous)/ nrow(pop)) + \n      (length(pop$Genotype[str_detect(pop$Genotype, homozygous_genotype)] & pop$Sex == sex_homozygous)/ nrow(pop)) +\n      (length(pop$Genotype[str_detect(pop$Genotype, \"I\")] & pop$Sex != sex_homozygous)/ nrow(pop))}\n}\n\n\nDeath of a breeding female triggers replacement by a new breeding individual, assuming that there is &gt;=1 non-breeding female in the population. If there are multiple non-breeding females, the new breeder is selected with probability 1 / number of non-breeding females."
  },
  {
    "objectID": "index.html#define-the-parameter-space",
    "href": "index.html#define-the-parameter-space",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Define the parameter space",
    "text": "Define the parameter space\n\n\nCode\nresolution &lt;- 25\n\nparameters &lt;-\n  expand_grid(\n    C = c(2, 10),\n    v = c(1, 10, 100),\n    prob_sibling_mating = seq(0, 1, length = resolution),\n    D = seq(0, -1.99, length = resolution)) %&gt;% \n  mutate(Starting_pop_size = 200,\n         baseline_mean_lifespan = 2,\n         N = 10,\n         number_mutants = 1,\n         time_end = 100,\n         parameter_space_ID = row_number())"
  },
  {
    "objectID": "index.html#speed-testing",
    "href": "index.html#speed-testing",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Speed testing",
    "text": "Speed testing\nThe fuction below can be used to test computation speed\n\n\nCode\nbench::mark({\n\n  }, iterations = 100)"
  },
  {
    "objectID": "index.html#build-the-main-simulation-function",
    "href": "index.html#build-the-main-simulation-function",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Build the main simulation function",
    "text": "Build the main simulation function\nThe simulation progresses through time. Fates of individuals are pre-calculated and occur in continuous time. We monitor the population regularly (time increments of 0.1) and update the population by:\n\nChecking whose still alive\nFinding new breeding females if there’s space and the females to fill it. All individuals in the population can mate but only those holding breeding sites can produce offspring.\nChecking if mating occurs (including inbreeding).\nAdding new individuals to the population when there are new mated breeders.\nGenerating fates for all new individuals and updating the fates of existing individuals.\n\nThe simulation ends when the inbreeding allele goes extinct, fixes or the time limit elapses.\nWe run one simulation per row in the parameter space table.\n\n\nCode\ncontinuous_time_simulation &lt;- function(row,\n                                       parameters,\n                                       expression, # 0 = in males, 1 = in females\n                                       chromosome, # where does the inbreeding mutation occur\n                                       inheritance_scheme, # mutation occurs on A, X, Y, Z or C\n                                       allele_freq_finder, # depends on inheritance scheme\n                                       heterozygous_genotype, # if hemizygous NA, else specify\n                                       homozygous_genotype, # homozygote for inbreeding allele)\n                                       sex_homozygous){ # if hemizygous 0 or 1, else NA \n  \n  print(paste(\"Doing row\", row)) # this tells you which row in the parameter space is being modelled\n  \n  Starting_pop_size &lt;- parameters$Starting_pop_size[row]\n  C &lt;- parameters$C[row]\n  v &lt;- parameters$v[row]\n  baseline_mean_lifespan &lt;- parameters$baseline_mean_lifespan[row]\n  N &lt;- parameters$N[row]\n  D &lt;- parameters$D[row]\n  number_mutants &lt;- parameters$number_mutants[row]\n  prob_sibling_mating &lt;- parameters$prob_sibling_mating[row]\n  time_end &lt;- parameters$time_end[row]\n  \n  # define the starting genotypes for each sex so the population table can be built\n  \n  Female_starting_genotype &lt;- inheritance_scheme[.N]$Female_genotype\n  \n  Male_starting_genotype &lt;- inheritance_scheme[.N]$Male_genotype\n  \n  # make sure random number generation is not replicated across simulation runs\n  \n  #set.seed(runif(1, 0, 1))\n  \n  # Initialize the timer t to 0\n  t &lt;- 0\n  \n  # Set the number of breeding sites\n  \n  breeding_sites &lt;- 0.5*Starting_pop_size\n  \n  # Initialize the Individual_ID  and Family_ID counters\n  \n  Individual_ID_counter &lt;- Starting_pop_size\n  \n  Family_ID_counter &lt;- Starting_pop_size/10 # the sim starts with 200 individuals from 200 different families...\n  \n  keep_going &lt;- TRUE # if the inbreeding allele fixes or goes extinct, this will change to false and the while loop will quit early\n  \n  # the simulation tracks the population via two dataframes. The first holds info about the individuals in the population, while the second (the candidate list) holds info on encounters between males and females in the population\n  \n  # create the starting population - note that females are sex = 1 and males are sex = 0\n  \n  population &lt;- \n    build_starting_pop(pop_size = Starting_pop_size, \n                       mean_lifespan = baseline_mean_lifespan)\n  \n  # seed population with the inbreeding allele using our custom mutate_sample() function\n  \n  #population &lt;-\n  mutate_sample(population,\n                number_mutants = number_mutants)\n  \n  # create sex specific data tables that can be matched to the mating timestamps\n  \n  female_population &lt;-\n    population[Sex &gt; 0, \n               .(Female_ID = Individual_ID, \n                 Female_genotype = Genotype, \n                 Female_mortality_time = Mortality_time,\n                 breeding,\n                 Female_family_ID = Family_ID)] \n  \n  \n  male_population &lt;-\n    population[Sex &lt; 1, \n               .(Male_ID = Individual_ID, \n                 Male_genotype = Genotype, \n                 Male_mortality_time = Mortality_time,\n                 Male_family_ID = Family_ID)] \n  \n  # Create the initial candidate list of mating interactions\n  \n  initial_females &lt;- female_population[, Female_ID]\n  \n  initial_males &lt;- male_population[, Male_ID]\n  \n  candidate_list &lt;- \n    candidate_timestamp_finder(Female_ID = initial_females,\n                               Male_ID = initial_males,\n                               v = v,\n                               Female_pop_size = length(initial_females)\n    )[female_population, on = 'Female_ID' # join the important genetic and life history info\n    ][male_population, on = \"Male_ID\"]\n  \n  # With the initial population and mating schedule ready to go, start the timer and let the simulation run. In short, time progresses and events with predetermined time stamps occur. These events trigger new actions which can lead to the production of new breeding individuals, which have their own timeline of predetermined events and interactions.\n  \n  while (t &lt;= time_end & keep_going) {\n    \n    # step 1. check whose still alive\n    \n    population &lt;-\n      population[Mortality_time &gt; t]\n    \n    # step 2. find new breeders if there's space and females to fill it\n    \n    # Get the current size of the breeding female population \n    \n    current_breeders &lt;- sum(population$breeding &gt; 0) #length(which(population$breeding &gt; 0))\n    \n    # If there are available breeding sites, and females to fill them, recruit new breeders\n    \n    if(current_breeders &lt; breeding_sites && sum(population$Sex &gt; 0 & population$breeding &lt; 1) &gt; 0){\n      \n      # choose whether site or female availability limits recruitment\n      \n      size_input &lt;- min(breeding_sites - current_breeders, \n                        sum(population$Sex &gt; 0 & population$breeding &lt; 1))\n      \n      # assign the new breeders\n      \n      population &lt;- population[sample(which(breeding &lt; 1 & Sex &gt; 0),\n                                      size = size_input, \n                                      replace = FALSE), # note that all females have equal prob of becoming a breeder atm\n                               breeding := 1]\n      \n      # slot the newly updated population info into the candidate list\n      \n      candidate_list &lt;- candidate_list[population[Sex &gt; 0, .(Female_ID = Individual_ID, breeding)], \n                                       on = .(Female_ID),\n                                       breeding := i.breeding]\n    }\n    \n    # step 3. mating\n    \n    # trim the candidate list by removing 1) removing all encounters for individuals that have died and 2) all encounters from the past, except those that led to mating but haven't yet led to reproduction (we need these later). t - 0.1 is used because time elapsed increases by 0.1 units every iteration.  \n    \n    candidate_list &lt;- candidate_list[Female_mortality_time &gt; t &\n                                       Male_mortality_time &gt; t & \n                                       (Mate_encounter_time_stamp &gt; t - 0.1 | mated &gt; 0 & reproduced &lt; 1)]\n    \n    # now use the list to check whether there are any female-male encounters at this moment that result in mating\n    # to do this, first create a table holding all encounters that occur at the current time\n    \n    encounters &lt;- candidate_list[Mate_encounter_time_stamp &lt;= t]\n    \n    # if an encounter occurs involving an individual carrying the A_I allele, provide an opportunity for inbreeding. Heterozygotes inbreed with 0.5 probability i.e. additive genetic expression. The hurdle requirement for an inbreeding opportunity is that an individual must stay alive long enough to meet any member of the opposite sex. We then code the simulation such that this opposite sex individual is swapped out for a full-sibling that can be mated with. This simulates a common situation in nature, where due to population viscosity, relatives live in close geographic proximity and are thus more likely to be encountered. \n    \n    inbreeders &lt;- data.table(Female_ID=numeric(), Male_ID=numeric()) # keeps the model running if no inbreeding occurs at t\n    \n    # find males that will inbreed when they are the sex that expresses inbreeding tolerance\n    \n    if(expression &lt; 1 & sum(str_detect(encounters$Male_genotype, \"I\") &gt; 0)){\n      \n      inbreeding_male_IDs &lt;- \n        unique(copy(encounters)\n               [str_detect(Male_genotype, \"A_IA_O\"), inbreeding := rbinom(.N, 1, 0.5) # heterozygotes\n               ][str_detect(Male_genotype, \"A_IA_I\"), inbreeding := 1 # homozygotes\n               ][inbreeding &gt; 0, .(Male_ID) # select those that inbreed\n               ])[, mate_with_full_sib := rbinom(.N, 1, prob_sibling_mating)] # manipulate r with prob_sibling_mating\n      \n      # find new mates for males, first those chosen to mate with a full sib, then those that mate at random in the pop\n      \n      inbreeders &lt;-\n        unique(\n          rbindlist(list(\n            candidate_list[inbreeding_male_IDs, on = \"Male_ID\"\n            ][mate_with_full_sib &gt; 0 & \n                Female_family_ID == Male_family_ID & # this line produces full-sib mating, if a receptive sib exists\n                female_matings &lt; 1 & \n                male_matings &lt; C,\n              .SD[sample(.N, 1, replace = F)], by = \"Male_ID\"], # choose a sister to mate with \n            \n            candidate_list[inbreeding_male_IDs, on = \"Male_ID\"\n            ][mate_with_full_sib &lt; 1 &\n                female_matings &lt; 1 & \n                male_matings &lt; C, \n              .SD[sample(.N, 1, replace = F)], by = \"Male_ID\"] # choose random female from population to mate with\n          ))[, `:=`(mated = 1, Mate_encounter_time_stamp = t, inbred_mating = 1) # change mating status and move encounter time forward\n          ][, mate_with_full_sib := NULL],\n          by = \"Female_ID\" # make sure no female is chosen twice\n        )[, .(Female_ID, Male_ID, mated, Mate_encounter_time_stamp, inbred_mating)] \n      \n      # update the candidate list by moving the chosen mating forward to the present time.\n      \n      candidate_list[inbreeders, `:=` (mated = i.mated, \n                                       Mate_encounter_time_stamp = i.Mate_encounter_time_stamp,\n                                       inbred_mating = i.inbred_mating),\n                     on = .(Female_ID, Male_ID)]\n    }\n    \n    # find females that will inbreed when they are the sex that expresses inbreeding tolerance\n    \n    if(expression &gt; 0 & sum(str_detect(encounters$Female_genotype, \"I\") &gt; 0)){\n      \n      inbreeding_female_IDs &lt;- \n        unique(copy(encounters)\n               [str_detect(Female_genotype, \"A_IA_O\"), inbreeding := rbinom(.N, 1, 0.5) # heterozygotes\n               ][str_detect(Female_genotype, \"A_IA_I\"), inbreeding := 1 # homozygotes\n               ][inbreeding &gt; 0, .(Female_ID)\n               ])[, mate_with_full_sib := rbinom(.N, 1, prob_sibling_mating)] # manipulate r with prob_sibling_mating\n      \n      # find new mates for females, first those chosen to mate with a full sib, then those that mate at random in the pop\n      \n      inbreeders &lt;-\n        unique(\n          rbindlist(list(\n            candidate_list[inbreeding_female_IDs, on = \"Female_ID\"\n            ][mate_with_full_sib &gt; 0 & \n                Female_family_ID == Male_family_ID & # this line produces full-sib mating\n                female_matings &lt; 1 & \n                male_matings &lt; C,\n              .SD[sample(.N, 1)], by = \"Female_ID\"], # choose brother to mate with\n            \n            candidate_list[inbreeding_female_IDs, on = \"Female_ID\"\n            ][mate_with_full_sib &lt; 1 &\n                female_matings &lt; 1 & \n                male_matings &lt; C, \n              .SD[sample(.N, 1)], by = \"Female_ID\"] # choose random male from population to mate with\n          ))[, `:=`(mated = 1, Mate_encounter_time_stamp = t, inbred_mating = 1) # change mating status and move encounter forward\n          ][, mate_with_full_sib := NULL],\n          by = \"Male_ID\" # make sure no male is chosen twice\n        )[, .(Female_ID, Male_ID, mated, Mate_encounter_time_stamp, inbred_mating)] \n      \n      # update the candidate list by moving the chosen mating forward to the present time. \n      \n      candidate_list[inbreeders, `:=` (mated = i.mated, \n                                       Mate_encounter_time_stamp = i.Mate_encounter_time_stamp,\n                                       inbred_mating = i.inbred_mating),\n                     on = .(Female_ID, Male_ID)]\n    }\n    \n    # conduct 'normal' matings\n    \n    receptive_encounters &lt;-\n      encounters[female_matings &lt; 1 & male_matings &lt; C\n      ][, f_number := .N, keyby = Female_ID\n      ][, m_number := .N,  by = Male_ID\n      ][!inbreeders, on = .(Female_ID) # remove females involved in inbreeding at this time\n      ][!inbreeders, on = .(Male_ID)] # remove males involved in inbreeding at this time\n    \n    # if individuals encounter multiple individuals at once, make sure they just choose one to mate with. If two individuals choose the same individual of the opposite sex, one randomly succeeds and the other(s) miss out\n    \n    if(max(receptive_encounters$f_number) &gt; 1 | max(receptive_encounters$m_number) &gt; 1){\n      \n      likely_matings &lt;- receptive_encounters[, \n                                             .I[Mate_encounter_time_stamp == min(Mate_encounter_time_stamp)], \n                                             by = Female_ID]$V1\n      \n      chosen_matings &lt;- unique(receptive_encounters[likely_matings, \n                                                    .(Male_ID, Female_ID)], \n                               by = \"Male_ID\")[, mated := 1]\n      \n      # update the candidate list\n      \n      candidate_list &lt;- candidate_list[chosen_matings, \n                                       on = .(Male_ID = Male_ID, Female_ID = Female_ID), \n                                       mated := i.mated]\n      \n    } else{\n      candidate_list &lt;-\n        candidate_list[!inbreeders, on = .(Female_ID) # remove females involved in inbreeding at this time\n        ][!inbreeders, on = .(Male_ID)  # remove males involved in inbreeding at this time\n        ][Mate_encounter_time_stamp &lt;= t &\n            female_matings &lt; 1 &\n            male_matings &lt; C, mated := 1]\n    }\n    \n    # update the mating tally in the population tibble\n    # the counted variable indicates that the successful mating has already been included in the female and males mating tally\n    # new matings combines the inbred matings and the 'normal matings' that occur at time t\n    \n    new_matings &lt;- \n      candidate_list[mated &gt; 0 & counted &lt; 1,][, `:=`(matings = 1)][, .(Female_ID, Male_ID, matings)]\n    \n    if(nrow(new_matings) &gt; 0){\n      # melt reshapes the table from wide to long, like pivot_longer in the tidyverse\n      population &lt;- population[melt(new_matings,\n                                    measure.vars = c(\"Female_ID\", \"Male_ID\"),\n                                    value.name = \"Individual_ID\")[,.(Individual_ID, matings)], \n                               `:=`(matings = matings + i.matings), on = \"Individual_ID\"]\n      \n      \n      # update the mating tally in the candidate list and check specific matings off as counted\n      \n      new_mated_females &lt;- \n        new_matings[, .(Female_ID, female_matings = matings)]\n      \n      new_mated_males &lt;- \n        new_matings[, .(Male_ID, male_matings = matings)]\n      \n      candidate_list &lt;- \n        candidate_list[new_mated_females, \n                       female_matings := female_matings + i.female_matings, \n                       on = \"Female_ID\"\n        ][new_mated_males, male_matings := male_matings + i.male_matings, \n          on = \"Male_ID\"\n        ][new_matings, counted := 1, on = c(\"Female_ID\", \"Male_ID\")] # this ticks the mating off as counted\n    }\n    \n    # step 4: reproduction\n    \n    # check how many females can now produce offspring, either because they're previously mated and have secured a breeding site or because they already held a breeding site and have now mated\n    \n    new_mated_breeders &lt;- sum(candidate_list$mated &gt; 0 & \n                                candidate_list$breeding &gt; 0 & \n                                candidate_list$reproduced &lt; 1)\n    \n    if(new_mated_breeders &gt; 0) {\n      # add offspring to the population. Each mated female that holds a breeding site produces N offspring\n      offspring &lt;- \n        candidate_list[mated &gt; 0 & breeding &gt; 0 & reproduced &lt; 1, \n        ][inheritance_scheme, \n          on = .(Female_genotype = Female_genotype,\n                 Male_genotype = Male_genotype), \n          nomatch = NULL, allow.cartesian  = TRUE\n        ][, .SD[sample(.N, \n                       size = N, \n                       prob = zygote_freq, \n                       replace = T)],\n          by = .(Female_ID, \n                 Male_ID)\n        ][, Family_ID := .GRP + Family_ID_counter,\n          by = .(Female_ID, \n                 Male_ID)\n        ][, .(Genotype, \n              Sex, \n              inbred_mating,\n              Family_ID)\n        ][, `:=`(birth_time = t,\n                 Lifespan = ifelse(inbred_mating &gt; 0, rexp(.N, rate = 1/(baseline_mean_lifespan + D)),\n                                   rexp(.N, rate = 1/baseline_mean_lifespan)),\n                 breeding = 0,\n                 matings = 0)\n        ][, Mortality_time := Lifespan + birth_time\n        ][, Individual_ID := .I + Individual_ID_counter\n        ][, c(-3)] # dangerous coding but this drops the inbred mating column that we don't need in the population table\n      \n      # bind the offspring table to the existing population table  \n      \n      population &lt;- rbindlist(list(population, offspring), use.names = TRUE)\n      \n      # update the reproduced column in the candidate list \n      \n      candidate_list &lt;- candidate_list[mated &gt; 0 & breeding &gt; 0 & reproduced &lt; 1, reproduced := 1]\n      \n      # update the candidate list with new members of the population\n      \n      # setup dummy dts so we can bind everything at once, which saves time\n      \n      new_female_mating_encounter_times &lt;- data.table(Female_ID=numeric(), Male_ID=numeric()) \n      new_male_mating_encounter_times &lt;- data.table(Female_ID=numeric(), Male_ID=numeric()) \n      \n      # first get all relevant data from the population table\n      new_females &lt;- population[Sex &gt; 0 & birth_time == t, \n                                .(Female_ID = Individual_ID,\n                                  Female_mortality_time = Mortality_time,\n                                  Female_genotype = Genotype,\n                                  Female_family_ID = Family_ID,\n                                  female_matings = matings,\n                                  breeding = breeding)]\n      # note that population only contains living individuals so we don't need to filter for that here\n      all_eligible_females &lt;- population[Sex &gt; 0 & matings &lt; 1, \n                                         .(Female_ID = Individual_ID,\n                                           Female_mortality_time = Mortality_time,\n                                           Female_genotype = Genotype,\n                                           Female_family_ID = Family_ID,\n                                           female_matings = matings,\n                                           breeding = breeding)]\n      \n      new_males &lt;- population[Sex &lt; 1 & birth_time == t, \n                              .(Male_ID = Individual_ID,\n                                Male_mortality_time = Mortality_time,\n                                Male_genotype = Genotype,\n                                Male_family_ID = Family_ID,\n                                male_matings = matings)]\n      \n      all_eligible_males &lt;- population[Sex &lt; 1 & matings &lt; C,\n                                       .(Male_ID = Individual_ID,\n                                         Male_mortality_time = Mortality_time,\n                                         Male_genotype = Genotype,\n                                         Male_family_ID = Family_ID,\n                                         male_matings = matings)]\n      \n      # find mating interactions for new females and join with life history info\n      \n      if(nrow(new_females) &gt; 0){\n        \n        new_female_mating_encounter_times &lt;-\n          CJ(Female_ID = new_females$Female_ID, \n             Male_ID = all_eligible_males$Male_ID\n          )[, \n            .(Female_ID,\n              Male_ID,\n              Mate_encounter_time_stamp = t + rexp(n = .N, rate = (v/nrow(all_eligible_females))),\n              mated = 0,\n              inbred_mating = 0,\n              reproduced = 0,\n              counted = 0)\n          ][new_females, on = \"Female_ID\"\n          ][all_eligible_males, on = \"Male_ID\"]\n        \n        # add new interactions to the list\n        \n        # candidate_list &lt;-\n        #  rbindlist(list(candidate_list, new_female_mating_encounter_times), use.names = TRUE)\n        \n      }\n      \n      # find mating interactions for new males and join with life history info\n      if(nrow(new_males)  &gt; 0){  \n        new_male_mating_encounter_times &lt;-\n          CJ(Female_ID = all_eligible_females$Female_ID, \n             Male_ID = new_males$Male_ID\n          )[, \n            .(Female_ID,\n              Male_ID,\n              Mate_encounter_time_stamp = t + rexp(n = .N, rate = (v/nrow(all_eligible_females))),\n              mated = 0,\n              inbred_mating = 0,\n              reproduced = 0,\n              counted = 0)\n          ][all_eligible_females, on = \"Female_ID\"\n          ][new_males, on = \"Male_ID\"]\n      }\n      \n      # add new individuals to the list\n      \n      candidate_list &lt;-\n        unique(rbindlist(list(candidate_list, \n                              new_female_mating_encounter_times,\n                              new_male_mating_encounter_times), use.names = TRUE), \n               by = c(\"Female_ID\", \"Male_ID\")\n               # update the reproduced column in the candidate list \n        )[mated &gt; 0 & breeding &gt; 0 & reproduced &lt; 1, reproduced := 1]\n    }\n    \n    # Update the Individual_ID counter\n    Individual_ID_counter &lt;- max(population$Individual_ID)\n    Family_ID_counter &lt;- max(population$Family_ID)\n    \n    print(paste0(\"Reproduction from \", new_mated_breeders, \" breeders, \", current_breeders,\n                 \" breeders alive, time = \", round(t, 2)))\n    \n    \n    # Calculate the frequency of the i allele, quit early if i fixes or goes extinct\n    #prop_i &lt;- calc_prop_inbreeding_allele(population, heterozygous_genotype, homozygous_genotype)\n    prop_i &lt;- allele_freq_finder(population, \n                                 homozygous_genotype = homozygous_genotype, \n                                 heterozygous_genotype = heterozygous_genotype,\n                                 sex_homozygous = sex_homozygous) \n    \n    # for testing change the invasion success criteria from fixation to an intermediate freq. Change back for final sim\n    #if(prop_i &gt; 0.999 | prop_i &lt; 0.0001) keep_going &lt;- FALSE\n    if(prop_i &gt; 0.4 | prop_i &lt; 0.0001) keep_going &lt;- FALSE\n    \n    \n    # Increment t by a small time step\n    t &lt;- t + 0.1\n  }\n  \n  # Print the simulation results\n  #list(population, candidate_list, prop_i)\n  parameters[row, ] %&gt;% mutate(I_frequency = prop_i)\n}"
  },
  {
    "objectID": "index.html#run-the-simulation",
    "href": "index.html#run-the-simulation",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Run the simulation",
    "text": "Run the simulation\n\n\nCode\nx &lt;- \n  continuous_time_simulation(row = 1,\n                             parameters = parameters,\n                             expression = 1,\n                             chromosome = \"W\",\n                             inheritance_scheme = offspring_genotypes_W,\n                             allele_freq_finder = calc_prop_hemizygous_inbreeding_allele,\n                             heterozygous_genotype = NA,\n                             homozygous_genotype = \"Z_OW_I\",\n                             sex_homozygous = NA)\n\nmap_dfr(1:50, continuous_time_simulation, parameters = parameters, inheritance_scheme = offspring_genotypes_autosome,\n                             heterozygous_genotype = \"A_IA_O\",\n                             homozygous_genotype = \"A_IA_I\")\n\nx %&gt;% glimpse()"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Notes",
    "section": "",
    "text": "Premise outline\nThis project centres around the fate of alleles that encode inbreeding preference / avoidance depending on where they occur within the genome.\nBut the deeper idea is that inbreeding is a ‘selfish action’ where some alleles benefit from helping copies of themselves in other individuals, to the detriment of the broader organism. This detriment occurs because of inbreeding depression, which occurs because of homozygosity at other loci across the genome. Homozygosity causes the expression of recessive deleterious alleles which are otherwise rarely expressed, reducing the number of viable offspring produced by the organism.\nTo represent the broader genome, we can use alleles on hemizygous sex chromosomes, which have no opportunity to be homozygous and thus can gain no benefits of helping a relative gain a breeding opportunity. This broadly aligns with the ‘interests’ of the organism. For example, in an XY system alleles on the Y do not increase the propagation of alleles identical by descent through inbreeding, because females do not carry a Y. An autosomal allele, however, does have the potential to increase the proliferation of its copies by increasing the chance of breeding with a relative. This benefit is somewhat similar to that achieved by meiotic drive allele (clarify your thoughts here).\nA second potential angle is to explore the effect of the sex an allele encoding a preference for inbreeding is expressed in. This is important because the conditions often applicable to expression in a male present a greater parameter space for inbreeding preference (to put it too simply, because males invest less in each mating opportunity than females). Sex-specific effects also interact with hemizygous conditions, because in addition to XY systems, ZW systems exist and suddenly hemizygous chromosomes are present in females.\nSo in sum, there is a likely conflict between alleles on different chromosomes over the tendency to inbreed and there is a second non-mutually exclusive conflict between the sexes over inbreeding tendency. Wow, this is cool.\nThis idea might be deeper still. We point out that alleles on hemizygous sex chromosomes gain no indirect inclusive fitness benefits by mating with kin. The kicker is that inbreeding is just one example of this larger idea. There are no inclusive fitness benefits for alleles that encode any altruistic behaviour towards opposite sex individuals (where one sex possesses a hemizygous sex chromosome).\nSome specific notes from the meeting\n\nHanna’s 2006 paper shows when a preference for inbreeding should or should not be favoured for an autosomal allele, but does not consider other regions of the genome.\nStart with the Parker 1/3 thing, which Hanna and co re-derive. But they implicitly assume that the alleles in question here are on an autosome. We can make the change that they are on a sex chromosome, as stipulated above.\nThe X and Z can also be explored, because of their unusual inheritance dynamics. E.g. the X spends 2/3 of its time in females, but is always expressed in males and vice versa for the W.\nDoes it matter whether the loci that cause inbreeding depression are on the same/different chromosomes as those that encode inbreeding preferences…\nBirds versus mammals, flies versus butterflies etc - different hemizygous sex chromosomes\nUnity breaks down because of inheritance differences\nHamilton 1967 extraordinary sex chromosomes paper is a nice angle here\nHaplodiploidy - this is an extension opportunity.\nI will also try to simulate this question.\n\n\\(~\\)\n\n\n\n\nHanna suggests that the time in, time out continuous framework might not be the best option, as it is not the most intuitive for others.\nPerhaps keeping it simple may be the best way forward - females mate once, males mate multiple times. This produces differences in the opportunity cost of mating between the sexes.\nA discrete time model might work better\nScottish group models the inbreeding problem in helpful ways\nAnother way is to follow the Ekrem paper and simulate in an intelligent way (this method might be particularly fruitful)\nEssentially browse the different ways to approach the problem and follow one you like best.\nModels like our developing one do not consider purging dynamics that should occur if inbreeding becomes common.\n\n\n\n\nHamilton 1963 & 1964\n\nWright’s coefficient of relationship - a pedigree based measure\n\nHamilton 1971 & 1972\n\nRegression coefficient between genotype of actor and recipient\n\nMichod and Hamilton 1980 - Coefficients of relatedness in sociobiology\n\n\\(r = \\frac{Cov(A_P, R_F)}{Cov(A_P, A_F)}\\)\nwhere \\(A_P\\) is the genetically encoded altruistic phenotype of the actor (with values 0, 0.5, 1 corresponding to the three possible genotypes, AA, Aa and aa)\nA_F is the frequency of the altruistic genotype in the actor\nR indicates the recepient\nOrlove 1975 and Orlove and Wood 1978 should be cited here as well\n\nGrafen 1985 - A geometric view of relatedness\n\nCrozier’s relatedness (1970) = genetic similarity: the extent to which they possess the same alleles (think genomic relatedness matrices)\nCrozier’s relationship (1970) = a measure of common ancestry that can be estimated from a pedigree (think animal models)\nPrice’s theorem is helpful. One important point is to divide the individual by its ploidy. This really matters for the inbreeding question.\n\nGardner, West and Wild 2011 - The genetical theory of kin selection\n\nTend to agree with Orlove and Wood 1978: \\(\\frac{Cov(g', g)}{Cov(g, g)}\\)\nNote that these are all individual measures of relatedness - we need to edit slightly to get gene’s eye view measures."
  },
  {
    "objectID": "notes.html#project-background-notes",
    "href": "notes.html#project-background-notes",
    "title": "Notes",
    "section": "",
    "text": "Premise outline\nThis project centres around the fate of alleles that encode inbreeding preference / avoidance depending on where they occur within the genome.\nBut the deeper idea is that inbreeding is a ‘selfish action’ where some alleles benefit from helping copies of themselves in other individuals, to the detriment of the broader organism. This detriment occurs because of inbreeding depression, which occurs because of homozygosity at other loci across the genome. Homozygosity causes the expression of recessive deleterious alleles which are otherwise rarely expressed, reducing the number of viable offspring produced by the organism.\nTo represent the broader genome, we can use alleles on hemizygous sex chromosomes, which have no opportunity to be homozygous and thus can gain no benefits of helping a relative gain a breeding opportunity. This broadly aligns with the ‘interests’ of the organism. For example, in an XY system alleles on the Y do not increase the propagation of alleles identical by descent through inbreeding, because females do not carry a Y. An autosomal allele, however, does have the potential to increase the proliferation of its copies by increasing the chance of breeding with a relative. This benefit is somewhat similar to that achieved by meiotic drive allele (clarify your thoughts here).\nA second potential angle is to explore the effect of the sex an allele encoding a preference for inbreeding is expressed in. This is important because the conditions often applicable to expression in a male present a greater parameter space for inbreeding preference (to put it too simply, because males invest less in each mating opportunity than females). Sex-specific effects also interact with hemizygous conditions, because in addition to XY systems, ZW systems exist and suddenly hemizygous chromosomes are present in females.\nSo in sum, there is a likely conflict between alleles on different chromosomes over the tendency to inbreed and there is a second non-mutually exclusive conflict between the sexes over inbreeding tendency. Wow, this is cool.\nThis idea might be deeper still. We point out that alleles on hemizygous sex chromosomes gain no indirect inclusive fitness benefits by mating with kin. The kicker is that inbreeding is just one example of this larger idea. There are no inclusive fitness benefits for alleles that encode any altruistic behaviour towards opposite sex individuals (where one sex possesses a hemizygous sex chromosome).\nSome specific notes from the meeting\n\nHanna’s 2006 paper shows when a preference for inbreeding should or should not be favoured for an autosomal allele, but does not consider other regions of the genome.\nStart with the Parker 1/3 thing, which Hanna and co re-derive. But they implicitly assume that the alleles in question here are on an autosome. We can make the change that they are on a sex chromosome, as stipulated above.\nThe X and Z can also be explored, because of their unusual inheritance dynamics. E.g. the X spends 2/3 of its time in females, but is always expressed in males and vice versa for the W.\nDoes it matter whether the loci that cause inbreeding depression are on the same/different chromosomes as those that encode inbreeding preferences…\nBirds versus mammals, flies versus butterflies etc - different hemizygous sex chromosomes\nUnity breaks down because of inheritance differences\nHamilton 1967 extraordinary sex chromosomes paper is a nice angle here\nHaplodiploidy - this is an extension opportunity.\nI will also try to simulate this question.\n\n\\(~\\)\n\n\n\n\nHanna suggests that the time in, time out continuous framework might not be the best option, as it is not the most intuitive for others.\nPerhaps keeping it simple may be the best way forward - females mate once, males mate multiple times. This produces differences in the opportunity cost of mating between the sexes.\nA discrete time model might work better\nScottish group models the inbreeding problem in helpful ways\nAnother way is to follow the Ekrem paper and simulate in an intelligent way (this method might be particularly fruitful)\nEssentially browse the different ways to approach the problem and follow one you like best.\nModels like our developing one do not consider purging dynamics that should occur if inbreeding becomes common.\n\n\n\n\nHamilton 1963 & 1964\n\nWright’s coefficient of relationship - a pedigree based measure\n\nHamilton 1971 & 1972\n\nRegression coefficient between genotype of actor and recipient\n\nMichod and Hamilton 1980 - Coefficients of relatedness in sociobiology\n\n\\(r = \\frac{Cov(A_P, R_F)}{Cov(A_P, A_F)}\\)\nwhere \\(A_P\\) is the genetically encoded altruistic phenotype of the actor (with values 0, 0.5, 1 corresponding to the three possible genotypes, AA, Aa and aa)\nA_F is the frequency of the altruistic genotype in the actor\nR indicates the recepient\nOrlove 1975 and Orlove and Wood 1978 should be cited here as well\n\nGrafen 1985 - A geometric view of relatedness\n\nCrozier’s relatedness (1970) = genetic similarity: the extent to which they possess the same alleles (think genomic relatedness matrices)\nCrozier’s relationship (1970) = a measure of common ancestry that can be estimated from a pedigree (think animal models)\nPrice’s theorem is helpful. One important point is to divide the individual by its ploidy. This really matters for the inbreeding question.\n\nGardner, West and Wild 2011 - The genetical theory of kin selection\n\nTend to agree with Orlove and Wood 1978: \\(\\frac{Cov(g', g)}{Cov(g, g)}\\)\nNote that these are all individual measures of relatedness - we need to edit slightly to get gene’s eye view measures."
  },
  {
    "objectID": "notes.html#section-2",
    "href": "notes.html#section-2",
    "title": "Notes",
    "section": "07/11/23",
    "text": "07/11/23\n\nr should not be called r. It is the multiplication of two conditional probabilities.\nThe problem with current r for our purposes is that inclusive fitness is an individual level fitness metric.\nOne plot is individual level fitness loss (strategic reference gene equivalent) from inbreeding as a bar plot for optimal level of inbreeding at each chromosome\nInterlocus (or more accurately inter-chromosome) sexual conflict plot\nHaplodiploids not from the a sense but the delta sense - follow-up project?"
  },
  {
    "objectID": "Selfish_inbreeding.html",
    "href": "Selfish_inbreeding.html",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "I think we can answer our question using the Kokko and Ots framework, but is it the right choice? Given we take a gene’s eye view, is a population genetic model (or if too difficult, a simulation) required.\nKin selection pop-gen models are well developed, by the time in, time out investment into reproduction dynamics is going to require lots of thinking on my behalf.\nThis is my first goal…\n\n\n\nLet’s build a single autosomal locus, bi-allelic model, assuming Hardy-Weinberg equilibrium.\n\nThe \\(A\\) allele is the ‘non-donor’ allele (can be thought of as an allele encoding outbreeding preference). The frequency of this allele is \\(p\\).\nThe \\(a\\) allele is the donor allele (the altruistic allele, which may encode inbreeding preference). The frequency of this allele is \\(q = 1 - p\\).\n\\(1 - h^2\\) is the likelihood that the \\(Aa\\) genotype exhibits the altruistic behaviour. If \\(h^2 = 1\\) then the allele is completely recessive.\n\nThe next step is to find all possible mating types:\n\n\nCode\nmake_mating_table &lt;- function(){#k, normalP1, P1cost, P2cost){\n  \n  make_offspring &lt;- function(X, Y, type, zygote_freq){\n    tibble(mother = X,\n           father = Y,\n           type,\n           zygote_freq)\n  }\n\n  # Set up the 9 possible mating combinations\n  \n  mating_types &lt;- expand_grid(\n    mother = c(\"AA_female\",\n               \"Aa_female\",\n               \"aa_female\"),\n    father = c(\"AA_male\",\n                \"Aa_male\",\n                \"aa_male\"))\n\n\n # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function\n  \n  # AA x AA\n  \n  g0 &lt;- c(\"AA_female\", \"AA_male\")\n  \n  # Aa x AA & AA x Aa\n  \n  g1 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\")\n  \n  # aa x AA & AA x aa\n  \n  g2 &lt;- c(\"Aa_female\", \"Aa_male\")\n  \n  # Aa x Aa\n  \n  g3 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # Aa x aa & aa x Aa\n  \n  g4 &lt;- c(\"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # aa x aa\n  \n  g5 &lt;- c(\"aa_female\", \"aa_male\")\n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # even frequency of four offspring types\n  \n  rep25 &lt;- rep(0.25, 4)\n  \n  # even frequency between two offspring types\n  \n  rep5 &lt;- rep(0.5, 2)\n  \n  # Aa * Aa\n  \n  p1 &lt;- c(0.5*0.25,\n          0.5*0.25,\n          0.5*0.5,\n          0.5*0.5,\n          0.5*0.25,\n          0.5*0.25)\n  \n    bind_rows(\n    list(\n      make_offspring(\"AA\", \"AA\", g0, rep5),\n      make_offspring(\"AA\", \"Aa\", g1, rep25),\n      make_offspring(\"AA\", \"aa\", g2, rep5),\n      make_offspring(\"Aa\", \"AA\", g1, rep25),\n      make_offspring(\"Aa\", \"Aa\", g3, p1),\n      make_offspring(\"Aa\", \"aa\", g4, rep25),\n      make_offspring(\"aa\", \"AA\", g2, rep5),\n      make_offspring(\"aa\", \"Aa\", g4, rep25),\n      make_offspring(\"aa\", \"aa\", g5, rep5)\n    )) %&gt;% \n    arrange(mother, father)\n  \n}\n\nmake_mating_table() %&gt;% \n  rename(zygote_type = type) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\nThe frequency of each mating type can be generated using the terms of the classic equation:\n\\[(p^2 + 2pq + q^2)^2\\] Note the final square generates the mating combination.\nThe frequencies of each genotype are\n\n\nCode\n(Mating_type_freqs &lt;-\n  tibble(mother = c(\"AA\",\"AA\",\"AA\",\"Aa\",\"Aa\",\"Aa\",\"aa\",\"aa\",\"aa\"),\n         father = c(\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\"),\n         frequency = c(\"(p^4)/2\", \"(4p^3*q)/2\", \"(2p^2*2q^2)/2\", \"(4p^3*q)/2\",\n                       \"(4p^2*q^2)/2\", \"(4p*q^3)/2\", \"(2p^2*2q^2)/2\", \"(4p*q^3)/2\",\n                       \"(q^4)/2\"\n                       )) %&gt;% \n  kable() %&gt;% \n    kable_styling())\n\n\n\n\n\n\nThis is a two-step process. First we determine the frequencies of each genotype in the mating population (this could be, for example, after we’ve accounted for inbreeding costs), then we calculate the frequencies of each potential mating combination between these genotypes.\nStep 1 - finding the genotype frequencies in the mating population\nHere we can model an inbreeding depression effect, by changing the viability of different genotypes. I make this a constant for now, to aid my initial understanding, but later this will be one of the key parameters to vary.\nI have also allowed the dominance of \\(a\\) to vary. While inbreeding depression is the result of the increased expression of recessive alleles through homozygosity, partially recessive alleles are likely to be common. When \\(h = 1\\), the \\(a\\) allele is completely recessive.\n\n\nCode\negg_adult_viability_Aa_finder &lt;- function(h){1 - 0.33*(1 - h)}\n\n\n# viability of each genotype \n\negg_adult_viability_AA_female &lt;- 1\n\negg_adult_viability_Aa_female &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_female &lt;- 0.67\n\negg_adult_viability_AA_male &lt;- 1\n\negg_adult_viability_Aa_male &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_male &lt;- 0.67\n\n\nUsing these parameters, we implement selection, so that each genotype is represented in the mating combinations according to the product of its frequency and its viability, which is determined by inbreeding depression. I assume that mating success is constant across genotypes (this may not be possible if one allele approaches extinction).\nStep 2 - finding the frequency of all potential mating combinations in the mating population\nNext, we model the effect of inbreeding preference on inclusive fitness (direct + indirect fitness). I first assume that individuals are faced with a simultaneous choice situation - between mating with a relative or mating with an unrelated individual.\nFor simplicity at the outset, I assume that inbreeding preference is only expressed in females. To simulate inbreeding preference, females carrying the \\(a\\) allele mate with siblings (those individuals produced by the same parental genotype combination). However, dominance also plays a role here. A proportion \\(1 - h\\) of \\(Aa\\) females express inbreeding preference, whereas a proportion \\(h\\) do not.\nWith the above in mind, I calculate the expected frequencies of each possible ‘mating combination’ (i.e. the combination of the maternal and paternal genotypes) across the population. For singly-mated females with genotype \\(AA\\), the frequency of each mating type is simply given by \\(F_iM_j\\), where \\(F_i\\) and \\(M_j\\) are the female and male parental genotype frequencies, that is they choose mates at random. For females with genotype \\(Aa\\) a proportion \\(1 - h\\) express a preference for inbreeding. For these females, the expected frequencies for each mating type are determined by the parental mating type combination they were produced by. These females randomly choose a mate from a subset of possible genotypes produced by the parental combination e.g. an \\(AA\\) x \\(aa\\) mating will produce a female that will choose to mate with a \\(Aa\\) male (the only possible genotype of her brothers). The proportion \\(h\\) of \\(Aa\\) females not expressing the \\(a\\) allele choose mates at random. Finally, All \\(aa\\) females choose to mate with individuals sired by the same parental genotypes.\n\n\nCode\nfind_mating_type_frequencies &lt;- function(pop, prob_remating_SD, prob_remating_W){\n  \n  # Step 1\n  \n  pop$prop &lt;- pop$prop * pop$egg_adult_viability # here's the selection step \n  pop$prop &lt;- pop$prop / sum(pop$prop) # now restandardise so that the props sum to 1\n  \n  # Step 2\n  \n  # Calculate the frequency of each single-mating combination\n  \n  first_mating_types &lt;- \n    expand_grid(mother = pop$type[str_detect(pop$type, \"female\")], # find all possible mother genotypes\n                father = pop$type[!str_detect(pop$type, \"female\")]) %&gt;% # find all possible father1 genotypes\n    mutate(prop_matings = 0, remating_probability = 0) # make placeholder columns we will fill in below\n  \n  # find genotype frequencies calculated for each sex (mate choice means these will not necessarily be 50:50)\n  \n  female_frequencies &lt;- pop %&gt;% filter(str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  male_frequencies &lt;- pop %&gt;% filter(!str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  \n  # This next step multiplies the proportion[i] of females with genotype[i] with the proportion[i] of males with genotype[i] \n  \n  for(i in 1:nrow(first_mating_types)){\n    first_mating_types$prop_matings[i] &lt;- female_frequencies$prop[female_frequencies$type == first_mating_types$mother[i]] * \n      male_frequencies$prop[male_frequencies$type == first_mating_types$father1[i]]\n  }\n  \n  # Now we incorporate female remating probabilities (SDSD males assumed to have same effect on females as WW males)\n  \n  first_mating_types$remating_probability &lt;- ifelse(str_detect(first_mating_types$father1, \"WSD\"), prob_remating_SD, prob_remating_W)\n  \n  # Now lets calculate the frequency of each double-mating combination, with the end product being the mating_type_frequency of each mating possibility\n  \n  second_mating_types &lt;- expand_grid(first_mating_types, father2 = c(\"none\", unique(first_mating_types$father1))) %&gt;%\n    mutate(mating_type_freq = 0)\n  \n  # scale the proportion of matings calculated above by the likelihood that these females will mate once\n  \n  for(i in 1:nrow(second_mating_types)){\n    if(second_mating_types$father2[i] == \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        (1 - second_mating_types$remating_probability[i])\n    }\n    \n    # now calculate the frequency of mating tryads for the females that mate twice\n    \n    if(second_mating_types$father2[i] != \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        second_mating_types$remating_probability[i] *\n        male_frequencies$prop[male_frequencies$type == second_mating_types$father2[i]] # pop. freq of the 2nd male type\n    }\n  }\n  \n  second_mating_types %&gt;% # output\n    select(mother, father1, father2, mating_type_freq) %&gt;%\n    # clean up the output by remving redundant info (makes it easier later)\n    mutate(mother = str_remove_all(mother, \"_female\"),\n           father1 = str_remove_all(father1, \"_male\"),\n           father2 = str_remove_all(father2, \"_male\"))\n}\n\n\n\n\n\n\n\n\\(~\\)\nThis is hard, but everything should be in the Kokko and Ots paper\nWe can now directly follow Kokko and Ots (2006), altering the equations where required to reflect the fitness consequences of inbreeding for different chromosomes.\n\n\n\n\n\n\nParameter definitions\n\n\n\n\\(\\delta\\): fraction of offspring lost due to inbreeding (inbreeding depression)\n\\(v_I\\): ‘time in’ reproductive value of individuals of the choosing sex\n\\(w_I\\): ‘time in’ reproductive value of individuals of the opposite sex\n\\(v_O\\): ‘time out’ reproductive value of individuals of the choosing sex\n\\(w_O\\): ‘time out’ reproductive value of individuals of the opposite sex\n\\(M\\): the unrelated mate encounter rate during time in (when sex ratio is unbiased)\n\\(m_v = M \\sqrt{\\beta}\\): the mating rate for the choosy sex\n\\(m_w = \\frac{M}{\\sqrt{\\beta}}\\): the mating rate for the opposite sex\n\\(\\beta\\): the operational sex ratio (males:females)\n\\(a\\): average number of offspring produced from a mating (I think - needs to be found numerically)\n\\(T_v\\): time out duration for choosing sex\n\\(T_w\\): time out duration for opposite sex\n\\(\\mu_{Iv}\\): ‘time in’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Iw}\\): ‘time in’ mortality risk of individuals of the opposite sex\n\\(\\mu_{Ov}\\): ‘time out’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Ow}\\): ‘time out’ mortality risk of individuals of the opposite sex\n\n\nAfter mating, offspring are produced, with a direct fitness benefit of \\[a(v_I + w_I)\\]\n\n\nThe choosing sex can either mate with an unrelated individual or an individual related by \\(r\\).\nMate with unrelated individual: \\(v_O + ro_iw_I + a(v_I + w_1)\\)\nMate with kin: \\(v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1)\\)\nWe continue to frame our study around the value of \\(\\delta\\) that can be tolerated, or put another way, to what extent can inbreeding reduce offspring viability and still be the selected strategy?\nWe therefore rearrange the equation to find the threshold value of \\(\\delta\\) where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_O + ro_iw_I + a(v_I + w_1)\\]\nto\n\\[\\delta_{sim} = 1 - \\frac{a(v_I + w_I) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] which can be more neatly expressed as\n\\[\\delta_{sim} = \\frac{a ro_i(v_I + w_I) - ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\]\n\n\n\nIn this scenario, a choosy individual (note that our models are framed around the strategy adopted by the choosy individuals) encounters a single potential mate, related by \\(r\\). The choosing sex can either mate with this individual or elect not to mate and wait for a future opportunity.\nNot mating produces the inclusive fitness:\n\\[v_I + ro_iw_I\\] Now an inbreeding preference strategy is favoured where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_I + ro_iw_I\\]\nThus, the threshold \\(\\delta\\) value below which inbreeding is adaptive is\n\\[\\delta_{seq} = 1 - \\frac{(v_I - v_O) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] \\(~\\)\n\n\n\n\n\\(~\\)\n$$\n\\[\\begin{bmatrix}dv_I/dt\\\\\ndv_O/dt\\\\\ndw_I/dt\\\\\ndw_O/dt\n\\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix}-\\mu_{Iv} + m_v(a - 1)  & m_v & am_v &  0\\\\\n1/T_v & 1/T_v -\\mu_{Ov} & 0 & 0\\\\\nam_w & 0 & -\\mu_{Iw} + m_w(a - 1) & m_w\\\\\n0 & 0 & 1/Tw & 1/T_w -\\mu_{Ow}\n\\end{bmatrix}\\]\n\n\\[\\begin{bmatrix}v_I\\\\\nv_O\\\\\nw_I\\\\\nw_O\n\\end{bmatrix}\\]\n$$\n\n\n\nCode\nm1 &lt;- matrix(c(1:4), ncol = 1)\n\nm2 &lt;- matrix(c(1:16), nrow = 4, ncol = 4)\n\nm2 %*% m1\n\n\n     [,1]\n[1,]   90\n[2,]  100\n[3,]  110\n[4,]  120\n\n\nCreate a function to calculate reproductive value for each state\n\n\nCode\nchange_repro_values &lt;- \n  matrix(c(-1*death_rate_in_choosy_sex + mating_rate_choosy_sex *(a - 1),\n           mating_rate_choosy_sex,\n           a*mating_rate_choosy_sex,\n           0,\n           1/time_out_duration_choosy_sex,\n           -1/time_out_duration_choosy_sex - death_rate_out_choosy_sex,\n           0,\n           0,\n           a*mating_rate_opp_sex,\n           0,\n           -1*death_rate_in_opp_sex + mating_rate_opp_sex *(a - 1),\n           mating_rate_opp_sex,\n           0,\n           0,\n           1/time_out_duration_opp_sex,\n           -1/time_out_duration_opp_sex - death_rate_out_opp_sex),\n         nrow = 4, ncol = 4)\n\nstate_repro_values &lt;- c(vI, vO, wI, wO)\n\nparameters &lt;- \n  expand_grid(r = 0.5,\n              x = c(0, 0.5, 1),\n              death_rate_in_choosy_sex = 1,\n              mating_rate_choosy_sex = ,\n              time_out_duration_choosy_sex = c(0.1, 0.01),\n              death_rate_out_choosy_sex = 1,\n              mating_rate_opp_sex = ,\n              death_rate_in_opp_sex = 1,\n              time_out_duration_opp_sex = ,\n              death_rate_out_opp_sex = 1,\n              a = ((mating_rate_choosy_sex*(1/time_out_duration_choosy_sex + death_rate_in_choosy_sex)/\n                      (death_rate_out_choosy_sex/time_out_duration_choosy_sex + \n                         death_rate_in_choosy_sex*(mating_rate_choosy_sex + death_rate_out_choosy_sex)))^-1)/2\n  )"
  },
  {
    "objectID": "Selfish_inbreeding.html#changing-the-focus-from-chromosomes-to-alleles",
    "href": "Selfish_inbreeding.html#changing-the-focus-from-chromosomes-to-alleles",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "I think we can answer our question using the Kokko and Ots framework, but is it the right choice? Given we take a gene’s eye view, is a population genetic model (or if too difficult, a simulation) required.\nKin selection pop-gen models are well developed, by the time in, time out investment into reproduction dynamics is going to require lots of thinking on my behalf.\nThis is my first goal…\n\n\n\nLet’s build a single autosomal locus, bi-allelic model, assuming Hardy-Weinberg equilibrium.\n\nThe \\(A\\) allele is the ‘non-donor’ allele (can be thought of as an allele encoding outbreeding preference). The frequency of this allele is \\(p\\).\nThe \\(a\\) allele is the donor allele (the altruistic allele, which may encode inbreeding preference). The frequency of this allele is \\(q = 1 - p\\).\n\\(1 - h^2\\) is the likelihood that the \\(Aa\\) genotype exhibits the altruistic behaviour. If \\(h^2 = 1\\) then the allele is completely recessive.\n\nThe next step is to find all possible mating types:\n\n\nCode\nmake_mating_table &lt;- function(){#k, normalP1, P1cost, P2cost){\n  \n  make_offspring &lt;- function(X, Y, type, zygote_freq){\n    tibble(mother = X,\n           father = Y,\n           type,\n           zygote_freq)\n  }\n\n  # Set up the 9 possible mating combinations\n  \n  mating_types &lt;- expand_grid(\n    mother = c(\"AA_female\",\n               \"Aa_female\",\n               \"aa_female\"),\n    father = c(\"AA_male\",\n                \"Aa_male\",\n                \"aa_male\"))\n\n\n # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function\n  \n  # AA x AA\n  \n  g0 &lt;- c(\"AA_female\", \"AA_male\")\n  \n  # Aa x AA & AA x Aa\n  \n  g1 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\")\n  \n  # aa x AA & AA x aa\n  \n  g2 &lt;- c(\"Aa_female\", \"Aa_male\")\n  \n  # Aa x Aa\n  \n  g3 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # Aa x aa & aa x Aa\n  \n  g4 &lt;- c(\"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # aa x aa\n  \n  g5 &lt;- c(\"aa_female\", \"aa_male\")\n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # even frequency of four offspring types\n  \n  rep25 &lt;- rep(0.25, 4)\n  \n  # even frequency between two offspring types\n  \n  rep5 &lt;- rep(0.5, 2)\n  \n  # Aa * Aa\n  \n  p1 &lt;- c(0.5*0.25,\n          0.5*0.25,\n          0.5*0.5,\n          0.5*0.5,\n          0.5*0.25,\n          0.5*0.25)\n  \n    bind_rows(\n    list(\n      make_offspring(\"AA\", \"AA\", g0, rep5),\n      make_offspring(\"AA\", \"Aa\", g1, rep25),\n      make_offspring(\"AA\", \"aa\", g2, rep5),\n      make_offspring(\"Aa\", \"AA\", g1, rep25),\n      make_offspring(\"Aa\", \"Aa\", g3, p1),\n      make_offspring(\"Aa\", \"aa\", g4, rep25),\n      make_offspring(\"aa\", \"AA\", g2, rep5),\n      make_offspring(\"aa\", \"Aa\", g4, rep25),\n      make_offspring(\"aa\", \"aa\", g5, rep5)\n    )) %&gt;% \n    arrange(mother, father)\n  \n}\n\nmake_mating_table() %&gt;% \n  rename(zygote_type = type) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\nThe frequency of each mating type can be generated using the terms of the classic equation:\n\\[(p^2 + 2pq + q^2)^2\\] Note the final square generates the mating combination.\nThe frequencies of each genotype are\n\n\nCode\n(Mating_type_freqs &lt;-\n  tibble(mother = c(\"AA\",\"AA\",\"AA\",\"Aa\",\"Aa\",\"Aa\",\"aa\",\"aa\",\"aa\"),\n         father = c(\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\"),\n         frequency = c(\"(p^4)/2\", \"(4p^3*q)/2\", \"(2p^2*2q^2)/2\", \"(4p^3*q)/2\",\n                       \"(4p^2*q^2)/2\", \"(4p*q^3)/2\", \"(2p^2*2q^2)/2\", \"(4p*q^3)/2\",\n                       \"(q^4)/2\"\n                       )) %&gt;% \n  kable() %&gt;% \n    kable_styling())"
  },
  {
    "objectID": "Selfish_inbreeding.html#function-to-determine-the-mating-type-frequencies-of-the-population",
    "href": "Selfish_inbreeding.html#function-to-determine-the-mating-type-frequencies-of-the-population",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "This is a two-step process. First we determine the frequencies of each genotype in the mating population (this could be, for example, after we’ve accounted for inbreeding costs), then we calculate the frequencies of each potential mating combination between these genotypes.\nStep 1 - finding the genotype frequencies in the mating population\nHere we can model an inbreeding depression effect, by changing the viability of different genotypes. I make this a constant for now, to aid my initial understanding, but later this will be one of the key parameters to vary.\nI have also allowed the dominance of \\(a\\) to vary. While inbreeding depression is the result of the increased expression of recessive alleles through homozygosity, partially recessive alleles are likely to be common. When \\(h = 1\\), the \\(a\\) allele is completely recessive.\n\n\nCode\negg_adult_viability_Aa_finder &lt;- function(h){1 - 0.33*(1 - h)}\n\n\n# viability of each genotype \n\negg_adult_viability_AA_female &lt;- 1\n\negg_adult_viability_Aa_female &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_female &lt;- 0.67\n\negg_adult_viability_AA_male &lt;- 1\n\negg_adult_viability_Aa_male &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_male &lt;- 0.67\n\n\nUsing these parameters, we implement selection, so that each genotype is represented in the mating combinations according to the product of its frequency and its viability, which is determined by inbreeding depression. I assume that mating success is constant across genotypes (this may not be possible if one allele approaches extinction).\nStep 2 - finding the frequency of all potential mating combinations in the mating population\nNext, we model the effect of inbreeding preference on inclusive fitness (direct + indirect fitness). I first assume that individuals are faced with a simultaneous choice situation - between mating with a relative or mating with an unrelated individual.\nFor simplicity at the outset, I assume that inbreeding preference is only expressed in females. To simulate inbreeding preference, females carrying the \\(a\\) allele mate with siblings (those individuals produced by the same parental genotype combination). However, dominance also plays a role here. A proportion \\(1 - h\\) of \\(Aa\\) females express inbreeding preference, whereas a proportion \\(h\\) do not.\nWith the above in mind, I calculate the expected frequencies of each possible ‘mating combination’ (i.e. the combination of the maternal and paternal genotypes) across the population. For singly-mated females with genotype \\(AA\\), the frequency of each mating type is simply given by \\(F_iM_j\\), where \\(F_i\\) and \\(M_j\\) are the female and male parental genotype frequencies, that is they choose mates at random. For females with genotype \\(Aa\\) a proportion \\(1 - h\\) express a preference for inbreeding. For these females, the expected frequencies for each mating type are determined by the parental mating type combination they were produced by. These females randomly choose a mate from a subset of possible genotypes produced by the parental combination e.g. an \\(AA\\) x \\(aa\\) mating will produce a female that will choose to mate with a \\(Aa\\) male (the only possible genotype of her brothers). The proportion \\(h\\) of \\(Aa\\) females not expressing the \\(a\\) allele choose mates at random. Finally, All \\(aa\\) females choose to mate with individuals sired by the same parental genotypes.\n\n\nCode\nfind_mating_type_frequencies &lt;- function(pop, prob_remating_SD, prob_remating_W){\n  \n  # Step 1\n  \n  pop$prop &lt;- pop$prop * pop$egg_adult_viability # here's the selection step \n  pop$prop &lt;- pop$prop / sum(pop$prop) # now restandardise so that the props sum to 1\n  \n  # Step 2\n  \n  # Calculate the frequency of each single-mating combination\n  \n  first_mating_types &lt;- \n    expand_grid(mother = pop$type[str_detect(pop$type, \"female\")], # find all possible mother genotypes\n                father = pop$type[!str_detect(pop$type, \"female\")]) %&gt;% # find all possible father1 genotypes\n    mutate(prop_matings = 0, remating_probability = 0) # make placeholder columns we will fill in below\n  \n  # find genotype frequencies calculated for each sex (mate choice means these will not necessarily be 50:50)\n  \n  female_frequencies &lt;- pop %&gt;% filter(str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  male_frequencies &lt;- pop %&gt;% filter(!str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  \n  # This next step multiplies the proportion[i] of females with genotype[i] with the proportion[i] of males with genotype[i] \n  \n  for(i in 1:nrow(first_mating_types)){\n    first_mating_types$prop_matings[i] &lt;- female_frequencies$prop[female_frequencies$type == first_mating_types$mother[i]] * \n      male_frequencies$prop[male_frequencies$type == first_mating_types$father1[i]]\n  }\n  \n  # Now we incorporate female remating probabilities (SDSD males assumed to have same effect on females as WW males)\n  \n  first_mating_types$remating_probability &lt;- ifelse(str_detect(first_mating_types$father1, \"WSD\"), prob_remating_SD, prob_remating_W)\n  \n  # Now lets calculate the frequency of each double-mating combination, with the end product being the mating_type_frequency of each mating possibility\n  \n  second_mating_types &lt;- expand_grid(first_mating_types, father2 = c(\"none\", unique(first_mating_types$father1))) %&gt;%\n    mutate(mating_type_freq = 0)\n  \n  # scale the proportion of matings calculated above by the likelihood that these females will mate once\n  \n  for(i in 1:nrow(second_mating_types)){\n    if(second_mating_types$father2[i] == \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        (1 - second_mating_types$remating_probability[i])\n    }\n    \n    # now calculate the frequency of mating tryads for the females that mate twice\n    \n    if(second_mating_types$father2[i] != \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        second_mating_types$remating_probability[i] *\n        male_frequencies$prop[male_frequencies$type == second_mating_types$father2[i]] # pop. freq of the 2nd male type\n    }\n  }\n  \n  second_mating_types %&gt;% # output\n    select(mother, father1, father2, mating_type_freq) %&gt;%\n    # clean up the output by remving redundant info (makes it easier later)\n    mutate(mother = str_remove_all(mother, \"_female\"),\n           father1 = str_remove_all(father1, \"_male\"),\n           father2 = str_remove_all(father2, \"_male\"))\n}"
  },
  {
    "objectID": "Selfish_inbreeding.html#time-in-and-time-out",
    "href": "Selfish_inbreeding.html#time-in-and-time-out",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "\\(~\\)\nThis is hard, but everything should be in the Kokko and Ots paper\nWe can now directly follow Kokko and Ots (2006), altering the equations where required to reflect the fitness consequences of inbreeding for different chromosomes.\n\n\n\n\n\n\nParameter definitions\n\n\n\n\\(\\delta\\): fraction of offspring lost due to inbreeding (inbreeding depression)\n\\(v_I\\): ‘time in’ reproductive value of individuals of the choosing sex\n\\(w_I\\): ‘time in’ reproductive value of individuals of the opposite sex\n\\(v_O\\): ‘time out’ reproductive value of individuals of the choosing sex\n\\(w_O\\): ‘time out’ reproductive value of individuals of the opposite sex\n\\(M\\): the unrelated mate encounter rate during time in (when sex ratio is unbiased)\n\\(m_v = M \\sqrt{\\beta}\\): the mating rate for the choosy sex\n\\(m_w = \\frac{M}{\\sqrt{\\beta}}\\): the mating rate for the opposite sex\n\\(\\beta\\): the operational sex ratio (males:females)\n\\(a\\): average number of offspring produced from a mating (I think - needs to be found numerically)\n\\(T_v\\): time out duration for choosing sex\n\\(T_w\\): time out duration for opposite sex\n\\(\\mu_{Iv}\\): ‘time in’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Iw}\\): ‘time in’ mortality risk of individuals of the opposite sex\n\\(\\mu_{Ov}\\): ‘time out’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Ow}\\): ‘time out’ mortality risk of individuals of the opposite sex\n\n\nAfter mating, offspring are produced, with a direct fitness benefit of \\[a(v_I + w_I)\\]\n\n\nThe choosing sex can either mate with an unrelated individual or an individual related by \\(r\\).\nMate with unrelated individual: \\(v_O + ro_iw_I + a(v_I + w_1)\\)\nMate with kin: \\(v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1)\\)\nWe continue to frame our study around the value of \\(\\delta\\) that can be tolerated, or put another way, to what extent can inbreeding reduce offspring viability and still be the selected strategy?\nWe therefore rearrange the equation to find the threshold value of \\(\\delta\\) where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_O + ro_iw_I + a(v_I + w_1)\\]\nto\n\\[\\delta_{sim} = 1 - \\frac{a(v_I + w_I) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] which can be more neatly expressed as\n\\[\\delta_{sim} = \\frac{a ro_i(v_I + w_I) - ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\]\n\n\n\nIn this scenario, a choosy individual (note that our models are framed around the strategy adopted by the choosy individuals) encounters a single potential mate, related by \\(r\\). The choosing sex can either mate with this individual or elect not to mate and wait for a future opportunity.\nNot mating produces the inclusive fitness:\n\\[v_I + ro_iw_I\\] Now an inbreeding preference strategy is favoured where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_I + ro_iw_I\\]\nThus, the threshold \\(\\delta\\) value below which inbreeding is adaptive is\n\\[\\delta_{seq} = 1 - \\frac{(v_I - v_O) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] \\(~\\)\n\n\n\n\n\\(~\\)\n$$\n\\[\\begin{bmatrix}dv_I/dt\\\\\ndv_O/dt\\\\\ndw_I/dt\\\\\ndw_O/dt\n\\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix}-\\mu_{Iv} + m_v(a - 1)  & m_v & am_v &  0\\\\\n1/T_v & 1/T_v -\\mu_{Ov} & 0 & 0\\\\\nam_w & 0 & -\\mu_{Iw} + m_w(a - 1) & m_w\\\\\n0 & 0 & 1/Tw & 1/T_w -\\mu_{Ow}\n\\end{bmatrix}\\]\n\n\\[\\begin{bmatrix}v_I\\\\\nv_O\\\\\nw_I\\\\\nw_O\n\\end{bmatrix}\\]\n$$\n\n\n\nCode\nm1 &lt;- matrix(c(1:4), ncol = 1)\n\nm2 &lt;- matrix(c(1:16), nrow = 4, ncol = 4)\n\nm2 %*% m1\n\n\n     [,1]\n[1,]   90\n[2,]  100\n[3,]  110\n[4,]  120\n\n\nCreate a function to calculate reproductive value for each state\n\n\nCode\nchange_repro_values &lt;- \n  matrix(c(-1*death_rate_in_choosy_sex + mating_rate_choosy_sex *(a - 1),\n           mating_rate_choosy_sex,\n           a*mating_rate_choosy_sex,\n           0,\n           1/time_out_duration_choosy_sex,\n           -1/time_out_duration_choosy_sex - death_rate_out_choosy_sex,\n           0,\n           0,\n           a*mating_rate_opp_sex,\n           0,\n           -1*death_rate_in_opp_sex + mating_rate_opp_sex *(a - 1),\n           mating_rate_opp_sex,\n           0,\n           0,\n           1/time_out_duration_opp_sex,\n           -1/time_out_duration_opp_sex - death_rate_out_opp_sex),\n         nrow = 4, ncol = 4)\n\nstate_repro_values &lt;- c(vI, vO, wI, wO)\n\nparameters &lt;- \n  expand_grid(r = 0.5,\n              x = c(0, 0.5, 1),\n              death_rate_in_choosy_sex = 1,\n              mating_rate_choosy_sex = ,\n              time_out_duration_choosy_sex = c(0.1, 0.01),\n              death_rate_out_choosy_sex = 1,\n              mating_rate_opp_sex = ,\n              death_rate_in_opp_sex = 1,\n              time_out_duration_opp_sex = ,\n              death_rate_out_opp_sex = 1,\n              a = ((mating_rate_choosy_sex*(1/time_out_duration_choosy_sex + death_rate_in_choosy_sex)/\n                      (death_rate_out_choosy_sex/time_out_duration_choosy_sex + \n                         death_rate_in_choosy_sex*(mating_rate_choosy_sex + death_rate_out_choosy_sex)))^-1)/2\n  )"
  },
  {
    "objectID": "useful_cuts.html",
    "href": "useful_cuts.html",
    "title": "useful_cuts",
    "section": "",
    "text": "Code\nlibrary(tidyverse) # for tidy style coding and plotting\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\nlibrary(pander) # for tables\nlibrary(kableExtra) # for scrolling tables\n\n\n\nAttaching package: 'kableExtra'\n\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n\n\nCode\nlibrary(MetBrewer) # for colour palettes based upon artwork housed at the MET\nlibrary(MoMAColors) # for colour palettes based upon artwork housed at MoMA\n\n\nRegistered S3 method overwritten by 'MoMAColors':\n  method        from     \n  print.palette MetBrewer\n\n\nCode\nlibrary(wesanderson) # for colour palettes based on wes anderson movies\n\n\nRegistered S3 method overwritten by 'wesanderson':\n  method        from      \n  print.palette MoMAColors\n\n\nCode\nlibrary(tidybayes) # for plotting distributions\nlibrary(stickylabeller) # labelling facets with strings in ggplot\nlibrary(patchwork) # for combining plots \nlibrary(geomtextpath) # for curved plot annotations\nlibrary(ggtext) # for markdown syntax in plot labels\nlibrary(patchwork) # for patching plots together\nlibrary(ggnewscale) # to reset scales in plots, allowing multiple fill arguments in ggplot\nlibrary(data.table) # for efficient handling of large dataframes\n\n\n\nAttaching package: 'data.table'\n\nThe following objects are masked from 'package:lubridate':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\nThe following object is masked from 'package:purrr':\n\n    transpose\n\n\nCode\nlibrary(dtplyr) # for tidyverse functions that can be used on data tables\nCode\n# create the starting population\n\nset.seed(123)\n\ninitial_population &lt;- \n  tibble(Individual_ID = 1:10,\n         entrance_time = rep(0, 10),\n         Lifespan = round(rexp(10, 1), 2),\n         alive = \"YES\") %&gt;% \n  mutate(Mortality_time = entrance_time + Lifespan)\n\n# build the main simulation function\n\ncontinuous_time_simulation &lt;- function(starting_population){\n  \n  # we need this so that t is correctly matched to Mortality_time\n  \n  tolerance &lt;- 0.001\n  \n  # Initialize the timer t to 0\n  t &lt;- 0\n  \n  # Initialize the Individual_ID counter\n  Individual_ID_counter &lt;- 11\n  \n  # Run the simulation until t reaches 10\n  while (t &lt;= 1) {\n    \n    starting_population &lt;- \n      starting_population %&gt;% \n      mutate(time = t,\n             alive = if_else(Mortality_time &lt;= time, \"NO\", alive))\n    \n    # Check if any Mortality_time value matches the current time t - we use the tolerance variable to allow the small amount of wiggle room required to produce a match\n    \n    matching_condition &lt;- which(abs(starting_population$Mortality_time - t) &lt; tolerance)\n    #matching_condition &lt;- 10 - length(which(starting_population$alive == \"YES\"))\n    \n    # we can also add the length of the mated female subset, if 0 don't add a new row\n    \n    if (length(matching_condition) &gt; 0) {\n      #if (matching_condition &gt; 0) {\n      # Add new rows to the starting_population\n      new_rows &lt;- \n        tibble(\n          Individual_ID = Individual_ID_counter:(Individual_ID_counter + length(matching_condition) - 1),\n          entrance_time = rep(t, length(matching_condition)),\n          Lifespan = round(rexp(length(matching_condition)), 2),\n          alive = rep(\"YES\", length(matching_condition))) %&gt;% \n        mutate(Mortality_time = entrance_time + Lifespan)\n      \n      starting_population &lt;- bind_rows(starting_population, new_rows)\n      \n      # Update the Individual_ID counter\n      Individual_ID_counter &lt;- Individual_ID_counter + length(matching_condition)\n    }\n    \n    # Increment 't' by a small time step (e.g. 0.01)\n    t &lt;- t + 0.01\n  }\n  \n  # Print the simulation results\n  print(n = 20, starting_population)\n}\n\ncontinuous_time_simulation(initial_population)\nA very important point is that we consider a population where the resident strategy is to accept mating with a relative. Our simulation therefore estimates the condition required for inbreeding avoidance to invade. One consequence of inbreeding avoidance is an increased risk of going unmated for both sexes when they forego mating with a relative, particularly when the cost of mating for males is large, or search efficiency is low."
  },
  {
    "objectID": "useful_cuts.html#plot-the-results",
    "href": "useful_cuts.html#plot-the-results",
    "title": "useful_cuts",
    "section": "Plot the results",
    "text": "Plot the results\n\nWhen is inbreeding favoured in each sex?\n\n\nCode\npal1 &lt;- met.brewer(\"OKeeffe1\", n=100, direction = -1)\npal2 &lt;- met.brewer(\"Hiroshige\", n=50, direction = -1)\n  \nFemale_plot &lt;-\n  results %&gt;%\n  filter(v == 100, C != 2 & C != 4) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = female_fitness_contrast)) + \n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-100, -75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  geom_line(data = female_inbreeding_equilibria, aes(x = r, y = D),\n            linetype = 3, alpha = 0.5) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(C ~ a, \n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('C = {`C`}, a = {`a`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Alleles present in females\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", linewidth = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\nMale_plot &lt;-\n  results %&gt;%\n  filter(v == 100, C != 2 & C != 4) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = male_fitness_contrast)) + \n  stat_contour(aes(z = male_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = male_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  geom_line(data = male_inbreeding_equilibria, aes(x = r, y = D),\n            linetype = 3, alpha = 0.5) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(C ~ a, \n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('C = {`C`}, a = {`a`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Alleles present in males\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\nFemale_plot\n\nMale_plot\n\n\n\n\nWhen is there intragenomic conflict over inbreeding?\n\n\nCode\nIntragenomic_conflict &lt;-\n  results %&gt;%\n  filter(v == 100, C != 4, C != 2, C != 1) %&gt;% \n  select(1:5, female_fitness_contrast, male_fitness_contrast) %&gt;%\n  pivot_wider(names_from = a, values_from = c(female_fitness_contrast, male_fitness_contrast)) %&gt;% \n  mutate(intragenomic_conflict_f_0_0.5 = female_fitness_contrast_0.5 - female_fitness_contrast_0,\n         #intragenomic_conflict_f_0.5_1 = female_fitness_contrast_1 - female_fitness_contrast_0.5,\n         intragenomic_conflict_f_0_1 = female_fitness_contrast_1 - female_fitness_contrast_0,\n         intragenomic_conflict_m_0_0.5 = male_fitness_contrast_0.5 - male_fitness_contrast_0,\n         #intragenomic_conflict_m_0.5_1 = male_fitness_contrast_1 - male_fitness_contrast_0.5,\n         intragenomic_conflict_m_0_1 = male_fitness_contrast_1 - male_fitness_contrast_0) %&gt;%\n  pivot_longer(cols = contains(\"intragenomic\"), names_to = \"contrast\", values_to = \"intragenomic_conflict\") %&gt;%\n  mutate(contrast = str_remove(contrast, \"intragenomic_conflict_\")) %&gt;% \n  separate_wider_delim(cols = contrast, delim = \"_\", names = c(\"Sex\", \"a_2\", \"a_1\")) %&gt;% \n  unite(\"contrast\", a_1:a_2) %&gt;% \n    mutate(contrast = case_when(\n    contrast == \"0.5_0\" ~ \"a = 0.5 - a = 0\",\n    contrast == \"1_0\" ~ \"a = 1 - a = 0\")) %&gt;%\n  mutate(intragenomic_conflict = case_when(\n    female_fitness_contrast_0 &lt; 0 & female_fitness_contrast_0.5 &gt; 0 & Sex == \"f\" & contrast == \"a = 0.5 - a = 0\" \n    ~ intragenomic_conflict,\n    female_fitness_contrast_0 &lt; 0 & female_fitness_contrast_1 &gt; 0 & Sex == \"f\" & contrast == \"a = 1 - a = 0\" \n    ~ intragenomic_conflict,\n    male_fitness_contrast_0 &gt; 0 & male_fitness_contrast_0.5 &lt; 0 & Sex == \"m\" & contrast == \"a = 0.5 - a = 0\" \n    ~ intragenomic_conflict,\n    male_fitness_contrast_0 &gt; 0 & male_fitness_contrast_1 &lt; 0 & Sex == \"m\" & contrast == \"a = 1 - a = 0\" \n    ~ intragenomic_conflict,\n    .default = NA)) %&gt;% \n  select(1:4, Sex, contrast, contains(\"intragenomic\")) \n    \n\nmake_genomic_conflict_plot &lt;- \n  function(sex, enter_subtitle){\n    Intragenomic_conflict %&gt;%\n      filter(Sex == sex) %&gt;% \n      #mutate(C = as.numeric(C)) %&gt;% \n      ggplot(aes(x = r, y = D)) +\n      geom_blank() +\n      geom_tile(aes(fill = intragenomic_conflict)) + \n      #stat_contour(aes(z = intragenomic_conflict), colour = \"black\",\n       #     breaks = c(-.10, -.20, -.30, -.40, -.50, -.60, -.70, -.80, -.90, -.100,\n        #               .10, .20, .30, .40, .50, .60, .70, .80, .90, .100),\n         #   upright = TRUE) +\n      #stat_contour(aes(z = intragenomic_conflict*100), colour = \"black\", breaks = 0,\n       #    linetype = 2) +\n      scale_fill_gradientn(colours = pal2, limits = c(-1.25, 1.1), na.value = \"white\",\n                           labels = c(\"Strong conflict\", -0.5, \"No conflict\", 0.5, \"Strong conflict\")) +\n      facet_wrap(C~contrast, nrow = 2,\n                 scales = \"free\", strip.position = c(\"top\"),\n                 labeller = label_glue('contrast: {`contrast`}, C = {`C`}')) +\n      labs(x = expression(~italic(r)~', the relatedness coefficient'),\n           y = ~delta~'(inbreeding depression)',\n           fill = \"Intragenomic conflict\",\n           subtitle = enter_subtitle) +\n      scale_x_continuous(expand = c(0, 0)) + \n      scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n      theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n            strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n  }\n\nmake_genomic_conflict_plot(sex = \"f\", \"Intragenomic conflict in females\")\nmake_genomic_conflict_plot(sex = \"m\", \"Intragenomic conflict in males\")\n\n\n\n\nWhen is there sexual conflict over inbreeding?\n\n\nCode\nautosomal_data &lt;-\n  results %&gt;%\n  filter(a == 1, v == 100,C != 4, C != 1) %&gt;% \n  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;%\n   mutate(sexual_conflict_updated = \n           if_else(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0, sexual_conflict, NA),\n          Location = \"Autosomal\") \n\nX_data &lt;- \n  results %&gt;% \n  filter(a == 0.5, C != 4, C != 1, v == 100) %&gt;%  \n  select(1:5, contains(\"female\")) %&gt;% \n  rename(a_female = a) %&gt;% # this step makes the join work as intended\n  left_join(\n    results %&gt;% \n      filter(a == 1, C != 4, C != 1, v == 100) %&gt;% \n      select(1:5, starts_with(\"male\")) %&gt;% \n      rename(a_male = a) # this step makes the join work as intended\n  ) %&gt;%\n  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;% \n  mutate(sexual_conflict_updated = \n           if_else(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0, sexual_conflict, NA),\n         Location = \"X-linked\")\n\nZ_data &lt;-\n  results %&gt;% \n  filter(a == 1, C != 4, C != 1, v == 100) %&gt;%  \n  select(1:5, contains(\"female\")) %&gt;% \n  rename(a_female = a) %&gt;% left_join(\n    \n    results %&gt;% \n      filter(a == 0.5, C != 4, C != 1, v == 100) %&gt;% \n      select(1:5, starts_with(\"male\")) %&gt;% \n      rename(a_male = a)\n  ) %&gt;% \n  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;%\n    mutate(sexual_conflict_updated = \n             if_else(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0, sexual_conflict, NA),\n           Location = \"Z-linked\")\n\n\n\nSexual_conflict_plot &lt;-\n  bind_rows(autosomal_data, X_data, Z_data) %&gt;%\n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_tile(aes(fill = sexual_conflict_updated)) + \n  # stat_contour(aes(z = sexual_conflict_updated), colour = \"black\",\n  #      breaks = c(-.10, -.20, -.30, -.40, -.50, -.60, -.70, -.80, -.90, -.100,\n  #                .10, .20, .30, .40, .50, .60, .70, .80, .90, .100),\n  #    upright = TRUE) +\n  #stat_contour(aes(z = sexual_conflict*100), colour = \"black\", breaks = 0,\n  #    linetype = 2) +\n  scale_fill_gradientn(colours = pal2, limits = c(-1.25, 1.1), na.value = \"white\",\n                       labels = c(\"Strong conflict, female (+)\", -0.5, \n                                  \"No conflict\", 0.5, \"Strong conflict, male (+)\")) +\n  facet_wrap(Location~C, \n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('{`Location`}, C = {`C`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Intensity of\\nsexual conflict\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n  \nSexual_conflict_plot\n\n\n\n\nThe cytoplasmic case\nThe results for cytoplasmic alleles are intuitive. Inbreeding can evolve through selection on either sex, but there is very little sexual antagonism over inbreeding, as selection optimises female fitness in both cases. The extent to which the inbreeding strategy is favoured can vary but the sign will never be opposing.\n\n\nCode\nFemale_cyto_plot &lt;-\n  results %&gt;%\n  filter(v != 10, C != 2 & C != 4, a == 0) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = female_fitness_contrast)) + \n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-100, -75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(v ~ C, \n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('v = {`v`}, C = {`C`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Alleles present in females\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", linewidth = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", size = .8))\n\n\nMale_cyto_plot &lt;-\n  results %&gt;%\n  filter(v != 10, C != 2 & C != 4, a == 1) %&gt;%  \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_tile(aes(fill = cyto_male_fitness_contrast)) + \n  stat_contour(aes(z = cyto_male_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = cyto_male_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(v ~ C,\n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('v = {`v`}, C = {`C`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Cytoplasmic alleles present in males\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", size = .8))\n\nFemale_cyto_plot\n\nMale_cyto_plot"
  },
  {
    "objectID": "useful_text.html",
    "href": "useful_text.html",
    "title": "USeful_text",
    "section": "",
    "text": "Here, we set N = 1000 and find the encounter time for the \\(500^2\\) possible female-male encounters.\n\\(v\\) is one of the parameters that we can vary to change the risk of an individual going unmated. Here, we create candidate lists of mating events where \\(v = 1\\), \\(v =10\\), \\(v = 100\\) and \\(v = 1000\\) (where v = 100 equates to a search efficiency equal to the rate of mortality when \\(N = 1000)\\)."
  }
]